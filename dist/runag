#!/usr/bin/env bash

#  Copyright 2012-2025 Runag project contributors
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# This script was built from commit cbae47a1336261025c10f4613c7409ac749dcc5a

# Configure shell options unless the script is being sourced
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  # Enable trace output if RUNAG_VERBOSE is set to true
  if [ "${RUNAG_VERBOSE:-}" = true ]; then
    # Show subshell level, function name, source file, and line number in trace output
    PS4='+${FUNCNAME[0]:+" ${FUNCNAME[0]}"}${BASH_SOURCE:+" (${BASH_SOURCE}:${LINENO})"}   '
    set -o xtrace
  fi
  # Exit immediately if an unset variable is referenced
  set -o nounset
fi

apt::add_source_with_key () 
{ 
    local source_name="$1";
    local source_string="$2";
    local key_url="$3";
    local temp_file;
    temp_file="$(mktemp)" || softfail "Failed to create temporary file for key." || return $?;
    curl --fail --silent --show-error "${key_url}" | gpg --dearmor > "${temp_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to get key or save it: ${key_url}" || return $?;
    file::write --sudo --mode 0644 --consume "${temp_file}" "/etc/apt/keyrings/${source_name}.gpg" || softfail "Failed to write GPG key to keyring." || return $?;
    file::write --sudo --mode 0644 "/etc/apt/sources.list.d/${source_name}.list" <<< "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/${source_name}.gpg] ${source_string}" || softfail "Failed to add repository source: ${source_name}" || return $?;
    apt::update || softfail "Failed to update apt sources after adding new repository." || return $?
}
apt::autoremove () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y autoremove || softfail "Failed to autoremove unnecessary packages." || return $?
}
apt::install () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y install "$@" || softfail "Failed to install packages: $*" || return $?
}
apt::remove () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y remove "$@" || softfail "Failed to remove packages: $*" || return $?
}
apt::update () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get update || softfail "Failed to update package list." || return $?
}
apt::upgrade () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y upgrade || softfail "Failed to upgrade packages." || return $?
}
asdf::extend_package_list::arch () 
{ 
    package_list+=(curl git)
}
asdf::extend_package_list::debian () 
{ 
    package_list+=(curl git)
}
asdf::install () 
{ 
    local set_global=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -g | --global)
                set_global=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local plugin_name="$1";
    local package_version="${2:-"latest"}";
    asdf plugin add "${plugin_name}" || softfail || return $?;
    asdf plugin update "${plugin_name}" || softfail || return $?;
    asdf install "${plugin_name}" "${package_version}" || softfail || return $?;
    if [ "${set_global}" = true ]; then
        asdf global "${plugin_name}" "${package_version}" || softfail || return $?;
    fi
}
asdf::install_self () 
{ 
    local version_tag;
    version_tag="v0.15.0";
    git::place_up_to_date_clone --branch "${version_tag}" "https://github.com/asdf-vm/asdf.git" "${HOME}/.asdf" || softfail || return $?
}
asdf::install_shellfile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "profile/asdf" <<SHELL || 
${license_text}

if [ -f "\${HOME}/.asdf/asdf.sh" ]; then
  . "\${HOME}/.asdf/asdf.sh" || { echo "Unable to load asdf" >&2; return 1; }
fi
SHELL
 softfail || return $?
    shellfile::write "rc/asdf" <<SHELL || 
${license_text}

if [ -f "\${HOME}/.asdf/asdf.sh" ]; then
  . "\${HOME}/.asdf/asdf.sh" || { echo "Unable to load asdf" >&2; return 1; }

  if [ -n "\${BASH_VERSION:-}" ]; then
    . "\${HOME}/.asdf/completions/asdf.bash" || { echo "Unable to load asdf completions" >&2; return 1; }

  elif [ -n "\${ZSH_VERSION:-}" ]; then
    fpath=(\${ASDF_DIR}/completions \${fpath}) || { echo "Unable to set fpath" >&2; return 1; }
    autoload -Uz compinit || { echo "Unable to set compinit function to autoload" >&2; return 1; }
    compinit || { echo "Unable to run compinit" >&2; return 1; }

  fi
fi
SHELL
 softfail || return $?
}
asdf::load () 
{ 
    . "${HOME}/.asdf/asdf.sh" || softfail "Unable to load asdf" || return $?
}
aws::pass::create_access_key () 
{ 
    local pass_path;
    local user_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -u | --user-name)
                user_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local access_key;
    access_key="$(aws iam create-access-key --user-name "${user_name}")" || softfail || return $?;
    jq --raw-output --exit-status .AccessKey.AccessKeyId <<< "${access_key}" | pass insert --multiline "${pass_path}/id";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    jq --raw-output --exit-status .AccessKey.SecretAccessKey <<< "${access_key}" | pass insert --multiline "${pass_path}/secret";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
aws::pass::write_credentials_file () 
{ 
    local credentials_file;
    local pass_path;
    local profile_name="default";
    local ssh_call=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --credentials-file)
                credentials_file="$2";
                shift;
                shift
            ;;
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -e | --profile)
                profile_name="$2";
                shift;
                shift
            ;;
            -r | --ssh-call)
                ssh_call=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local command_prefix=();
    local default_credentials_dir="${HOME}/.aws";
    if [ "${ssh_call}" = true ]; then
        command_prefix+=("ssh::call");
        default_credentials_dir=".aws";
    fi;
    credentials_file="${credentials_file:-"${AWS_SHARED_CREDENTIALS_FILE:-"${default_credentials_dir}/credentials"}"}";
    local credentials_dir;
    credentials_dir="$(dirname "${credentials_file}")" || softfail || return $?;
    "${command_prefix[@]}" dir::ensure_exists --mode 0700 "${credentials_dir}" || softfail || return $?;
    local aws_access_key_id;
    aws_access_key_id="$(pass::use "${pass_path}/id")" || softfail || return $?;
    local aws_secret_access_key;
    aws_secret_access_key="$(pass::use "${pass_path}/secret")" || softfail || return $?;
    "${command_prefix[@]}" file::write --mode 0600 --section "PROFILE ${profile_name}" "${credentials_file}" <<INI || 
[${profile_name}]
aws_access_key_id=${aws_access_key_id}
aws_secret_access_key=${aws_secret_access_key}
INI
 softfail || return $?
}
benchmark::is_available () 
{ 
    if [[ "${OSTYPE}" =~ ^linux ]] || [[ "${OSTYPE}" =~ ^darwin ]]; then
        if command -v sysbench > /dev/null; then
            return 0;
        fi;
    fi;
    return 1
}
benchmark::run () 
{ 
    local hostname_string;
    hostname_string="$(hostnamectl --static status)" || softfail || return $?;
    local current_date;
    current_date="$(date --utc "+%Y-%m-%dT%H%M%SZ")" || softfail || return $?;
    local result_file;
    result_file="$(mktemp "benchmark-${hostname_string}-${current_date}-XXXX.txt")" || softfail || return $?;
    benchmark::run::indeed | tee "${result_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
benchmark::run::indeed () 
{ 
    ( echo "## CPU SPEED ##";
    sysbench cpu run || softfail || return $?;
    echo "## THREADS ##";
    sysbench threads run || softfail || return $?;
    echo "## RAM WRITE, 4KiB BLOCKS ##";
    sysbench memory run --memory-block-size=4096 || softfail || return $?;
    local temp_dir;
    temp_dir="$(mktemp -d "${HOME}/.benchmark-XXXXXX")" || softfail || return $?;
    cd "${temp_dir}" || softfail || return $?;
    sysbench fileio prepare --verbosity=2 --file-extra-flags=direct || softfail || return $?;
    sync || softfail || return $?;
    echo "## RANDOM READ QD1 ##";
    sysbench fileio run --file-test-mode=rndrd --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off --file-extra-flags=direct || softfail || return $?;
    echo "## RANDOM WRITE QD1 ##";
    sysbench fileio run --file-test-mode=rndwr --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on --file-extra-flags=direct || softfail || return $?;
    if ! [[ "${OSTYPE}" =~ ^darwin ]]; then
        echo "## RANDOM READ QD32 ##";
        sysbench fileio run --file-test-mode=rndrd --file-io-mode=async --file-async-backlog=32 --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off || softfail || return $?;
        echo "## RANDOM WRITE QD32 ##";
        sysbench fileio run --file-test-mode=rndwr --file-io-mode=async --file-async-backlog=32 --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on || softfail || return $?;
    fi;
    echo "## SEQUENTIAL READ ##";
    sysbench fileio run --file-test-mode=seqrd --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off --file-extra-flags=direct || softfail || return $?;
    echo "## SEQUENTIAL WRITE ##";
    sysbench fileio run --file-test-mode=seqwr --file-extra-flags=sync --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on --file-extra-flags=direct || softfail || return $?;
    sysbench fileio cleanup --verbosity=2 || softfail || return $?;
    rmdir "${temp_dir}" || softfail || return $? )
}
btrfs::check () 
{ 
    sudo btrfs check --readonly --progress "$@" || softfail || return $?
}
btrfs::scrub () 
{ 
    sudo btrfs scrub start "$@" || softfail || return $?
}
btrfs::scrub_status () 
{ 
    sudo btrfs scrub status -d "$@" || softfail || return $?
}
checksum::create_or_update () 
{ 
    local directory="$1";
    local current_checksum_file="$2";
    local checksum_algo="sha3-256";
    local new_checksum_file;
    new_checksum_file="$(mktemp)" || softfail || return $?;
    ( cd "${directory}" || softfail || return $?;
    find . -type f ! -path "./${current_checksum_file}" "${@:3}" -exec openssl dgst "-${checksum_algo}" {} \; | LC_ALL=C sort > "${new_checksum_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    if [ ! -f "${current_checksum_file}" ]; then
        if [ "${RUNAG_CREATE_CHECKSUMS_WITHOUT_CONFIRMATION:-}" != true ]; then
            cat "${new_checksum_file}" || softfail || return $?;
        fi;
        if [ "${RUNAG_CREATE_CHECKSUMS_WITHOUT_CONFIRMATION:-}" = true ] || ui::confirm "Do you want to create the checksum file: ${directory}/${current_checksum_file} (yes/no)?"; then
            cp "${new_checksum_file}" "${current_checksum_file}" || softfail || return $?;
            if [ -d .git ]; then
                git add "${current_checksum_file}" || softfail || return $?;
                git commit -m "Creates checksum file" "${current_checksum_file}" || softfail || return $?;
            fi;
        fi;
        exit 0;
    fi;
    if diff --strip-trailing-cr "${current_checksum_file}" "${new_checksum_file}" > /dev/null 2>&1; then
        echo "Checksums are good: ${directory}/${current_checksum_file}";
        exit 0;
    fi;
    if command -v git > /dev/null; then
        git diff --ignore-cr-at-eol --color --unified=6 --no-index "${current_checksum_file}" "${new_checksum_file}" | tee;
    else
        diff --strip-trailing-cr --context=6 --color "${current_checksum_file}" "${new_checksum_file}";
    fi;
    if ui::confirm "Do you want to update the checksum file: ${directory}/${current_checksum_file} (yes/no)?"; then
        cp "${new_checksum_file}" "${current_checksum_file}" || softfail || return $?;
        if [ -d .git ]; then
            git add "${current_checksum_file}" || softfail || return $?;
            git commit -m "Updates checksum file" "${current_checksum_file}" || softfail || return $?;
        fi;
    fi );
    local result=$?;
    rm "${new_checksum_file}" || softfail || return $?;
    sync || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "checksum::create_or_update failed (${result})" || return $?;
    fi
}
checksum::verify () 
{ 
    ( local directory="$1";
    local current_checksum_file="$2";
    local checksum_algo="sha3-256";
    local new_checksum_file;
    new_checksum_file="$(mktemp)" || softfail || return $?;
    ( cd "${directory}" || softfail || return $?;
    if [ ! -f "${current_checksum_file}" ]; then
        softfail "Unable to find the checksum file: ${directory}/${current_checksum_file}" || return $?;
    fi;
    find . -type f ! -path "./${current_checksum_file}" "${@:3}" -exec openssl dgst "-${checksum_algo}" {} \; | LC_ALL=C sort > "${new_checksum_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    if diff --strip-trailing-cr "${current_checksum_file}" "${new_checksum_file}" > /dev/null 2>&1; then
        echo "Checksums are good: ${directory}/${current_checksum_file}";
        exit 0;
    fi;
    if command -v git > /dev/null; then
        git diff --ignore-cr-at-eol --color --unified=6 --no-index "${current_checksum_file}" "${new_checksum_file}" | tee;
    else
        diff --strip-trailing-cr --context=6 --color "${current_checksum_file}" "${new_checksum_file}";
    fi;
    softfail "Checksums are different (!): ${directory}/${current_checksum_file}" || return $? );
    local result=$?;
    rm "${new_checksum_file}" || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "checksum::verify failed (${result})" || return $?;
    fi )
}
cifs::credentials () 
{ 
    local credentials_file="$1";
    local cifs_username="$2";
    local cifs_password="$3";
    printf "username=%s\npassword=%s\n" "${cifs_username}" "${cifs_password}" | file::write --mode 0600 "${credentials_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
cifs::credentials::exists () 
{ 
    local credentials_file="$1";
    test -f "${credentials_file}"
}
cifs::mount () 
{ 
    local file_mode="0600";
    local dir_mode="0700";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --file-mode)
                file_mode="$2";
                shift;
                shift
            ;;
            -d | --dir-mode)
                dir_mode="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local server_path="$1";
    local mount_point="$2";
    local credentials_file="$3";
    dir::ensure_exists --mode "${dir_mode}" "${mount_point}" || softfail || return $?;
    local fstab_tag="# cifs mount: ${mount_point}";
    if ! grep -qFx "${fstab_tag}" /etc/fstab; then
        echo "${fstab_tag}" | sudo tee -a /etc/fstab > /dev/null || softfail || return $?;
        echo "${server_path} ${mount_point} cifs credentials=${credentials_file},uid=${USER},forceuid,gid=${USER},forcegid,file_mode=${file_mode},dir_mode=${dir_mode},nosetuids,echo_interval=10,noserverino,noposix  0  0" | sudo tee -a /etc/fstab > /dev/null || softfail || return $?;
    fi;
    sudo mount -a;
    findmnt --mountpoint "${mount_point}" > /dev/null || softfail "Filesystem is not mounted: ${mount_point}" || return $?
}
config::install () 
{ 
    local src="$1";
    local dst="$2";
    if [ -f "${dst}" ]; then
        config::merge "${src}" "${dst}" || softfail || return $?;
    else
        cp "${src}" "${dst}" || softfail || return $?;
    fi
}
config::merge () 
{ 
    local src="$1";
    local dst="$2";
    if [ -t 0 ]; then
        if [ -f "${dst}" ]; then
            if ! diff --strip-trailing-cr "${src}" "${dst}" > /dev/null 2>&1; then
                if command -v git > /dev/null; then
                    git diff --ignore-cr-at-eol --color --unified=6 --no-index "${dst}" "${src}" | tee;
                else
                    diff --strip-trailing-cr --context=6 --color "${dst}" "${src}";
                fi;
                local action;
                echo "Files are different:";
                echo "  ${src}";
                echo "  ${dst}";
                echo "Please choose an action to perform:";
                echo "  1: Use file from the repository to replace file on this machine (apply the patch shown above)";
                echo "  2: Use file from this machine to save it to the repository";
                echo "  3 (or Enter): Ignore conflict";
                IFS="" read -r action || softfail || return $?;
                if [ "${action}" = 1 ]; then
                    cp "${src}" "${dst}" || softfail || return $?;
                else
                    if [ "${action}" = 2 ]; then
                        cp "${dst}" "${src}" || softfail || return $?;
                    fi;
                fi;
            fi;
        fi;
    fi
}
cross_platform::config_home () 
{ 
    case "${OSTYPE}" in 
        linux*)
            echo "${XDG_CONFIG_HOME:-"${HOME}/.config"}"
        ;;
        darwin*)
            echo "${HOME}/Library/Application Support"
        ;;
        msys*)
            echo "${APPDATA}"
        ;;
        *)
            softfail "Platform is not supported" || return $?
        ;;
    esac
}
dir::ensure_exists () 
{ 
    local mode;
    local owner;
    local group;
    local sudo;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -m | --mode)
                mode="$2";
                shift 2
            ;;
            -o | --owner)
                owner="$2";
                shift 2
            ;;
            -g | --group)
                group="$2";
                shift 2
            ;;
            -s | --sudo)
                sudo=true;
                shift
            ;;
            -u | --user-only)
                mode="${mode:-0700}";
                owner="${USER}";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1";
                return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local path="$1";
    if [ -n "${mode:-}" ]; then
        if ! [[ "${mode}" =~ ^[0-7]+$ ]]; then
            softfail "Invalid mode: Mode should be numeric" || return $?;
        fi;
        local umask_value;
        umask_value="$(printf "0%o" "$(( 0777 - "0${mode}" ))")" || softfail "Failed to calculate umask value" || return $?;
        if [ "${sudo:-}" = true ]; then
            sudo --shell '$SHELL' -c "$(printf "umask %q && mkdir -p %q" "${umask_value}" "${path}")" || softfail "Failed to create directory with sudo and specified mode" || return $?;
        else
            ( umask "${umask_value}" && mkdir -p "${path}" ) || softfail "Failed to create directory with specified mode" || return $?;
        fi;
        ${sudo:+"sudo"} chmod "${mode}" "${path}" || softfail "Failed to set permissions on the directory" || return $?;
    else
        ${sudo:+"sudo"} mkdir -p "${path}" || softfail "Failed to create directory" || return $?;
    fi;
    if [ -n "${owner:-}" ]; then
        if [ -z "${group:-}" ]; then
            group="$(id -g -n "${owner}")" || softfail "Failed to retrieve group for owner '${owner}'" || return $?;
        fi;
        ${sudo:+"sudo"} chown "${owner}:${group}" "${path}" || softfail "Failed to set ownership to ${owner}:${group}" || return $?;
    else
        if [ -n "${group:-}" ]; then
            ${sudo:+"sudo"} chgrp "${group}" "${path}" || softfail "Failed to set group ownership to '${group}'" || return $?;
        fi;
    fi
}
direnv::is_allowed () 
{ 
    ( local envrc_path="${1:-".envrc"}";
    local envrc_dir envrc_basename envrc_realpath status_output;
    envrc_dir="$(dirname "${envrc_path}")" || softfail "Failed to get directory from path" || return $?;
    envrc_basename="$(basename "${envrc_path}")" || softfail "Failed to get filename from path" || return $?;
    cd "${envrc_dir}" || softfail "Failed to change to directory: ${envrc_dir}" || return $?;
    envrc_realpath="${PWD}/${envrc_basename}";
    status_output="$(direnv status --json)" || softfail "Failed to get direnv status" || return $?;
    jq --raw-output --exit-status --arg envrc_realpath "${envrc_realpath}" '((.state | has("foundRC")) and ((.state.foundRC == null) or (.state.foundRC.allowed == 0 and .state.foundRC.path == $envrc_realpath)))' <<< "${status_output}" > /dev/null )
}
erlang::extend_package_list::arch () 
{ 
    package_list+=(base-devel fop libssh libxslt ncurses)
}
erlang::extend_package_list::debian () 
{ 
    package_list+=(autoconf build-essential fop libncurses5-dev libssh-dev libxml2-utils m4 xsltproc)
}
erlang::extend_package_list::observer::arch () 
{ 
    package_list+=(glu libpng mesa wxwidgets-gtk3)
}
erlang::extend_package_list::observer::debian () 
{ 
    local -a webview_packages;
    mapfile -t webview_packages < <(apt-cache --names-only search '^libwxgtk-webview.*-dev' | cut -d " " -f 1) || softfail || return $?;
    package_list+=(libgl1-mesa-dev libglu1-mesa-dev libpng-dev "${webview_packages[@]}")
}
fail () 
{ 
    local exit_status=1;
    local unless_good=false;
    local ignore_statuses;
    local perform_softfail=false;
    local trace_start=1;
    local message;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --status)
                if [ -z "${2:-}" ] || [[ "$2" =~ ^- ]]; then
                    printf "Missing argument for '%s' option.\n" "$1" 1>&2;
                    shift;
                else
                    if [[ ! "$2" =~ ^[0-9]+$ || "$2" -lt 0 || "$2" -gt 255 ]]; then
                        printf "Status code '%s' must be a number between 0 and 255.\n" "$2" 1>&2;
                        shift 2;
                    else
                        exit_status="$2";
                        shift 2;
                    fi;
                fi
            ;;
            -g | --unless-good)
                unless_good=true;
                shift
            ;;
            -u | --unless)
                if [ -z "${2:-}" ] || [[ "$2" =~ ^- ]]; then
                    printf "Missing argument for '%s' option.\n" "$1" 1>&2;
                    shift;
                else
                    ignore_statuses="$2";
                    shift 2;
                fi
            ;;
            -f | --soft)
                perform_softfail=true;
                shift
            ;;
            -w | --from-softfail-wrapper)
                perform_softfail=true;
                trace_start=2;
                shift
            ;;
            -*)
                printf "Unrecognized argument: '%s'.\n" "$1" 1>&2;
                shift;
                message="$*";
                break
            ;;
            *)
                message="$*";
                break
            ;;
        esac;
    done;
    if [ -z "${message:-}" ]; then
        message="An error occurred; refer to the stack trace for context.";
    fi;
    if [ "${unless_good}" = true ] && [ "${exit_status}" = 0 ]; then
        return 0;
    fi;
    if [ -n "${ignore_statuses:-}" ]; then
        local ignore_array ignore_item ignore_start ignore_end;
        IFS=',' read -ra ignore_array <<< "${ignore_statuses}";
        for ignore_item in "${ignore_array[@]}";
        do
            if [[ "${ignore_item}" =~ ^[0-9]+-[0-9]+$ ]]; then
                IFS='-' read -r ignore_start ignore_end <<< "${ignore_item}";
                if (( exit_status >= ignore_start && exit_status <= ignore_end )); then
                    return 0;
                fi;
            else
                if ! [[ "${ignore_item}" =~ ^[0-9]+$ ]]; then
                    printf "Ignored pattern '%s' is not a valid number or range.\n" "${ignore_item}" 1>&2;
                else
                    if [[ "${exit_status}" = "${ignore_item}" ]]; then
                        return 0;
                    fi;
                fi;
            fi;
        done;
    fi;
    if [ "${exit_status}" = 0 ]; then
        exit_status=1;
    fi;
    local error_prefix="[ERROR] " error_postfix="";
    if [ -t 2 ]; then
        error_prefix="$(printf "setaf 9\nbold" | tput -S 2> /dev/null)";
        error_postfix="$(tput sgr 0 2> /dev/null)";
    fi;
    printf "%s%s%s\n" "${error_prefix}" "${message}" "${error_postfix}" 1>&2;
    local trace_index trace_end=$((${#BASH_LINENO[@]} - 1));
    for ((trace_index=trace_start; trace_index<=trace_end; trace_index++))
    do
        printf "%s    at %s (%s:%s)%s\n" "${error_prefix}" "${FUNCNAME[${trace_index}]}" "${BASH_SOURCE[${trace_index}]}" "${BASH_LINENO[$((trace_index-1))]}" "${error_postfix}" 1>&2;
    done;
    if [ "${perform_softfail}" = true ]; then
        return "${exit_status}";
    fi;
    exit "${exit_status}"
}
file::read_section () 
{ 
    test -n "${1:-}" || softfail "Section name is required." || return $?;
    test -n "${2:-}" || softfail "File path is required." || return $?;
    local section_name="$1";
    local file_path="$2";
    if [ ! -f "${file_path}" ]; then
        softfail "File '${file_path}' does not exist." || return $?;
    fi;
    local file_lines;
    local section_lines=();
    local line;
    local state="search";
    mapfile -t file_lines < "${file_path}" || softfail "Failed to read content from '${file_path}'." || return $?;
    for line in "${file_lines[@]}";
    do
        case "${state}" in 
            search)
                if [ "${line}" = "# BEGIN ${section_name}" ]; then
                    state="within-section";
                fi
            ;;
            within-section)
                if [ "${line}" = "# END ${section_name}" ]; then
                    state="section-found";
                    break;
                else
                    section_lines+=("${line}");
                fi
            ;;
        esac;
    done;
    if [ "${state}" != "section-found" ]; then
        softfail "Section '${section_name}' not found in '${file_path}'." || return $?;
    fi;
    for line in "${section_lines[@]}";
    do
        printf "%s\n" "${line}" || softfail "Failed to print content of section '${section_name}'." || return $?;
    done
}
file::section_envelope () 
{ 
    local section_name="$1";
    printf "# BEGIN %s\n" "${section_name}" || softfail "Failed to write start marker for section '${section_name}'." || return $?;
    sed "\$a\\" || softfail "Failed to append newline to input content for section '${section_name}'." || return $?;
    printf "# END %s\n" "${section_name}" || softfail "Failed to write end marker for section '${section_name}'." || return $?
}
file::write () 
{ 
    local mode;
    local owner;
    local group;
    local sudo;
    local mkdir=false;
    local method;
    local source_file;
    local allow_empty;
    local filter_function;
    local filter_arguments_count;
    local filter_command=();
    local file_path;
    local dir_path;
    local dir_mode;
    local umask_value;
    local temp_file;
    local existing_file_temp;
    local filter_output_temp;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -m | --mode)
                if [ -z "${2:-}" ]; then
                    softfail "Error: Missing argument for $1 option" || return $?;
                fi;
                mode="$2";
                shift 2
            ;;
            -o | --owner)
                if [ -z "${2:-}" ]; then
                    softfail "Error: Missing argument for $1 option" || return $?;
                fi;
                owner="$2";
                shift 2
            ;;
            -g | --group)
                if [ -z "${2:-}" ]; then
                    softfail "Error: Missing argument for $1 option" || return $?;
                fi;
                group="$2";
                shift 2
            ;;
            -s | --sudo)
                sudo=true;
                shift
            ;;
            -r | --root)
                mode="${mode:-0644}";
                owner="root";
                sudo=true;
                shift
            ;;
            -u | --user-only)
                mode="${mode:-0600}";
                owner="${USER}";
                shift
            ;;
            -d | --mkdir)
                mkdir=true;
                shift
            ;;
            -c | --copy)
                if [ -z "${2:-}" ]; then
                    softfail "Error: Missing argument for $1 option" || return $?;
                fi;
                method="copy";
                source_file="$2";
                shift 2
            ;;
            -n | --consume)
                if [ -z "${2:-}" ]; then
                    softfail "Error: Missing argument for $1 option" || return $?;
                fi;
                method="consume";
                source_file="$2";
                shift 2
            ;;
            -p | --capture)
                method="capture";
                shift
            ;;
            -e | --allow-empty)
                allow_empty=true;
                shift
            ;;
            --*)
                filter_function="${1#--}";
                filter_function="file::write_filter::${filter_function//-/_}";
                if ! declare -F "${filter_function}" > /dev/null; then
                    softfail "Unknown option '${1}' or filter function '${filter_function}' is not defined." || return $?;
                fi;
                filter_command=("${filter_function}");
                shift;
                filter_arguments_count="$("${filter_function}" --parse-arguments "$@")" || softfail "Filter argument parsing failed for '${filter_function}'." || return $?;
                if ! [[ "${filter_arguments_count}" =~ ^[0-9]+$ ]]; then
                    softfail "Filter '${filter_function}' returned non-numeric value when parsing arguments." || return $?;
                fi;
                if [ "${filter_arguments_count}" -gt 0 ]; then
                    filter_command+=("${@:1:${filter_arguments_count}}");
                    shift "${filter_arguments_count}";
                fi
            ;;
            -*)
                softfail "Unrecognized option: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${1:-}" ]; then
        softfail "Error: A file path must be provided as an argument." || return $?;
    fi;
    file_path="$1";
    shift;
    if [ -z "${method:-}" ]; then
        if [ $# = 0 ]; then
            method="fetch";
        else
            method="string";
        fi;
    fi;
    if ${sudo:+"sudo"} test -e "${file_path}"; then
        if ! ${sudo:+"sudo"} test -w "${file_path}"; then
            softfail "The file exists but the user does not have write access: ${file_path}" || return $?;
        fi;
        if ! ${sudo:+"sudo"} test -f "${file_path}"; then
            softfail "The file exists but it is not a regular file: ${file_path}" || return $?;
        fi;
    fi;
    if [ -n "${source_file:-}" ] && ! [ -r "${source_file}" ]; then
        softfail "Source file does not exist or is not readable: ${source_file}" || return $?;
    fi;
    if [ "${mkdir}" = true ]; then
        dir_path="$(dirname "${file_path}")" || softfail "Failed to determine the directory path from ${file_path}" || return $?;
        if [ -n "${mode:-}" ]; then
            dir_mode=$(( "0${mode}" )) || softfail "Failed to parse mode value: ${mode}" || return $?;
            dir_mode=$(( (dir_mode & 0400) == 0400 ? (dir_mode | 0100) : dir_mode )) || softfail "Failed to adjust directory mode for user execute permissions" || return $?;
            dir_mode=$(( (dir_mode & 040) == 040 ? (dir_mode | 010) : dir_mode )) || softfail "Failed to adjust directory mode for group execute permissions" || return $?;
            dir_mode=$(( (dir_mode & 04) == 04 ? (dir_mode | 01) : dir_mode )) || softfail "Failed to adjust directory mode for other execute permissions" || return $?;
            printf -v dir_mode "0%o" "${dir_mode}" || softfail "Failed to format directory mode as octal" || return $?;
        fi;
        dir::ensure_exists ${dir_mode:+--mode "${dir_mode}"} ${owner:+--owner "${owner}"} ${group:+--group "${group}"} ${sudo:+"--sudo"} "${dir_path}" || softfail "Failed to ensure the directory exists: ${dir_path}" || return $?;
    fi;
    if ${sudo:+"sudo"} test -f "${file_path}"; then
        if [ -z "${mode:-}" ]; then
            mode="$(${sudo:+"sudo"} stat -c %a "${file_path}")" || softfail "Failed to retrieve file permissions for ${file_path}" || return $?;
        fi;
        if [ -z "${owner:-}" ]; then
            owner="$(${sudo:+"sudo"} stat -c %U "${file_path}")" || softfail "Failed to retrieve file owner for ${file_path}" || return $?;
        fi;
        if [ -z "${group:-}" ]; then
            group="$(${sudo:+"sudo"} stat -c %G "${file_path}")" || softfail "Failed to retrieve file group for ${file_path}" || return $?;
        fi;
    fi;
    if [ -z "${mode:-}" ]; then
        if [ "${sudo:-}" = true ]; then
            umask_value="$(sudo --shell umask)" || softfail "Failed to retrieve umask value with sudo" || return $?;
        else
            umask_value="$(umask)" || softfail "Failed to retrieve umask value" || return $?;
        fi;
        mode="$(printf "%o" "$(( 0666 ^ "${umask_value}" ))")" || softfail "Failed to calculate mode from umask" || return $?;
    fi;
    if [ -z "${owner:-}" ]; then
        if [ "${sudo:-}" = true ]; then
            owner=root;
        else
            owner="${USER}";
        fi;
    fi;
    if [ -z "${group:-}" ]; then
        group="$(id -g -n "${owner}")" || softfail "Failed to retrieve group for owner '${owner}'" || return $?;
    fi;
    temp_file="$(mktemp)" || softfail "Failed to create a temporary file" || return $?;
    case "$method" in 
        copy | consume)
            cat "${source_file}" > "${temp_file}" || softfail "Failed to copy data from source file '${source_file}' to temporary file" || return $?
        ;;
        capture)
            "$@" > "${temp_file}" || softfail "Failed to capture output and write to temporary file" || return $?
        ;;
        fetch)
            if [ -t 0 ]; then
                softfail "Stdin cannot be a terminal for file::write. Use a data source or specify a different input method" || return $?;
            fi;
            cat > "${temp_file}" || softfail "Failed to read input from stdin and write to temporary file" || return $?
        ;;
        string)
            if [ -n "$*" ]; then
                printf "%s\n" "$*" > "${temp_file}" || softfail "Failed to write string data to temporary file" || return $?;
            fi
        ;;
        -*)
            softfail "Unknown input method specified: $1" || return $?
        ;;
    esac;
    if [ ${#filter_command[@]} -gt 0 ]; then
        if ${sudo:+"sudo"} test -f "${file_path}"; then
            existing_file_temp="$(mktemp)" || softfail "Could not create a temporary file to store existing content." || return $?;
            ${sudo:+"sudo"} cat "${file_path}" > "${existing_file_temp}" || softfail "Copying existing content to a temporary file did not work." || return $?;
        fi;
        filter_output_temp="$(mktemp)" || softfail "Something went wrong while creating a temporary file for filtered output." || return $?;
        "${filter_command[@]}" "${existing_file_temp:-}" < "${temp_file}" > "${filter_output_temp}" || softfail "Filtering process failed to complete successfully." || return $?;
        mv "${filter_output_temp}" "${temp_file}" || softfail "Could not update the temporary file with the filtered content." || return $?;
        if [ -n "${existing_file_temp:-}" ]; then
            rm "${existing_file_temp}" || softfail "Cleaning up the temporary file for existing content didn't work." || return $?;
        fi;
    fi;
    if [ "${allow_empty:-}" != true ] && [ ! -s "${temp_file}" ]; then
        rm "${temp_file}" || softfail "Failed to remove the temporary file: ${temp_file}" || return $?;
        softfail "Empty input is not permitted for file::write unless the --allow-empty flag is specified." || return $?;
    fi;
    ${sudo:+"sudo"} chown "${owner}:${group}" "${temp_file}" || softfail "Failed to change ownership of ${temp_file} to ${owner}:${group}" || return $?;
    ${sudo:+"sudo"} chmod "${mode}" "${temp_file}" || softfail "Failed to set permissions (${mode}) on ${temp_file}" || return $?;
    ${sudo:+"sudo"} mv "${temp_file}" "${file_path}" || softfail "Failed to move ${temp_file} to ${file_path}" || return $?;
    if [ "${method}" = consume ]; then
        rm "${source_file}" || softfail "Failed to remove the source file: ${source_file}" || return $?;
    fi
}
file::write_filter::append_line_unless_present () 
{ 
    if [ "${1:-}" = "--parse-arguments" ]; then
        echo 0;
        return;
    fi;
    local existing_file="${1:-}";
    local input_data;
    input_data="$(head -n 1)" || softfail "Failed to read input data from standard input." || return $?;
    if [ -n "${existing_file}" ] && [ -s "${existing_file}" ]; then
        if grep -qFx "${input_data}" "${existing_file}"; then
            cat "${existing_file}" || softfail "Failed to read file '${existing_file}'." || return $?;
            return;
        else
            sed "\$a\\" "${existing_file}" || softfail "Could not append newline to '${existing_file}'." || return $?;
        fi;
    fi;
    printf "%s\n" "${input_data}" || softfail "Failed to write input data to output." || return $?
}
file::write_filter::section () 
{ 
    if [ "${1:-}" = "--parse-arguments" ]; then
        echo 1;
        return;
    fi;
    test -n "${1:-}" || softfail "Section name is required." || return $?;
    local section_name="$1";
    local existing_file="${2:-}";
    local existing_lines;
    local line;
    local state="search";
    if [ -n "${existing_file}" ] && [ -s "${existing_file}" ]; then
        mapfile -t existing_lines < "${existing_file}" || softfail "Failed to read content from '${existing_file}'." || return $?;
        for line in "${existing_lines[@]}";
        do
            case "${state}" in 
                search)
                    if [ "${line}" = "# BEGIN ${section_name}" ]; then
                        state="within-section";
                        file::section_envelope "${section_name}" || softfail "Failed to write updated section '${section_name}'." || return $?;
                    else
                        printf '%s\n' "${line}" || softfail "Failed to write preserved line before section '${section_name}'." || return $?;
                    fi
                ;;
                within-section)
                    if [ "${line}" = "# END ${section_name}" ]; then
                        state="section-found";
                    fi
                ;;
                section-found)
                    printf '%s\n' "${line}" || softfail "Failed to write preserved line after section '${section_name}'." || return $?
                ;;
            esac;
        done;
        case "${state}" in 
            within-section)
                softfail "Section '${section_name}' is missing an end marker." || return $?
            ;;
            section-found)
                return
            ;;
        esac;
    fi;
    file::section_envelope "${section_name}" || softfail "Failed to append new section '${section_name}'." || return $?
}
firefox::enable_wayland () 
{ 
    shellfile::write "profile/firefox-enable-wayland" <<SHELL || 
export MOZ_ENABLE_WAYLAND=1
SHELL
 softfail || return $?
}
firefox::set_pref () 
{ 
    local name="$1";
    local value="$2";
    local prefs_line="user_pref(\"${name}\", ${value});";
    local profile_dir;
    for profile_dir in "${HOME}/.mozilla/firefox"/*.default-release;
    do
        if [ -d "${profile_dir}" ]; then
            local prefs_file="${profile_dir}/prefs.js";
            if ! grep -qFx "${prefs_line}" "${prefs_file}"; then
                echo "${prefs_line}" >> "${prefs_file}" || softfail || return $?;
            fi;
        fi;
    done
}
fs::convert_msys_path_to_windows () 
{ 
    sed "s/^\\/\\([[:alpha:]]\\)\\//\\1:\\//" <<< "$1" | sed "s/\\//\\\\/g";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
fs::get_absolute_path () 
{ 
    local relative_path="$1";
    local path_basename;
    path_basename="$(basename "${relative_path}")" || softfail "Unable to get a basename of '${relative_path}' ($?)" || return $?;
    local unresolved_dir;
    unresolved_dir="$(dirname "${relative_path}")" || softfail "Unable to get a dirname of '${relative_path}'" || return $?;
    local resolved_dir;
    resolved_dir="$(cd "${unresolved_dir}" > /dev/null 2>&1 && pwd)" || softfail "Unable to determine absolute path for '${unresolved_dir}'" || return $?;
    echo "${resolved_dir}/${path_basename}"
}
fs::update_symlink () 
{ 
    local target_thing="$1";
    local link_name="$2";
    if [ -e "${link_name}" ] && [ ! -L "${link_name}" ]; then
        softfail "Unable to create/update symlink, some non-link file exists: ${link_name}";
        return $?;
    fi;
    ln --symbolic --force --no-dereference "${target_thing}" "${link_name}" || softfail || return $?
}
fs::wait_until_mounted () 
{ 
    local mountpoint="$1";
    if ! findmnt --mountpoint "${mountpoint}" > /dev/null; then
        echo "Filesystem is not mounted: '${mountpoint}'" 1>&2;
        echo "Please connect the external media if the filesystem resides on it" 1>&2;
        echo "Waiting for the filesystem to be available, press Control-C to interrupt" 1>&2;
    fi;
    while ! findmnt --mountpoint "${mountpoint}" > /dev/null; do
        sleep 0.1;
    done
}
fs::with_secure_temp_dir_if_available () 
{ 
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        linux::with_secure_temp_dir "$@";
    else
        "$@";
    fi
}
fstab::add_mount_option () 
{ 
    local fstype;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --filesystem-type)
                fstype="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local option="$1";
    local skip;
    skip="$(sed 's/^\([[:alnum:]]\+\).*/\1/' <<< "${option}")" || softfail || return $?;
    sed "/^\(#\|[[:graph:]]\+[[:blank:]]\+[[:graph:]]\+[[:blank:]]\+${fstype}[[:blank:]]\+.*[[:blank:][:punct:]]${skip}\([[:blank:][:punct:]]\|$\)\)/!s/^\([[:graph:]]\+[[:blank:]]\+[[:graph:]]\+[[:blank:]]\+${fstype}[[:blank:]]\+defaults\)\([^[:alnum:]]\|$\)/\1,${option}\2/g;" /etc/fstab | fstab::verify_and_write;
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Error adding mount option to /etc/fstab" || return $?
}
fstab::verify_and_write () 
{ 
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    cat > "${temp_file}" || softfail "Error writing to temp file: ${temp_file}" || return $?;
    test -s "${temp_file}" || softfail "Error: fstab candidate should have size greater that zero: ${temp_file}" || return $?;
    findmnt --verify --tab-file "${temp_file}" 2>&1 || softfail "Failed to verify fstab candidate: ${temp_file}" || return $?;
    file::write --sudo --mode 0664 --consume "${temp_file}" /etc/fstab || softfail "Failed to install new fstab: ${temp_file}" || return $?
}
git::add_or_update_remote () 
{ 
    local remote_name="$1";
    local remote_url="$2";
    if ! git config "remote.${remote_name}.url" > /dev/null; then
        git remote add "${remote_name}" "${remote_url}" || softfail || return $?;
    else
        git config "remote.${remote_name}.url" "${remote_url}" || softfail || return $?;
    fi
}
git::add_signed_off_by_trailer_in_commit_msg_hook () 
{ 
    ( local dest_path="${1:-}";
    if [ -n "${dest_path}" ]; then
        cd "${dest_path}" || softfail || return $?;
    fi;
    if [ ! -d .git ]; then
        softfail "Not in a git folder: ${PWD}" || return $?;
    fi;
    local hook_file=".git/hooks/commit-msg";
    if [ -s "${hook_file}" ]; then
        if [ "$(head -n 1 "${hook_file}")" != "#!/bin/sh" ]; then
            softfail "Not a /bin/sh script: ${hook_file}" || return $?;
        fi;
    else
        file::write "${hook_file}" "#!/bin/sh" || softfail || return $?;
    fi;
    chmod u+x "${hook_file}" || softfail || return $?;
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    file::write --section "add-signed-off-by-trailer" "${hook_file}" <<SHELL || 
${license_text}

user_name="\$(git config user.name)" || exit 1
user_email="\$(git config user.email)" || exit 1

git interpret-trailers --if-exists addIfDifferent --trailer "Signed-off-by: \${user_name} <\${user_email}>" --in-place "\$1"
SHELL
 softfail || return $? )
}
git::clone_or_update_local_mirror () 
{ 
    local source_path="$1";
    local dest_path="$2";
    local remote_name="${3:-}";
    local source_path_full;
    source_path_full="$(cd "${source_path}" > /dev/null 2>&1 && pwd)" || softfail || return $?;
    if [ ! -d "${dest_path}" ]; then
        git clone "${source_path_full}" "${dest_path}" || softfail || return $?;
        local mirror_origin;
        mirror_origin="$(git -C "${source_path_full}" remote get-url origin)" || softfail || return $?;
        git -C "${dest_path}" remote set-url origin "${mirror_origin}" || softfail || return $?;
        if [ -n "${remote_name}" ]; then
            git -C "${dest_path}" remote add "${remote_name}" "${source_path_full}" || softfail || return $?;
        fi;
    else
        git -C "${dest_path}" pull "${remote_name}" main || softfail || return $?;
    fi
}
git::create_or_update_mirror () 
{ 
    local source_url="$1";
    local dest_path="$2";
    if [ -d "${dest_path}" ]; then
        ( cd "${dest_path}" && git remote update ) || softfail || return $?;
    else
        git clone --mirror "${source_url}" "${dest_path}" || softfail || return $?;
    fi
}
git::ensure_git_is_installed () 
{ 
    ( if [[ "${OSTYPE}" =~ ^linux ]]; then
        if ! command -v git > /dev/null; then
            . /etc/os-release || softfail || return $?;
            if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
                apt::update || softfail || return $?;
                apt::install git || softfail || return $?;
            else
                if [ "${ID:-}" = arch ]; then
                    sudo pacman --sync --sysupgrade --refresh --noconfirm || softfail || return $?;
                    sudo pacman --sync --needed --noconfirm git || softfail || return $?;
                else
                    softfail "Unable to install git, your operating system is not supported" || return $?;
                fi;
            fi;
        fi;
    else
        if [[ "${OSTYPE}" =~ ^darwin ]]; then
            git --version > /dev/null || softfail "Please install git" || return $?;
        else
            if ! command -v git > /dev/null; then
                softfail "Unable to install git, your operating system is not supported" || return $?;
            fi;
        fi;
    fi )
}
git::get_remote_url_without_username () 
{ 
    local remote_name="${1:-"origin"}";
    git remote get-url "${remote_name}" | sed 's/^https:\/\/[[:alnum:]_]\+@/https:\/\//';
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
git::gnome_keyring_credentials () 
{ 
    local server="$1";
    local login="$2";
    local password="$3";
    echo -n "${password}" | secret-tool store --label="Git: https://${server}/" server "${server}" user "${login}" protocol https xdg:schema org.gnome.keyring.NetworkPassword;
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
git::gnome_keyring_credentials::exists () 
{ 
    local server="$1";
    local login="$2";
    secret-tool lookup server "${server}" user "${login}" protocol https xdg:schema org.gnome.keyring.NetworkPassword > /dev/null
}
git::install_libsecret_credential_helper () 
{ 
    if [ ! -f /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret ]; then
        ( cd /usr/share/doc/git/contrib/credential/libsecret && sudo make ) || softfail "Unable to compile libsecret" || return $?;
    fi
}
git::install_profile_from_pass () 
{ 
    local pass_path="$1";
    if pass::exists "${pass_path}/user-name"; then
        local user_name;
        user_name="$(pass::use "${pass_path}/user-name")" || softfail || return $?;
        git config "${@:2}" user.name "${user_name}" || softfail || return $?;
    fi;
    if pass::exists "${pass_path}/user-email"; then
        local user_email;
        user_email="$(pass::use "${pass_path}/user-email")" || softfail || return $?;
        git config "${@:2}" user.email "${user_email}" || softfail || return $?;
    fi;
    if pass::exists "${pass_path}/signing-key"; then
        local signing_key;
        signing_key="$(pass::use "${pass_path}/signing-key")" || softfail || return $?;
        git config "${@:2}" commit.gpgsign true || softfail || return $?;
        git config "${@:2}" user.signingkey "${signing_key}" || softfail || return $?;
    fi
}
git::is_local_remote_connected () 
{ 
    local remote_name="${1:-"origin"}";
    local remote_path;
    remote_path="$(git config "remote.${remote_name}.url")" || fail "Remote url not found";
    if [[ ! "${remote_path}" =~ ^/ ]]; then
        fail "Remote path should be an absolute path: ${remote_path}";
    fi;
    [ -d "${remote_path}" ] && [ -f "${remote_path}/config" ]
}
git::is_remote_local () 
{ 
    local remote_name="${1:-"origin"}";
    local remote_path;
    remote_path="$(git config "remote.${remote_name}.url")" || fail "Remote url not found";
    if [[ "${remote_path}" =~ ^/ ]]; then
        return 0;
    fi;
    return 1
}
git::place_up_to_date_clone () 
{ 
    local branch_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -b | --branch)
                local branch_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local remote_url="$1";
    local dest_path="$2";
    if [ -d "${dest_path}" ]; then
        local current_url;
        current_url="$(cd "${dest_path}" && git config remote.origin.url)" || softfail || return $?;
        if [ "${current_url}" != "${remote_url}" ]; then
            git::remove_current_clone "${dest_path}" || softfail || return $?;
        fi;
    fi;
    if [ ! -d "${dest_path}" ]; then
        git clone "${remote_url}" "${dest_path}" || softfail "Unable to clone ${remote_url}" || return $?;
    fi;
    if [ -n "${branch_name:-}" ]; then
        ( cd "${dest_path}" && git remote update ) || softfail "Unable to perform git remote update: ${dest_path}" || return $?;
        ( cd "${dest_path}" && git fetch ) || softfail "Unable to perform git fetch: ${dest_path}" || return $?;
        ( cd "${dest_path}" && git checkout "${branch_name}" ) || softfail "Unable to perform git checkout: ${dest_path}" || return $?;
    else
        ( cd "${dest_path}" && git pull ) || softfail "Unable to perform git pull: ${dest_path}" || return $?;
    fi
}
git::remove_current_clone () 
{ 
    local dest_path="$1";
    local dest_full_path;
    dest_full_path="$(cd "${dest_path}" > /dev/null 2>&1 && pwd)" || softfail || return $?;
    local dest_parent_dir;
    dest_parent_dir="$(dirname "${dest_full_path}")" || softfail || return $?;
    local dest_dir_name;
    dest_dir_name="$(basename "${dest_full_path}")" || softfail || return $?;
    local backup_path;
    backup_path="$(mktemp -u "${dest_parent_dir}/${dest_dir_name}-PREVIOUS-CLONE-XXXXXXXXXX")" || softfail || return $?;
    mv "${dest_full_path}" "${backup_path}" || softfail || return $?
}
git::use_libsecret_credential_helper () 
{ 
    ( local libsecret_path;
    . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        libsecret_path="/usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret";
    else
        if [ "${ID:-}" = arch ]; then
            libsecret_path="/usr/lib/git-core/git-credential-libsecret";
        else
            softfail "Your operating system is not supported" || return $?;
        fi;
    fi;
    if [ ! -f "${libsecret_path}" ]; then
        softfail "Unable to find libsecret: ${libsecret_path}" || return $?;
    fi;
    git config --global credential.helper "${libsecret_path}" || softfail || return $? )
}
github::download_release () 
{ 
    local release_id="latest";
    local query_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --release-id)
                release_id="$2";
                shift;
                shift
            ;;
            -q | --query)
                query_string="$2";
                shift;
                shift
            ;;
            -l | --asset-label)
                query_string=".assets[] | select(.label == \"$2\").browser_download_url";
                shift;
                shift
            ;;
            -n | --asset-name)
                query_string=".assets[] | select(.name | test(\"$2\")).browser_download_url";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${query_string:-}" ]; then
        softfail "Query string should be specified" || return $?;
    fi;
    local repo_path="$1";
    local file_url;
    file_url="$(github::query_release --release-id "${release_id}" --query "${query_string}" "${repo_path}")" || softfail || return $?;
    if [ -z "${file_url}" ]; then
        softfail "Can't find release URL for ${repo_path} that matched ${query_string} and release ${release_id}" || return $?;
    fi;
    local temp_file;
    temp_file="$(mktemp)" || softfail "Unable to create temp file" || return $?;
    curl --location --fail --silent --show-error --output "${temp_file}" "${file_url}" > /dev/null || softfail "Unable to download ${file_url}" || return $?;
    echo "${temp_file}"
}
github::install_profile_from_pass () 
{ 
    local pass_path="$1";
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        git::use_libsecret_credential_helper || softfail || return $?;
        local github_username;
        github_username="$(pass::use "${pass_path}/username")" || softfail || return $?;
        pass::use "${pass_path}/personal-access-token" git::gnome_keyring_credentials "github.com" "${github_username}" || softfail || return $?;
    fi
}
github::query_release () 
{ 
    local release_id="latest";
    local query_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --release-id)
                release_id="$2";
                shift;
                shift
            ;;
            -g | --get)
                query_string=".$2";
                shift;
                shift
            ;;
            -q | --query)
                query_string="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${query_string:-}" ]; then
        softfail "Query string should be specified" || return $?;
    fi;
    local repo_path="$1";
    local api_url="https://api.github.com/repos/${repo_path}/releases/${release_id}";
    curl --fail --silent --show-error "${api_url}" | jq --raw-output --exit-status "${query_string}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
gpg::get_key_uid () 
{ 
    local source_path="$1";
    gpg --import --import-options show-only "${source_path}" | grep '^uid ' | head -n 1 | sed -E 's/^uid[[:space:]]+(.*)/\1/';
    test "${PIPESTATUS[*]}" = "0 0 0 0" || softfail || return $?
}
gpg::import_key () 
{ 
    local skip_if_exists trust_level should_confirm;
    local list_keys_command="--list-keys";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --confirm)
                should_confirm=true;
                shift
            ;;
            -s | --skip-if-exists)
                skip_if_exists=true;
                shift
            ;;
            -m | --trust-marginally)
                trust_level=4;
                shift
            ;;
            -f | --trust-fully)
                trust_level=5;
                shift
            ;;
            -u | --trust-ultimately)
                trust_level=6;
                shift
            ;;
            -e | --secret-key)
                list_keys_command="--list-secret-keys";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local gpg_key_id="$1";
    local source_path="$2";
    local trust_levels=(- - - - marginally fully ultimately);
    if [ "${skip_if_exists:-}" = true ] && gpg "${list_keys_command}" "${gpg_key_id}" > /dev/null 2>&1; then
        return 0;
    fi;
    if [ "${should_confirm:-}" = true ]; then
        local key_with_spaces;
        key_with_spaces="$(sed -E 's/(.{4})/\1 /g' <<< "${gpg_key_id}" | sed 's/ $//'; test "${PIPESTATUS[*]}" = "0 0")" || softfail || return $?;
        local key_base64;
        key_base64="$(xxd -r -p <<< "${gpg_key_id}" | base64 | sed -E 's/(.{4})/\1 /g' | sed 's/ $//'; test "${PIPESTATUS[*]}" = "0 0 0 0")" || softfail || return $?;
        echo "";
        echo "You are about to import GPG key with id: ${gpg_key_id}.";
        if [ -n "${trust_level:-}" ]; then
            echo "Trust level for that key will be set to \"Trust ${trust_levels[${trust_level}]}\"";
        fi;
        echo "Space-separated key id: ${key_with_spaces}";
        echo "Base64-encoded key id: ${key_base64}";
        echo "";
        echo "Data to be imported:";
        echo "";
        gpg --import --import-options show-only "${source_path}" || softfail || return $?;
        echo "Please confirm that it is your intention to do so by entering \"yes\"";
        echo "Please prepare the key password if needed";
        echo "Please enter \"no\" if you want to continue without this key being imported.";
        if ! ui::confirm; then
            log::warning "Key was not imported" || softfail || return $?;
            return 0;
        fi;
    fi;
    gpg --import "${source_path}" || softfail || return $?;
    if [ -n "${trust_level:-}" ]; then
        echo "${gpg_key_id}:${trust_level}:" | gpg --import-ownertrust || softfail || return $?;
    fi
}
imagemagick::set_policy::resource () 
{ 
    local policy_path="/etc/ImageMagick-6/policy.xml";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --policy-path)
                policy_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local name="$1";
    local value="$2";
    sudo sed --in-place "s/^.*\(<policy domain=\"resource\" name=\"${name}\" value=\"\).*\(\"\/>\)$/\1${value}\2/g" "${policy_path}" || softfail || return $?
}
leaseweb::domains::clear_acme_challenge () 
{ 
    leaseweb::domains::clear_record "_acme-challenge.${CERTBOT_DOMAIN}" TXT || softfail || return $?
}
leaseweb::domains::clear_record () 
{ 
    local record="$1";
    local record_type="$2";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    curl --fail --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request DELETE --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?
}
leaseweb::domains::extract_domain_from_host () 
{ 
    grep -E --only-matching "[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-]+$" <<< "$1" || softfail || return $?
}
leaseweb::domains::get_short_record () 
{ 
    local record="$1";
    local record_type="$2";
    leaseweb::domains::list "${record}" "${record_type}" | jq --exit-status 'del(._links, .editable)';
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
leaseweb::domains::list () 
{ 
    local record="$1";
    local record_type="$2";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    curl --fail --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --request GET --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?
}
leaseweb::domains::set_acme_challenge () 
{ 
    leaseweb::domains::set_record "_acme-challenge.${CERTBOT_DOMAIN}" 1m TXT "${CERTBOT_VALIDATION}" || softfail || return $?
}
leaseweb::domains::set_record () 
{ 
    local record="$1";
    local record_ttl="$2";
    local record_type="$3";
    local record_data="$4";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    if [ "${record_ttl}" = 1m ]; then
        record_ttl=60;
    else
        if [ "${record_ttl}" = 5m ]; then
            record_ttl=300;
        else
            if [ "${record_ttl}" = 30m ]; then
                record_ttl=1800;
            else
                if [ "${record_ttl}" = 1h ]; then
                    record_ttl=3600;
                else
                    if [ "${record_ttl}" = 4h ]; then
                        record_ttl=14400;
                    else
                        if [ "${record_ttl}" = 8h ]; then
                            record_ttl=28800;
                        else
                            if [ "${record_ttl}" = 12h ]; then
                                record_ttl=43200;
                            else
                                if [ "${record_ttl}" = 1d ]; then
                                    record_ttl=86400;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    local domain_exists;
    domain_exists="$(curl --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request GET --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" --write-out "%{http_code}")" || softfail || return $?;
    if [ "${domain_exists}" = 200 ]; then
        curl --data "{ \"content\": [\"${record_data}\"], \"ttl\": ${record_ttl} }" --fail --header "content-type: application/json" --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request PUT --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?;
    else
        if [ "${domain_exists}" = 404 ]; then
            curl --data "{ \"name\": \"${record}.\", \"type\": \"${record_type}\", \"content\": [\"${record_data}\"], \"ttl\": ${record_ttl} }" --fail --header "content-type: application/json" --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request POST --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets" || softfail || return $?;
        else
            softfail "Domain check returned HTTP status code: ${domain_exists}";
            return $?;
        fi;
    fi
}
leaseweb::function_sources () 
{ 
    declare -f leaseweb::domains::get_short_record || softfail || return $?;
    declare -f leaseweb::domains::list || softfail || return $?;
    declare -f leaseweb::domains::set_record || softfail || return $?;
    declare -f leaseweb::domains::clear_record || softfail || return $?;
    declare -f leaseweb::domains::set_acme_challenge || softfail || return $?;
    declare -f leaseweb::domains::clear_acme_challenge || softfail || return $?;
    declare -f leaseweb::domains::extract_domain_from_host || softfail || return $?
}
letsencrypt::agree_tos_and_register_unsafely_without_email () 
{ 
    if [ ! -d /etc/letsencrypt/accounts ] || [ -z "$(ls -A /etc/letsencrypt/accounts)" ]; then
        sudo letsencrypt register --agree-tos --register-unsafely-without-email --non-interactive || softfail || return $?;
    fi
}
linux::adduser () 
{ 
    local user_name="${*: -1}";
    if ! id -u "${user_name}" > /dev/null 2>&1; then
        sudo adduser "$@" || softfail || return $?;
    fi
}
linux::configure_inotify () 
{ 
    local max_user_watches="1048576";
    local max_user_instances="2048";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -w | --max-user-watches)
                max_user_watches="$2";
                shift;
                shift
            ;;
            -i | --max-user-instances)
                max_user_instances="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    file::write --sudo --mode 0644 /etc/sysctl.d/runag-inotify.conf <<EOF || 
fs.inotify.max_user_watches=${max_user_watches}
fs.inotify.max_user_instances=${max_user_instances}
EOF
 softfail || return $?
    sudo sysctl --system || softfail || return $?
}
linux::get_default_path_env () 
{ 
    ( . /etc/environment && echo "${PATH}" || softfail || return $? )
}
linux::get_default_route () 
{ 
    ip route show | grep 'default via' | awk '{print $3}';
    test "${PIPESTATUS[*]}" = "0 0 0" || softfail || return $?
}
linux::get_home_dir () 
{ 
    local user_name="$1";
    getent passwd "${user_name}" | cut -d : -f 6;
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
linux::get_ipv4_address () 
{ 
    local ip_address;
    ip_address="$(ip route get 1.1.1.1 2> /dev/null | sed -n 's/^.*src \([[:digit:].]*\).*$/\1/p'; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain host ipv6 address" || return $?;
    if [ -z "${ip_address}" ]; then
        softfail "Unable to obtain host ipv6 address" || return $?;
    fi;
    echo "${ip_address}"
}
linux::get_ipv6_address () 
{ 
    local ip_address;
    ip_address="$(ip route get 2606:4700:4700::1111 2> /dev/null | sed -n 's/^.*src \([[:xdigit:]:]*\).*$/\1/p'; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain host ipv6 address" || return $?;
    if [ -z "${ip_address}" ]; then
        softfail "Unable to obtain host ipv6 address" || return $?;
    fi;
    echo "${ip_address}"
}
linux::install_gnome_keyring_and_libsecret () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::install gnome-keyring libsecret-tools libsecret-1-0 libsecret-1-dev || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm gnome-keyring libsecret || softfail || return $?;
        else
            softfail "Your operating system is not supported" || return $?;
        fi;
    fi )
}
linux::is_user_exists () 
{ 
    local user_name="$1";
    id -u "${user_name}" > /dev/null 2>&1
}
linux::reset_locales () 
{ 
    local carry_on=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --carry-on)
                carry_on=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local item;
    for item in "$@";
    do
        if [[ "${item}" =~ ^[[:alpha:]_]+=(.*)$ ]]; then
            local locale_match;
            locale_match="$(sed -E 's/[.]/[.]/g' <<< "${BASH_REMATCH[1]}")" || softfail || return $?;
            sudo sed --in-place -E 's/^#\s*('"${locale_match}"'(\s|$))/\1/g' /etc/locale.gen || softfail || return $?;
        fi;
    done;
    sudo locale-gen --keep-existing || softfail || return $?;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    { 
        local locale_line;
        for locale_line in "$@";
        do
            printf "%q\n" "${locale_line}" || softfail || return $?;
        done
    } > "${temp_file}" || softfail || return $?;
    file::write --sudo --consume "${temp_file}" --mode 0644 /etc/locale.conf || softfail || return $?;
    unset -v LANG LANGUAGE "${!LC_@}" || softfail || return $?;
    if [ "${carry_on}" = false ]; then
        local temp_file;
        temp_file="$(mktemp)" || softfail || return $?;
        ( declare -gx "$@" && /usr/bin/true ) 2> "${temp_file}" || softfail || return $?;
        if [ -s "${temp_file}" ]; then
            cat "${temp_file}" 1>&2 || softfail || return $?;
            rm "${temp_file}" || softfail || return $?;
            softfail "Unable to change locale, please try to run the same command once again in a new bash process";
            return $?;
        else
            rm "${temp_file}" || softfail || return $?;
        fi;
    fi;
    declare -gx "$@" || softfail || return $?
}
linux::set_battery_charge_control_threshold () 
{ 
    local battery_number=0;
    local if_present=false;
    local start_threshold=90;
    local end_threshold=100;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -b | --battery)
                battery_number="$2";
                shift;
                shift
            ;;
            -p | --if-present)
                if_present=true;
                shift
            ;;
            -s | --start)
                start_threshold="$2";
                shift;
                shift
            ;;
            -e | --end)
                end_threshold="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local battery_path="/sys/class/power_supply/BAT${battery_number}";
    if [ ! -d "${battery_path}" ]; then
        if [ "${if_present}" = true ]; then
            return 0;
        else
            softfail "Battery not found: ${battery_path}" || return $?;
        fi;
    fi;
    sudo tee "${battery_path}/charge_control_end_threshold" <<< "100" > /dev/null || softfail || return $?;
    sudo tee "${battery_path}/charge_control_start_threshold" <<< "${start_threshold}" > /dev/null || softfail || return $?;
    sudo tee "${battery_path}/charge_control_end_threshold" <<< "${end_threshold}" > /dev/null || softfail || return $?
}
linux::set_hostname () 
{ 
    local new_name="$1";
    local hosts_file="/etc/hosts";
    local previous_name;
    previous_name="$(hostnamectl --static status)" || softfail || return $?;
    if [ "${new_name}" = "${previous_name}" ]; then
        return 0;
    fi;
    local previous_name_escaped;
    previous_name_escaped="$(sed 's/\./\\./g' <<< "${previous_name}")" || softfail || return $?;
    file::write --append-line-unless-present --root --mode 0644 "${hosts_file}" "127.0.1.1	${new_name}" || softfail || return $?;
    sudo hostnamectl set-hostname "${new_name}" || softfail || return $?;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    grep -vxE "[[:blank:]]*127.0.1.1[[:blank:]]+${previous_name_escaped}[[:blank:]]*" "${hosts_file}" > "${temp_file}" || softfail || return $?;
    file::write --sudo --mode 0644 --consume "${temp_file}" "${hosts_file}" || softfail || return $?
}
linux::set_timezone () 
{ 
    local timezone="$1";
    sudo timedatectl set-timezone "${timezone}" || softfail || return $?
}
linux::update_remote_locale () 
{ 
    ( local locale_list=();
    if [ $# != 0 ]; then
        locale_list=("$@");
        unset -v LANG LANGUAGE "${!LC_@}" || softfail || return $?;
    else
        if [ -n "${REMOTE_LOCALE:-}" ]; then
            IFS=" " read -r -a locale_list <<< "${REMOTE_LOCALE}" || softfail || return $?;
        fi;
    fi;
    if [ "${#locale_list[@]}" = 0 ]; then
        softfail "Locale list is empty";
        return $?;
    fi;
    export REMOTE_CONTROL_MASTER=no;
    ssh::call linux::reset_locales --carry-on "${locale_list[@]}" || softfail || return $? )
}
linux::user_media_path () 
{ 
    if [ -d /run/media ]; then
        echo "/run/media/${USER}";
    else
        if [ -d /media ]; then
            echo "/media/${USER}";
        else
            softfail "Unable to determine user mounts path" || return $?;
        fi;
    fi
}
linux::with_secure_temp_dir () 
{ 
    local secure_temp_dir;
    secure_temp_dir="$(mktemp -d)" || softfail || return $?;
    sudo mount -t ramfs -o mode=700 ramfs "${secure_temp_dir}" || softfail || return $?;
    sudo chown "${USER}:${USER}" "${secure_temp_dir}" || softfail || return $?;
    ( export TMPDIR="${secure_temp_dir}";
    "$@" );
    local result=$?;
    sudo umount "${secure_temp_dir}" || softfail || return $?;
    rmdir "${secure_temp_dir}" || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "Error performing ${1:-"(argument is empty)"} (${result})" || return $?;
    fi
}
log::elapsed_time () 
{ 
    log::notice "Elapsed time: $((SECONDS / 3600))h$(((SECONDS % 3600) / 60))m$((SECONDS % 60))s"
}
log::error () 
{ 
    [ -t 2 ] && printf "%s\n" "$(printf "setaf 9\nbold" | tput -S 2> /dev/null)${*:-"Log message missing."}$(tput sgr 0 2> /dev/null)" 1>&2 || printf "[ERROR] %s\n" "${*:-"Log message missing."}" 1>&2
}
log::notice () 
{ 
    [ -t 2 ] && printf "%s\n" "$(printf "setaf 14\nbold" | tput -S 2> /dev/null)${*:-"Log message missing."}$(tput sgr 0 2> /dev/null)" 1>&2 || printf "[NOTICE] %s\n" "${*:-"Log message missing."}" 1>&2
}
log::success () 
{ 
    [ -t 2 ] && printf "%s\n" "$(printf "setaf 13\nbold" | tput -S 2> /dev/null)${*:-"Log message missing."}$(tput sgr 0 2> /dev/null)" 1>&2 || printf "[SUCCESS] %s\n" "${*:-"Log message missing."}" 1>&2
}
log::warning () 
{ 
    [ -t 2 ] && printf "%s\n" "$(printf "setaf 11\nbold" | tput -S 2> /dev/null)${*:-"Log message missing."}$(tput sgr 0 2> /dev/null)" 1>&2 || printf "[WARNING] %s\n" "${*:-"Log message missing."}" 1>&2
}
macos::hide_dir () 
{ 
    if [ -d "$1" ]; then
        chflags hidden "$1" || softfail || return $?;
    fi
}
macos::increase_maxfiles_limit () 
{ 
    local soft_limit="${1:-"262144"}";
    local hard_limit="${2:-"524288"}";
    local label="runag.limit.maxfiles";
    local dst="/Library/LaunchDaemons/${label}.plist";
    if [ ! -f "${dst}" ]; then
        file::write --sudo --mode 0644 "${dst}" <<HTML || 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
        "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>${label}</string>
    <key>ProgramArguments</key>
    <array>
      <string>launchctl</string>
      <string>limit</string>
      <string>maxfiles</string>
      <string>${soft_limit}</string>
      <string>${hard_limit}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>ServiceIPC</key>
    <false/>
  </dict>
</plist>
HTML
 softfail || return $?
        echo "increase_maxfiles_limit: Please reboot your computer" 1>&2;
    fi
}
macos::install_homebrew () 
{ 
    if ! command -v brew > /dev/null; then
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" < /dev/null || softfail "Unable to install homebrew" || return $?;
    fi
}
nodejs::add_apt_source () 
{ 
    local version="$1";
    apt::add_source_with_key "nodesource" "https://deb.nodesource.com/node_${version}.x nodistro main" "https://deb.nodesource.com/gpgkey/nodesource.gpg.key" || softfail "Unable to add nodejs apt source" || return $?
}
nodejs::add_yarn_apt_source () 
{ 
    apt::add_source_with_key "yarnpkg" "https://dl.yarnpkg.com/debian/ stable main" "https://dl.yarnpkg.com/debian/pubkey.gpg" || softfail "Unable to add yarn apt source" || return $?
}
nodejs::extend_package_list::arch () 
{ 
    package_list+=(curl gawk gnupg)
}
nodejs::extend_package_list::debian () 
{ 
    package_list+=(curl dirmngr gawk gpg)
}
npm::auth_token () 
{ 
    local registry="registry.npmjs.org";
    local project_config;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --registry)
                registry="$2";
                shift;
                shift
            ;;
            -l | --project)
                project_config=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local token="$1";
    if [ "${project_config:-}" = true ]; then
        file::write --append-line-unless-present ".gitignore" "/.npmrc" || softfail || return $?;
        if [ -f .npmignore ]; then
            file::write --append-line-unless-present ".npmignore" "/.npmrc" || softfail || return $?;
        fi;
    fi;
    npm config set ${project_config:+"--location" "project"} "//${registry}/:_authToken" "${token}" || softfail || return $?;
    chmod 0600 ".npmrc" || softfail || return $?
}
npm::update_globally_installed_packages () 
{ 
    sudo NODENV_VERSION=system npm update -g --unsafe-perm=true || softfail || return $?
}
nvidia::enable_preserve_video_memory_allocations () 
{ 
    file::write --sudo --mode 0644 "/etc/modprobe.d/nvidia-power-management.conf" <<< "options nvidia NVreg_PreserveVideoMemoryAllocations=1" || softfail || return $?
}
nvidia::is_device_present () 
{ 
    lspci | grep -q "VGA.*NVIDIA Corporation";
    local savedPipeStatus="${PIPESTATUS[*]}";
    if [ "${savedPipeStatus}" = "0 1" ]; then
        return 0;
    else
        if [ "${savedPipeStatus}" = "1 0" ] || [ "${savedPipeStatus}" = "1 1" ]; then
            fail "Error calling lspci";
        fi;
    fi
}
pass::dir_exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -d "${password_store_dir}/${secret_path}" ]; then
        return 0;
    else
        return 1;
    fi
}
pass::each () 
{ 
    local test_expression="-f";
    local search_extension=".gpg";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dir | --directory)
                test_expression="-d";
                search_extension="";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local search_path="$1";
    shift;
    local password_store_dir;
    password_store_dir="$(realpath "${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}")";
    local absolute_search_path;
    absolute_search_path="$(realpath "${password_store_dir}/${search_path}")" || softfail || return $?;
    local found_path;
    for found_path in "${absolute_search_path}"/*"${search_extension}";
    do
        if test "${test_expression}" "${found_path}"; then
            local found_relative_path="${found_path:$((${#password_store_dir}+1))}";
            if [ "${test_expression}" = "-f" ]; then
                local dir_name;
                dir_name="$(dirname "${found_relative_path}")" || softfail || return $?;
                local base_name;
                base_name="$(basename -s .gpg "${found_relative_path}")" || softfail || return $?;
                found_relative_path="${dir_name}/${base_name}";
            fi;
            "$@" "${found_relative_path}";
            softfail --unless-good --status $? || exit $?;
        fi;
    done
}
pass::exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -d "${password_store_dir}/${secret_path}" ] || [ -f "${password_store_dir}/${secret_path}".gpg ]; then
        return 0;
    else
        return 1;
    fi
}
pass::get_metadata () 
{ 
    local match_string="$1";
    local match_string_canonical;
    match_string_canonical="$(tr "[:upper:]" "[:lower:]" <<< "${match_string}" | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//"; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to produce match_string_canonical" || return $?;
    local line metadata_key;
    while IFS="" read -r line; do
        metadata_key="$(tr "[:upper:]" "[:lower:]" <<< "${line}" | cut -s -d ":" -f 1 | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//"; test "${PIPESTATUS[*]}" = "0 0 0")" || softfail "Unable to produce canonical metadata_key" || return $?;
        if [ "${metadata_key}" = "${match_string_canonical}" ]; then
            cut -s -d ":" -f 2- <<< "${line}" | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//";
            test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to produce metadata value" || return $?;
            return 0;
        fi;
    done;
    return 1
}
pass::install_fzf_extension () 
{ 
    local extension_name="${1:-ff}";
    local temp_file;
    temp_file="$(mktemp)" || fail;
    { 
        printf "#!/usr/bin/env bash\n\n" || fail;
        runag::print_license && printf "\n" || fail;
        cat <<'SHELL'
pass_name=$(cd "${PREFIX}" && find -name "*.gpg" | cut -c 3- | sed 's/\.gpg$//' | fzf --query "$*" --select-1) || exit $?

pass show --clip "${pass_name}" && printf "\n"
pass show "${pass_name}" | tail -n +2
SHELL

    } > "${temp_file}" || fail;
    file::write --consume "${temp_file}" --sudo --mode 0755 "/usr/lib/password-store/extensions/${extension_name}.bash" || fail
}
pass::secret_exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -f "${password_store_dir}/${secret_path}".gpg ]; then
        return 0;
    else
        return 1;
    fi
}
pass::use () 
{ 
    local get_body=false;
    local get_metadata=false metadata_name;
    local get_multiline=false;
    local skip_if_empty=false;
    local skip_if_not_exists=false;
    local skip_update=false;
    local absorb_in_callback=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -a | --consume-in-callback)
                absorb_in_callback=true;
                shift
            ;;
            -b | --body)
                get_body=true;
                shift
            ;;
            -g | --get)
                get_metadata=true;
                metadata_name="$2";
                shift;
                shift
            ;;
            -m | --multiline)
                get_multiline=true;
                shift
            ;;
            -e | --skip-if-empty)
                skip_if_empty=true;
                shift
            ;;
            -x | --skip-if-not-exists)
                skip_if_not_exists=true;
                shift
            ;;
            -u | --skip-update)
                skip_update=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local secret_path="$1";
    shift;
    local callback_function="${1:-}";
    shift;
    if [ "${skip_update}" = true ]; then
        if [ -z "${callback_function}" ]; then
            softfail "Callback function name should be specified" || return $?;
        fi;
        if ! declare -F "${callback_function}::exists" > /dev/null && ! command -v "${callback_function}::exists" > /dev/null; then
            softfail "${callback_function}::exists should be available as function or command" || return $?;
        fi;
        if "${callback_function}::exists" "$@"; then
            return 0;
        fi;
    fi;
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    local secret_file_path="${password_store_dir}/${secret_path}.gpg";
    if [ ! -f "${secret_file_path}" ]; then
        if [ "${skip_if_not_exists}" = true ]; then
            return 0;
        else
            softfail "Unable to find password file: ${secret_file_path}" || return $?;
        fi;
    fi;
    if [ "${get_body}" = true ] || [ "${get_multiline}" = true ]; then
        if [ "${absorb_in_callback}" = true ]; then
            if [ -z "${callback_function}" ]; then
                softfail "Callback function should be specified" || return $?;
            fi;
            local temp_file;
            temp_file="$(mktemp)" || softfail || return $?;
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2 > "${temp_file}";
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass" || return $?;
            else
                pass show "${secret_path}" > "${temp_file}" || softfail || return $?;
            fi;
            if [ -f "${temp_file}" ] && [ ! -s "${temp_file}" ]; then
                if [ "${skip_if_empty}" = true ]; then
                    return 0;
                fi;
                softfail "Zero-length secret data from pass" || return $?;
            fi;
            "${callback_function}" --consume "${temp_file}" "$@";
            softfail --unless-good --status $? "Unable to process secret data in ${callback_function} ($?)" || return $?;
            return 0;
        fi;
        if [ "${skip_if_empty}" = true ]; then
            softfail "--skip-if-empty is not supported for pipe output" || return $?;
        fi;
        if [ -n "${callback_function}" ]; then
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2 | "${callback_function}" "$@";
                test "${PIPESTATUS[*]}" = "0 0 0" || softfail "Unable to obtain secret from pass and process it with the callback function: ${callback_function}" || return $?;
            else
                pass show "${secret_path}" | "${callback_function}" "$@";
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass and process it with the callback function: ${callback_function}" || return $?;
            fi;
        else
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2;
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass" || return $?;
            else
                pass show "${secret_path}" || softfail "Unable to obtain secret from pass" || return $?;
            fi;
        fi;
        return 0;
    fi;
    local secret_data;
    if [ "${get_metadata}" = true ]; then
        secret_data="$(pass show "${secret_path}" | tail -n +2 | pass::get_metadata "${metadata_name}"; test "${PIPESTATUS[*]}" = "0 0 0")" || softfail "Unable to obtain secret from pass" || return $?;
    else
        secret_data="$(pass show "${secret_path}" | head -n1; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain secret from pass" || return $?;
    fi;
    if [ -z "${secret_data}" ]; then
        if [ "${skip_if_empty}" = true ]; then
            if [ -n "${callback_function}" ]; then
                return 0;
            fi;
            softfail "--skip-if-empty is not supported for pipe output" || return $?;
        fi;
        softfail "Zero-length secret data from pass" || return $?;
    fi;
    if [ -n "${callback_function}" ]; then
        "${callback_function}" "$@" "${secret_data}";
        softfail --unless-good --status $? "Unable to process secret data in ${callback_function} ($?)" || return $?;
    else
        printf "%s" "${secret_data}" || softfail || return $?;
    fi
}
postgresql::as_postgres_user () 
{ 
    local postgres_user;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        if [ -n "${SUDO_USER:-}" ]; then
            postgres_user="${SUDO_USER}";
        else
            postgres_user="${USER}";
        fi;
    else
        postgres_user=postgres;
    fi;
    sudo -i -u "${postgres_user}" "$@"
}
postgresql::create_role_if_not_exists () 
{ 
    local with_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --with)
                with_string="WITH $2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local role_name="${1:-"${PGUSER:-"${USER}"}"}";
    if ! postgresql::is_role_exists "${role_name}"; then
        postgresql::psql --sudo --query "CREATE ROLE ${role_name} ${with_string:-}" --dbname postgres || softfail || return $?;
    fi
}
postgresql::install_dictionaries () 
{ 
    ( local source_dir="$1";
    test -d "${source_dir}" || softfail "The directory does not exist: ${source_dir}" || return $?;
    . /etc/os-release || softfail || return $?;
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
            local dest_found=false;
            local dest;
            for dest in /usr/share/postgresql/*;
            do
                test -d "${dest}" || continue;
                postgresql::install_dictionaries::do || softfail || return $?;
                dest_found=true;
            done;
            if [ "${dest_found}" = false ]; then
                softfail "No destination were found for installation";
                return $?;
            fi;
        else
            if [ "${ID:-}" = arch ]; then
                local dest="/usr/share/postgresql";
                test -d "${dest}" || softfail "Destination directory not found: ${dest}" || return $?;
                postgresql::install_dictionaries::do || softfail || return $?;
            else
                softfail "Your operating system is not supported";
                return $?;
            fi;
        fi;
    else
        softfail "Your operating system is not supported";
        return $?;
    fi )
}
postgresql::install_dictionaries::do () 
{ 
    local file_found=false;
    local file;
    for file in "${source_dir}"/*;
    do
        test -f "${file}" || continue;
        local file_basename;
        file_basename="$(basename "${file}")" || softfail || return $?;
        file::write --sudo --mode 0644 --copy "${file}" "${dest}/tsearch_data/${file_basename}" || softfail || return $?;
        file_found=true;
    done;
    if [ "${file_found}" = false ]; then
        softfail "No files were found for installation";
        return $?;
    fi
}
postgresql::is_database_exists () 
{ 
    local database_name="${1:-"${PGDATABASE}"}";
    local database_exists;
    database_exists="$(postgresql::psql --query "SELECT 1 FROM pg_database WHERE datname='${database_name}'" --dbname postgres)" || fail --status 2 "Unable to query postgresql";
    test "${database_exists}" = 1
}
postgresql::is_role_exists () 
{ 
    local role_name="${1:-"${PGUSER:-"${USER}"}"}";
    local role_exists;
    role_exists="$(postgresql::psql --sudo --query "SELECT 1 FROM pg_roles WHERE rolname='${role_name}'" --dbname postgres)" || fail --status 2 "Unable to query postgresql";
    test "${role_exists}" = 1
}
postgresql::psql () 
{ 
    local psql_command=(psql --set ON_ERROR_STOP=on);
    local arguments_list=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --sudo)
                local user_name;
                if [[ "${OSTYPE}" =~ ^darwin ]]; then
                    if [ -n "${SUDO_USER:-}" ]; then
                        user_name="${SUDO_USER}";
                    else
                        user_name="${USER}";
                    fi;
                else
                    user_name=postgres;
                fi;
                psql_command=(sudo -i -u "${user_name}" psql --username "${user_name}" --set ON_ERROR_STOP=on);
                shift
            ;;
            --query)
                arguments_list=(--no-align --echo-errors --quiet --tuples-only --command "$2");
                shift;
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    "${psql_command[@]}" "${arguments_list[@]}" "$@"
}
rails::get_database_config () 
{ 
    ruby <(rails::get_database_config::ruby_script) "$1" || softfail "Unable to get database config from ruby" || return $?
}
rails::get_database_config::ruby_script () 
{ 
    cat <<RUBY
    require "yaml"

    key=ARGV[0]

    exit 1 unless key
    exit 1 if key.empty?
    
    config = YAML.load_file "config/database.yml"

    exit 1 unless config.is_a?(Hash)

    env_config = config[ENV["RAILS_ENV"] || "development"]

    exit 1 unless env_config.is_a?(Hash)

    value = env_config[key]

    exit 1 unless value
    exit 1 if value.empty?

    puts value
RUBY

}
rails::is_migration_pending () 
{ 
    bin/rails db:migrate:status | grep -cE "^[[:space:]]+down" > /dev/null;
    local saved_pipe_status=("${PIPESTATUS[@]}");
    test "${saved_pipe_status[0]}" = 0 || fail "Error performing 'bin/rails db:migrate:status'";
    test "${saved_pipe_status[1]}" = 0
}
relative::cd () 
{ 
    local caller_dir;
    caller_dir="$(dirname "${BASH_SOURCE[1]}")" || softfail "Failed to get caller directory" || return $?;
    cd "${caller_dir}/$1" || softfail "Failed to change directory to ${caller_dir}/$1" || return $?
}
relative::realpath () 
{ 
    ( local caller_dir;
    caller_dir="$(dirname "${BASH_SOURCE[1]}")" || softfail "Failed to get caller directory" || return $?;
    cd "${caller_dir}" || softfail "Failed to change directory to ${caller_dir}" || return $?;
    realpath "$@" )
}
relative::source () 
{ 
    local caller_dir;
    caller_dir="$(dirname "${BASH_SOURCE[1]}")" || softfail "Failed to get caller directory" || return $?;
    recursive_flag=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --recursive)
                recursive_flag=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "${recursive_flag}" = true ]; then
        relative::source::walk_directory "${caller_dir}/$1" "${@:2}" || softfail "Unable to load recursively from: ${caller_dir}/$1" || return $?;
    else
        . "${caller_dir}/$1" "${@:2}" || softfail "Unable to load: ${caller_dir}/$1" || return $?;
    fi
}
relative::source::walk_directory () 
{ 
    local dir_list=();
    local item dir_item;
    for item in "$1/"*;
    do
        if [ -d "${item}" ]; then
            dir_list+=("${item}");
        else
            if [ -f "${item}" ] && [[ "${item}" =~ \.sh$ ]]; then
                . "${item}" "${@:2}" || softfail "Unable to load: ${item}" || return $?;
            fi;
        fi;
    done;
    for dir_item in "${dir_list[@]}";
    do
        relative::source::walk_directory "${dir_item}" "${@:2}" || softfail "Unable to load from directory: ${dir_item}" || return $?;
    done
}
release::build_and_deploy_services () 
{ 
    ( local release_dir;
    local load_local_runagfile;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --release-dir)
                release_dir="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${release_dir}" || softfail || return $?;
    if [ "${load_local_runagfile}" = true ]; then
        runagfile::load --if-exists || softfail || return $?;
    fi;
    if declare -F release::env > /dev/null; then
        release::env || softfail || return $?;
    fi;
    if declare -F release::build > /dev/null; then
        release::build || softfail || return $?;
    fi;
    if declare -F release::deploy_services > /dev/null; then
        release::deploy_services || softfail || return $?;
    fi )
}
release::cleanup () 
{ 
    local cleanup_kind;
    local keep_amount=6;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -k | --kind)
                cleanup_kind="$2";
                shift;
                shift
            ;;
            -p | --keep)
                keep_amount="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local release_item;
    for release_item in releases/*;
    do
        if [ -d "${release_item}" ]; then
            if [ "${cleanup_kind}" = successful ] && [ -f "${release_item}/.successful-release-flag" ]; then
                echo "${release_item}";
            else
                if [ "${cleanup_kind}" = non-successful ] && [ ! -f "${release_item}/.successful-release-flag" ]; then
                    echo "${release_item}";
                fi;
            fi;
        fi;
    done | sort | head --lines="-${keep_amount}" | while IFS="" read -r release_item; do
        echo "Cleaning up past release ${PWD}/${release_item}...";
        rm -rf "${release_item:?}" || softfail || return $?;
    done;
    if [[ "${PIPESTATUS[*]}" =~ [^0[:space:]] ]]; then
        softfail || return $?;
    fi
}
release::create () 
{ 
    ( local dest_path;
    local load_local_runagfile;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${dest_path}" || softfail || return $?;
    export RELEASE_SHARED_PATH="${PWD}/shared";
    local current_date;
    current_date="$(date --utc "+%Y%m%dT%H%M%SZ")" || softfail || return $?;
    local release_dir;
    release_dir="$(mktemp -d "releases/${current_date}-XXX")" || softfail "Unable to make release directory" || return $?;
    git clone --quiet repo "${release_dir}" || softfail || return $?;
    release::build_and_deploy_services ${load_local_runagfile:+"--load-local-runagfile"} --release-dir "${release_dir}" || softfail || return $?;
    ln --symbolic --force --no-dereference "${release_dir}" "current" || softfail || return $?;
    touch "${release_dir}/.successful-release-flag" || softfail || return $?;
    release::cleanup --kind successful || softfail || return $?;
    release::cleanup --kind non-successful || softfail || return $? )
}
release::deploy () 
{ 
    local source_path;
    local dest_path;
    local load_local_runagfile;
    local ssh_call_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source)
                source_path="$2";
                shift;
                shift
            ;;
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -c | --ssh-call)
                ssh_call_command+=(ssh::call);
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${dest_path:-}" ]; then
        dest_path="$(basename "${source_path}")" || softfail || return $?;
    fi;
    "${ssh_call_command[@]}" release::init --dest "${dest_path}" || softfail || return $?;
    release::push --source "${source_path}" --dest "${dest_path}" || softfail || return $?;
    "${ssh_call_command[@]}" release::create ${load_local_runagfile:+"--load-local-runagfile"} --dest "${dest_path}" || softfail || return $?
}
release::init () 
{ 
    local dest_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    dir::ensure_exists --mode 0700 "${dest_path}" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${dest_path}/releases" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${dest_path}/repo" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${dest_path}/shared" || softfail || return $?;
    git init --quiet --bare "${dest_path}/repo" || softfail || return $?;
    ( cd "${dest_path}/repo" && git symbolic-ref HEAD refs/heads/main ) || softfail || return $?
}
release::push () 
{ 
    ( local source_path;
    local dest_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source)
                source_path="$2";
                shift;
                shift
            ;;
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${source_path}" || softfail || return $?;
    local git_status_length;
    git_status_length="$(git status --porcelain=v1 | wc --bytes; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain git status" || return $?;
    if [ "${git_status_length}" != 0 ]; then
        log::warning "There are uncommited changes in ${PWD}";
    fi;
    local remote_name="${REMOTE_USER}@${REMOTE_HOST}/${dest_path}";
    local git_remote_url="${REMOTE_USER:?}@${REMOTE_HOST:?}:${dest_path}/repo";
    git::add_or_update_remote "${remote_name}" "${git_remote_url}" || softfail || return $?;
    if git ls-remote --exit-code --heads "${remote_name}" main > /dev/null; then
        git pull --quiet "${remote_name}" main || fail;
    fi;
    git push --quiet "${remote_name}" main || fail )
}
restic::install () 
{ 
    local restic_version="$1";
    if command -v restic > /dev/null; then
        local installed_restic_version;
        installed_restic_version="$(restic version)" || softfail || return $?;
        if [[ "${installed_restic_version}" =~ ^[^[:digit:]]+([[:digit:]\.]+) ]] && [ "${BASH_REMATCH[1]}" = "${restic_version}" ]; then
            return 0;
        fi;
    fi;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    curl --location --fail --silent --show-error --output "${temp_file}" "https://github.com/restic/restic/releases/download/v${restic_version}/restic_${restic_version}_linux_amd64.bz2" > /dev/null || softfail || return $?;
    bzip2 --decompress --stdout "${temp_file}" > "${temp_file}.out" || softfail || return $?;
    file::write --sudo --mode 0755 --consume "${temp_file}.out" /usr/local/bin/restic || softfail || return $?;
    rm "${temp_file}" || softfail || return $?
}
restic::open_mount_when_available () 
{ 
    local mount_path="$1";
    local cutoff_time="$((SECONDS+40))";
    ( while [ ! -d "${mount_path}/snapshots" ]; do
        sleep 0.1 || fail;
        if [ "${SECONDS}" -gt "${cutoff_time}" ]; then
            fail "Maximum time to wait for mount to complete has been reached";
        fi;
    done;
    if [ -d "${mount_path}/snapshots/latest" ]; then
        xdg-open "${mount_path}/snapshots/latest" || fail;
    else
        xdg-open "${mount_path}" || fail;
    fi ) &
}
rsync::rsh_string () 
{ 
    local Ssh_Args=();
    ssh::call::set_ssh_args || softfail || return $?;
    local rsh_string="";
    local ssh_arg;
    for ssh_arg in "${Ssh_Args[@]}";
    do
        rsh_string+=" '$(sed -E "s/'/''/" <<< "${ssh_arg}")'" || softfail || return $?;
    done;
    echo "ssh ${rsh_string:1}" || softfail || return $?
}
rsync::set_default_args () 
{ 
    Default_Rsync_Args=(--checksum --delete --links --perms --recursive --safe-links --times)
}
rsync::sync () 
{ 
    local from_remote=false;
    local to_remote=false;
    local rsync_args=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --from-remote)
                from_remote=true;
                shift
            ;;
            --to-remote)
                to_remote=true;
                shift
            ;;
            -*)
                rsync_args+=("$1");
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    local sources_and_destination;
    if [ "${from_remote}" = true ]; then
        sources_and_destination=("${REMOTE_HOST:+"${REMOTE_HOST}:"}$1" "$2");
    else
        if [ "${to_remote}" = true ]; then
            sources_and_destination=("$1" "${REMOTE_HOST:+"${REMOTE_HOST}:"}$2");
        else
            sources_and_destination=("$@");
        fi;
    fi;
    local Default_Rsync_Args;
    rsync::set_default_args || softfail || return $?;
    local rsh_string;
    rsh_string="$(rsync::rsh_string)" || softfail || return $?;
    rsync --rsh "${rsh_string}" "${Default_Rsync_Args[@]}" "${rsync_args[@]}" "${sources_and_destination[@]}" || softfail || return $?
}
ruby::dangerously_append_nodocument_to_gemrc () 
{ 
    file::write --append-line-unless-present "${HOME}/.gemrc" "gem: --no-document" || softfail || return $?
}
ruby::extend_package_list::arch () 
{ 
    package_list+=(base-devel libffi libyaml openssl rust sqlite zlib)
}
ruby::extend_package_list::debian () 
{ 
    package_list+=(build-essential libedit-dev libffi-dev libsqlite3-dev libssl-dev libyaml-dev zlib1g-dev)
}
ruby::gem () 
{ 
    local exit_status;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    gem "$@" 2> "${temp_file}";
    exit_status=$?;
    if [ "${exit_status}" != 0 ]; then
        rm "${temp_file}" || softfail "Unable to remove temp file";
        return "${exit_status}";
    fi;
    if [ -s "${temp_file}" ]; then
        cat "${temp_file}" 1>&2 || softfail "Unable to read STDERR output from temp file: ${temp_file}" || return $?;
        if grep -q "^ERROR:" "${temp_file}"; then
            rm "${temp_file}" || softfail "Unable to remove temp file";
            softfail "Error found in rubygems output";
            return $?;
        fi;
    fi
}
ruby::install_disable_spring_shellfile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "profile/ruby-disable-spring" <<SHELL || 
${license_text}

export DISABLE_SPRING=true
SHELL
 softfail || return $?
}
ruby::without_docs () 
{ 
    RUBY_CONFIGURE_OPTS="--disable-install-doc" "$@" || softfail || return $?
}
rubygems::credentials () 
{ 
    local api_key="$1";
    local file_path="${HOME}/.gem/credentials";
    file::write --mode 0600 "${file_path}" <<YAML || 
---
:rubygems_api_key: ${api_key}
YAML
 softfail "Unable to write secret to file" || return $?
}
rubygems::credentials::exists () 
{ 
    local file_path="${HOME}/.gem/credentials";
    test -s "${file_path}"
}
rubygems::direnv_credentials () 
{ 
    local GEM_HOST_API_KEY="$1";
    local envrc_path=".envrc";
    direnv::is_allowed "${envrc_path}" || softfail "'.envrc' is not allowed by direnv" || return $?;
    file::write --user-only --capture --section "RUBYGEMS-CREDENTIALS" "${envrc_path}" shell::emit_exports GEM_HOST_API_KEY || softfail "Failed to write RubyGems credentials to .envrc" || return $?;
    direnv allow "${envrc_path}" || softfail "Failed to allow '.envrc' via direnv" || return $?;
    file::write --append-line-unless-present ".gitignore" "/.envrc" || softfail || return $?;
    if [ -f .npmignore ]; then
        file::write --append-line-unless-present ".npmignore" "/.envrc" || softfail || return $?;
    fi
}
runag::extend_package_list::arch () 
{ 
    package_list+=(curl git gnupg jq pass tinyxxd)
}
runag::extend_package_list::debian () 
{ 
    package_list+=(apt-transport-https curl git gpg jq pass xxd)
}
runag::mini_library () 
{ 
    printf "#!/usr/bin/env bash\n\n" || softfail "Failed to print the shebang line." || return $?;
    runag::print_license && printf "\n" || softfail "Error printing license information." || return $?;
    if [ "${1:-}" = "--nounset" ]; then
        printf "set -o nounset\n\n" || softfail "Failed to print 'nounset' option." || return $?;
    fi;
    declare -f fail || softfail "The 'fail' function is not defined." || return $?;
    declare -f softfail || softfail "The 'softfail' function is not defined." || return $?;
    declare -f dir::ensure_exists || softfail "The 'dir::ensure_exists' function is not defined." || return $?;
    declare -f file::write || softfail "The 'file::write' function is not defined." || return $?
}
runag::print_license () 
{ 
    cat <<SHELL
#  Copyright 2012-2025 Runag project contributors
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
SHELL

}
runagfile::load () 
{ 
    local if_exists=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -e | --if-exists)
                if_exists=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -f "runagfile.sh" ]; then
        . "runagfile.sh";
        softfail --unless-good --status $? "Failed to load './runagfile.sh' (exit code $?)";
        return $?;
    fi;
    if [ -f "runagfile/runagfile.sh" ]; then
        . "runagfile/runagfile.sh";
        softfail --unless-good --status $? "Failed to load './runagfile/runagfile.sh' (exit code $?)";
        return $?;
    fi;
    local matches=(*-runagfile);
    if [ "${#matches[@]}" -eq 1 ] && [ -d "${matches[0]}" ] && [ -f "${matches[0]}/runagfile.sh" ]; then
        . "${matches[0]}/runagfile.sh";
        softfail --unless-good --status $? "Failed to load '${matches[0]}/runagfile.sh' (exit code $?)";
        return $?;
    fi;
    if [ "${if_exists}" = true ]; then
        return;
    fi;
    softfail "No 'runagfile.sh' found in any known location"
}
shell::assign_and_mark_for_export () 
{ 
    declare -gx "$1"="$2"
}
shell::emit_exports () 
{ 
    local list_item;
    for list_item in "$@";
    do
        if [[ -n "${!list_item:-}" ]]; then
            echo "export $(printf "%q=%q" "${list_item}" "${!list_item}")";
        fi;
    done
}
shell::enable_trace () 
{ 
    PS4='+${BASH_SUBSHELL} ${BASH_SOURCE:+"${BASH_SOURCE}:${LINENO}: "}${FUNCNAME[0]:+"in \`${FUNCNAME[0]}'"'"' "}** ';
    set -o xtrace
}
shell::open () 
{ 
    "${SHELL}" "$@" || true
}
shell::with () 
{ 
    ( local call_array=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --)
                shift;
                break
            ;;
            *)
                call_array+=("$1");
                shift
            ;;
        esac;
    done;
    "${call_array[@]}";
    softfail --unless-good --status $? || return $?;
    "$@" )
}
shellfile::install_direnv_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/direnv" <<SHELL || 
${license_text}

if command -v direnv >/dev/null; then
  export DIRENV_LOG_FORMAT=""
  if [ -n "\${ZSH_VERSION:-}" ]; then
    eval "\$(direnv hook zsh)" || echo "Unable to hook direnv" >&2
  elif [ -n "\${BASH_VERSION:-}" ]; then
    eval "\$(direnv hook bash)" || echo "Unable to hook direnv" >&2
  fi
fi
SHELL
 softfail || return $?
}
shellfile::install_editor_rc () 
{ 
    local editor_path;
    editor_path="$(command -v "$1")" || softfail || return $?;
    shift;
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/editor" <<SHELL || 
${license_text}

if [ -z "\${EDITOR:-}" ]; then
  export EDITOR=$(printf "%q" "${editor_path}")
fi
SHELL
 softfail || return $?
}
shellfile::install_flush_history_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/flush-history" <<SHELL || 
${license_text}

HISTSIZE=10000

shopt -s histappend

#if [ -n "\${BASH_VERSION:-}" ]; then
#  PROMPT_COMMAND="\${PROMPT_COMMAND:+"\${PROMPT_COMMAND}; "}history -a && history -r"
#fi
SHELL
 softfail || return $?
}
shellfile::install_fzf_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/fzf" <<SHELL || 
${license_text}

export FZF_DEFAULT_OPTS="--exact"

if command -v fzf >/dev/null; then
  if [ -n "\${ZSH_VERSION:-}" ]; then
    source <(fzf --zsh) || echo "Unable to hook fzf" >&2
  elif [ -n "\${BASH_VERSION:-}" ]; then
    eval "\$(fzf --bash)" || echo "Unable to hook fzf" >&2
  fi
fi

alias p="pass ff"
SHELL
 softfail || return $?
}
shellfile::install_loader::bash () 
{ 
    shellfile::write_loader_block --file "${HOME}/.bashrc" --dir ".shellfile.d/rc" || softfail || return $?;
    if [ -f "${HOME}/.bash_profile" ] || [ ! -f "${HOME}/.profile" ]; then
        shellfile::write_loader_block --file "${HOME}/.bash_profile" --dir ".shellfile.d/profile" || softfail || return $?;
    else
        shellfile::write_loader_block --file "${HOME}/.profile" --dir ".shellfile.d/profile" || softfail || return $?;
    fi
}
shellfile::install_loader::zsh () 
{ 
    shellfile::write_loader_block --file "${HOME}/.zshrc" --dir ".shellfile.d/rc" || softfail || return $?;
    shellfile::write_loader_block --file "${HOME}/.zprofile" --dir ".shellfile.d/profile" || softfail || return $?
}
shellfile::install_local_bin_path_profile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "profile/local-bin-path" <<SHELL || 
${license_text}

if [ -d "\${HOME}/.local/bin" ]; then
  case ":\${PATH}:" in
  *":\${HOME}/.local/bin:"*)
    true
    ;;
  *)
    export PATH="\${HOME}/.local/bin:\${PATH}"
    ;;
  esac
fi
SHELL
 softfail || return $?
}
shellfile::install_short_prompt_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/short-prompt" <<SHELL || 
${license_text}

if [ -n "\${BASH_VERSION:-}" ]; then
  if tput cols >/dev/null 2>&1 && [ "\$(tput cols)" -le 140 ]; then
    PS1='\['"\$(tput setaf 12)\$(tput bold)"'\]\W\['"\$(tput sgr 0)"'\]\$ '
  fi
fi
SHELL
 softfail || return $?
}
shellfile::write () 
{ 
    local source_now=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source-now)
                source_now=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local shellfile_dir_path="${HOME}/.shellfile.d";
    dir::ensure_exists --mode 0700 "${shellfile_dir_path}" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${shellfile_dir_path}/rc" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${shellfile_dir_path}/profile" || softfail || return $?;
    local output_path="${shellfile_dir_path}/${file_path}.sh";
    file::write --mode 0600 "${output_path}" || softfail || return $?;
    if [ "${source_now}" = true ]; then
        . "${output_path}" || softfail || return $?;
    fi
}
shellfile::write_loader_block () 
{ 
    local file_path;
    local directory_path;
    local block_name="shellfile-d-loader";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --file)
                file_path="$2";
                shift;
                shift
            ;;
            -d | --dir)
                directory_path="$2";
                shift;
                shift
            ;;
            -b | --block)
                block_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    file::write --mode 0644 --section "${block_name}" "${file_path}" <<SHELL || 
if [ -d "\${HOME}"/$(printf "%q" "${directory_path}") ]; then
  for __file_bb21go6nkCN82Gk9XeY2 in "\${HOME}"/$(printf "%q" "${directory_path}")/*.sh; do
    if [ -f "\${__file_bb21go6nkCN82Gk9XeY2}" ]; then
      . "\${__file_bb21go6nkCN82Gk9XeY2}" || { echo "Unable to load file \${__file_bb21go6nkCN82Gk9XeY2} (\$?)" >&2; }
    fi
  done
  unset __file_bb21go6nkCN82Gk9XeY2
fi
SHELL
 softfail || return $?
}
snapshot::cleanup () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_time=false;
    local daily_snapshot_count=30;
    local weekly_snapshot_count=14;
    local monthly_snapshot_count=12;
    local snapshots_by_time_count=14;
    if [ "$#" = 1 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    daily_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    weekly_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    monthly_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    snapshots_by_time_count="$2";
                    shift;
                fi;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 1 ]; then
        softfail "Snapshots directory must be specified";
        return $?;
    else
        local dest="${1:?}";
    fi;
    if [ "${daily_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/daily-snapshots" "${daily_snapshot_count}";
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/weekly-snapshots" "${weekly_snapshot_count}";
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/monthly-snapshots" "${monthly_snapshot_count}";
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshot::cleanup::dir "${dest}/snapshots-by-time" "${snapshots_by_time_count}";
    fi
}
snapshot::cleanup::dir () 
{ 
    local snapshots_dir="${1:?}";
    local keep_amount="${2:-10}";
    local snapshot_path;
    local remove_this_snapshot;
    if [ ! -f "${snapshots_dir:?}"/.safe-to-cleanup ]; then
        softfail "Unable to find safe to cleanup flag. To indicate that it is safe to perform automatic cleanup please put \".safe-to-cleanup\" file in the directory that you are sure it is safe to cleanup.";
        return $?;
    fi;
    for snapshot_path in "${snapshots_dir:?}"/*;
    do
        if [ -d "${snapshot_path:?}" ]; then
            echo "${snapshot_path:?}";
        fi;
    done | sort | head "--lines=-${keep_amount:?}" | while IFS="" read -r remove_this_snapshot; do
        echo "Removing ${remove_this_snapshot:?}...";
        if [ "$(stat --format=%i "${remove_this_snapshot:?}")" -eq 256 ]; then
            sudo btrfs subvolume delete "${remove_this_snapshot:?}" || softfail || return $?;
        else
            rm -rf "${remove_this_snapshot:?}" || softfail || return $?;
        fi;
    done;
    if [[ "${PIPESTATUS[*]}" =~ [^0[:space:]] ]]; then
        softfail || return $?;
    fi
}
snapshot::create () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_name=false;
    local snapshots_by_time=false;
    local snapshot_name;
    if [ "$#" = 2 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                shift
            ;;
            -n | --name)
                snapshots_by_name=true;
                snapshot_name="${2:?}";
                shift;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 2 ]; then
        softfail "Source and snapshot directories must be specified";
        return $?;
    else
        local source="${1:?}";
        local dest="${2:?}";
    fi;
    local snapshot_path;
    if [ "${daily_snapshot}" = true ]; then
        snapshot_path="${dest}/daily-snapshots/$(date --utc "+%Y-%m-%d")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshot_path="${dest}/weekly-snapshots/$(date --utc "+%G-W%V")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshot_path="${dest}/monthly-snapshots/$(date --utc "+%Y-%m")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${snapshots_by_name}" = true ]; then
        snapshot_path="${dest}/snapshots-by-name/${snapshot_name}";
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        else
            softfail "Snapshot directory already exist: ${snapshot_path}";
            return $?;
        fi;
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshot_path="${dest}/snapshots-by-time/$(date --utc "+%Y-%m-%dT%H%M%SZ")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        else
            softfail "Snapshot directory already exist: ${snapshot_path}";
            return $?;
        fi;
    fi
}
snapshot::init () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_name=false;
    local snapshots_by_time=false;
    if [ "$#" = 1 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                shift
            ;;
            -n | --name)
                snapshots_by_name=true;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 1 ]; then
        softfail "Snapshots directory must be specified";
        return $?;
    else
        local dest="${1:?}";
    fi;
    dir::ensure_exists --mode 0700 "${dest}" || softfail || return $?;
    local snapshots_path;
    if [ "${daily_snapshot}" = true ]; then
        snapshots_path="${dest}/daily-snapshots";
        dir::ensure_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshots_path="${dest}/weekly-snapshots";
        dir::ensure_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshots_path="${dest}/monthly-snapshots";
        dir::ensure_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${snapshots_by_name}" = true ]; then
        snapshots_path="${dest}/snapshots-by-name";
        dir::ensure_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshots_path="${dest}/snapshots-by-time";
        dir::ensure_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi
}
softfail () 
{ 
    fail --from-softfail-wrapper "$@"
}
ssh::add_host_to_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    local known_hosts="${HOME}/.ssh/known_hosts";
    if ! command -v ssh-keygen > /dev/null; then
        softfail "ssh-keygen not found" || return $?;
    fi;
    if [ ! -f "${known_hosts}" ]; then
        dir::ensure_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
        ( umask 0177 && touch "${known_hosts}" ) || softfail || return $?;
    fi;
    if [ "${ssh_port}" = "22" ]; then
        local keygen_host_string="${host_name}";
    else
        local keygen_host_string="[${host_name}]:${ssh_port}";
    fi;
    if ! ssh-keygen -F "${keygen_host_string}" > /dev/null; then
        ssh-keyscan -p "${ssh_port}" -T 30 "${host_name}" >> "${known_hosts}" || softfail "Unable to add host ${host_name}:${ssh_port} to ssh known_hosts" || return $?;
    fi
}
ssh::add_ssh_config_d_include_directive () 
{ 
    dir::ensure_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    dir::ensure_exists --mode 0700 "${HOME}/.ssh/ssh_config.d" || softfail "Unable to create ssh user config.d directory" || return $?;
    file::write --mode 0600 --section "include-files-from-ssh-config-d" "${HOME}/.ssh/config" <<SHELL || 
Host *
Include ~/.ssh/ssh_config.d/*.conf
SHELL
 softfail "Unable to add configuration to user ssh config" || return $?
}
ssh::call () 
{ 
    local Ssh_Args=();
    local internal_args=();
    local keep_temp_files=false;
    local direct_mode=false;
    local terminal_mode=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --root)
                local REMOTE_USER=root;
                shift
            ;;
            --user | -l)
                local REMOTE_USER="$2";
                shift;
                shift
            ;;
            -[46AaCfGgKkMNnqsTtVvXxYy]*)
                Ssh_Args+=("$1");
                shift
            ;;
            -[BbcDEeFIiJLmOopQRSWw])
                Ssh_Args+=("$1" "$2");
                shift;
                shift
            ;;
            --keep-temp-files)
                internal_args+=("$1");
                keep_temp_files=true;
                shift
            ;;
            --direct)
                internal_args+=("$1");
                direct_mode=true;
                shift
            ;;
            --terminal)
                internal_args+=("$1");
                terminal_mode=true;
                shift
            ;;
            --*)
                internal_args+=("$1");
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "${keep_temp_files}" = false ] && [ "${REMOTE_KEEP_TEMP_FILES:-}" = true ]; then
        internal_args+=(--keep-temp-files);
        keep_temp_files=true;
    fi;
    ssh::call::set_ssh_args || softfail "Unable to set ssh args" || return $?;
    local temp_dir;
    temp_dir="$(mktemp -d)" || softfail "Unable to make temp file" || return $?;
    local locale_list=();
    if [ -n "${REMOTE_LOCALE:-}" ]; then
        IFS=" " read -r -a locale_list <<< "${REMOTE_LOCALE}" || softfail || return $?;
    fi;
    if [ "${#locale_list[@]}" != 0 ]; then
        ( unset -v LANG LANGUAGE "${!LC_@}" || softfail || return $?;
        local locale_item;
        for locale_item in "${locale_list[@]}";
        do
            export "${locale_item}" || softfail || return $?;
        done;
        ssh::call::internal --temp-dir "${temp_dir}" "${internal_args[@]}" "$@" );
    else
        ssh::call::internal --temp-dir "${temp_dir}" "${internal_args[@]}" "$@";
    fi;
    local exit_status=$?;
    if [ "${keep_temp_files}" != true ]; then
        local remove_list=("${temp_dir}/stdin" "${temp_dir}/stdout" "${temp_dir}/stderr");
        if [ "${exit_status}" = 0 ] || [ "${terminal_mode}" = true ] || { 
            [ "${direct_mode}" = true ] && [ "${exit_status}" = 255 ]
        }; then
            remove_list+=("${temp_dir}/script" "${temp_dir}");
        else
            echo "Script is kept due to abnormal termination: ${temp_dir}/script" 1>&2;
        fi;
        rm -fd "${remove_list[@]}" || softfail "Unable to remote temp files";
    fi;
    return "${exit_status}"
}
ssh::call::interactive_terminal_functions_filter () 
{ 
    local function_name="$1";
    [ "${function_name:0:1}" = "_" ] || [[ "${function_name}" =~ ^(asdf|command_not_found_handle|dequote|quote|quote_readline)$ ]]
}
ssh::call::internal () 
{ 
    local produce_script_args=();
    local direct_mode=false;
    local terminal_mode=false;
    local keep_temp_files=false;
    local absorb_file;
    local temp_dir;
    local upload_path;
    local ssh_destination;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --consume)
                absorb_file="$2";
                shift;
                shift
            ;;
            --command | --cmd)
                produce_script_args+=(--command);
                shift
            ;;
            --home)
                produce_script_args+=(--home);
                shift
            ;;
            --direct)
                direct_mode=true;
                shift
            ;;
            --terminal)
                produce_script_args+=(--terminal);
                terminal_mode=true;
                shift
            ;;
            --keep-temp-files)
                keep_temp_files=true;
                shift
            ;;
            --temp-dir)
                temp_dir="$2";
                shift;
                shift
            ;;
            --upload)
                upload_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -n "${REMOTE_HOST:-}" ]; then
        ssh_destination="${REMOTE_HOST}";
    else
        ssh_destination="$1";
        shift;
    fi;
    local resolved_upload_path;
    local rsync_ssh_args_string;
    local upload_remote_temp;
    local upload_rsync_dest;
    local upload_rsync_src;
    local upload_basename;
    if [ -n "${upload_path:-}" ]; then
        if [ -d "${upload_path}" ]; then
            resolved_upload_path="$(cd "${upload_path}" > /dev/null 2>&1 && pwd)" || softfail "Unable to resolve upload directory: ${upload_path}" || return $?;
            upload_basename="$(basename "${resolved_upload_path}")" || softfail || return $?;
            if [ "${upload_basename}" = "/" ]; then
                upload_basename=root;
            fi;
            upload_rsync_src="${resolved_upload_path}/";
        else
            upload_basename="$(basename "${upload_path}")" || softfail || return $?;
            upload_rsync_src="${upload_path}";
        fi;
        upload_remote_temp="$(ssh "${Ssh_Args[@]}" "${ssh_destination}" "mktemp -d")" || softfail --status $? "Unable to create remote temp directory for file upload" || return $?;
        upload_rsync_dest="${upload_remote_temp}/${upload_basename}";
        local ssh_args_item;
        for ssh_args_item in "${Ssh_Args[@]}";
        do
            rsync_ssh_args_string+=" '$(sed -E "s/'/''/" <<< "${ssh_args_item}")'" || softfail || return $?;
        done;
        rsync --rsh "ssh ${rsync_ssh_args_string:1}" --checksum --links --perms --recursive --safe-links --times "${upload_rsync_src}" "${ssh_destination}:${upload_rsync_dest}" || softfail || return $?;
        set -- "$@" "${upload_rsync_dest}";
    fi;
    local script_checksum;
    ssh::call::produce_script "${produce_script_args[@]}" "$@" > "${temp_dir}/script" || softfail "Unable to produce script" || return $?;
    script_checksum="$(cksum < "${temp_dir}/script")" || softfail "Unable to calculate script checksum" || return $?;
    local script_upload_command;
    printf -v script_upload_command 'temp_dir="$(mktemp -d)" && cat>"${temp_dir}/script" && { if [ "$(cksum <"${temp_dir}/script")" != %q ]; then exit 254; fi; } && echo "${temp_dir}"' "${script_checksum}" || softfail || return $?;
    local remote_temp_dir;
    remote_temp_dir="$(ssh "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "${script_upload_command}")" < "${temp_dir}/script")" || softfail --status $? "Unable to upload script" || return $?;
    if [ -z "${remote_temp_dir}" ]; then
        softfail "Unable to get remote temp file name" || return $?;
    fi;
    if [ "${terminal_mode}" = true ]; then
        ssh::call::invoke --terminal "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script"';
        local task_status=$?;
    else
        if [ "${direct_mode}" = true ]; then
            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script"';
            local task_status=$?;
        else
            local remote_stdin_file="/dev/null";
            if [ ! -t 0 ] || [ -n "${absorb_file:-}" ]; then
                if [ -n "${absorb_file:-}" ]; then
                    mv "${absorb_file}" "${temp_dir}/stdin" || softfail "Unable to absorb file: ${absorb_file}" || return $?;
                else
                    cat > "${temp_dir}/stdin" || softfail "Unable to read stdin" || return $?;
                fi;
                if [ -s "${temp_dir}/stdin" ]; then
                    local stdin_checksum;
                    stdin_checksum="$(cksum < "${temp_dir}/stdin")" || softfail "Unable to get stdin checksum" || return $?;
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat >"${temp_dir}/stdin"; if [ "$(cksum <"${temp_dir}/stdin")" != %q ]; then exit 254; fi' "${stdin_checksum}" < "${temp_dir}/stdin" || softfail --status $? "Unable to store stdin data on remote" || return $?;
                    remote_stdin_file="${remote_temp_dir}/stdin";
                fi;
            fi;
            ssh::call::invoke --nohup "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script" <%q >"${temp_dir}/stdout" 2>"${temp_dir}/stderr"; script_status=$?; echo "${script_status}" >"${temp_dir}/exit_status"; touch "${temp_dir}/done"; exit "${script_status}"' "${remote_stdin_file}";
            local task_status=$?;
            local task_status_retrieved=false;
            local stdout_retrieved=false;
            local stderr_retrieved=false;
            local call_result;
            if [ "${task_status}" != 255 ]; then
                task_status_retrieved=true;
            fi;
            local started_at="${SECONDS}";
            local retry_limit="${REMOTE_RECONNECT_TIME_LIMIT:-600}";
            local first_run=true;
            local notice_prefix="[NOTICE] " notice_postfix="";
            if [ -t 2 ]; then
                notice_prefix="$(printf "setaf 14\nbold" | tput -S 2> /dev/null)";
                notice_postfix="$(tput sgr 0 2> /dev/null)";
            fi;
            while true; do
                if [ "${first_run}" = true ]; then
                    first_run=false;
                else
                    sleep "${REMOTE_RECONNECT_DELAY:-5}";
                    if [ "$(( SECONDS - started_at ))" -ge "${retry_limit}" ]; then
                        softfail "Unable to obtain task result, maximum time limit reached";
                        return 1;
                    fi;
                    echo "${notice_prefix}Attempting to obtain result ($(( retry_limit - (SECONDS - started_at) )) second(s) till timeout)...${notice_postfix}" 1>&2;
                fi;
                if [ "${task_status_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -f "${temp_dir}/done"';
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -d "${temp_dir}"';
                            call_result=$?;
                            if [ "${call_result}" != 0 ] && [ "${call_result}" != 255 ]; then
                                softfail "Unable to find remote task state directory, remote host may have been rebooted";
                                return 1;
                            fi;
                            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -f "${temp_dir}/stdout"';
                            call_result=$?;
                            if [ "${call_result}" != 0 ] && [ "${call_result}" != 255 ]; then
                                softfail "It seems that the remote command did not even start";
                                return 1;
                            fi;
                            continue;
                        fi;
                    fi;
                    task_status="$(ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/exit_status"')";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain exit status from remote";
                            return 1;
                        fi;
                    fi;
                    if ! [[ "${task_status}" =~ ^[0-9]+$ ]]; then
                        task_status=1;
                    fi;
                    task_status_retrieved=true;
                fi;
                if [ "${stdout_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/stdout"' > "${temp_dir}/stdout";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain stdout from remote";
                            return 1;
                        fi;
                    fi;
                    stdout_retrieved=true;
                fi;
                if [ "${stderr_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/stderr"' > "${temp_dir}/stderr";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain stderr from remote";
                            return 1;
                        fi;
                    fi;
                    stderr_retrieved=true;
                fi;
                local remote_checksum;
                local local_checksum;
                remote_checksum="$(ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" '{ cat "${temp_dir}/stdout" "${temp_dir}/stderr" && touch "${temp_dir}/output_concat_good"; } | cksum && test -f "${temp_dir}/output_concat_good"')";
                call_result=$?;
                if [ "${call_result}" = 255 ]; then
                    continue;
                else
                    if [ "${call_result}" != 0 ]; then
                        softfail "Unable to obtain checksums from remote";
                        return 1;
                    fi;
                fi;
                local_checksum="$(cat "${temp_dir}/stdout" "${temp_dir}/stderr" | cksum; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to get local output checksum" || return $?;
                if [ "${remote_checksum}" != "${local_checksum}" ]; then
                    softfail "Output checksum mismatch";
                    return 1;
                fi;
                break;
            done;
            local error_state=false;
            if [ -s "${temp_dir}/stdout" ]; then
                cat "${temp_dir}/stdout" || { 
                    echo "Unable to display task stdout ($?)" 1>&2;
                    error_state=true
                };
            fi;
            if [ -s "${temp_dir}/stderr" ]; then
                if test -t 2; then
                    local error_color;
                    error_color="$(printf "setaf 9\nbold" | tput -S 2> /dev/null)" || error_color="";
                    local reset_attrs;
                    reset_attrs="$(tput sgr 0 2> /dev/null)" || reset_attrs="";
                    local error_line;
                    while IFS="" read -r error_line; do
                        echo "${error_color}${error_line}${reset_attrs}" 1>&2;
                    done < "${temp_dir}/stderr" || { 
                        echo "Unable to display task stderr ($?)" 1>&2;
                        error_state=true
                    };
                else
                    cat "${temp_dir}/stderr" 1>&2 || { 
                        echo "Unable to display task stderr ($?)" 1>&2;
                        error_state=true
                    };
                fi;
            fi;
            if [ "${error_state}" = true ]; then
                softfail "Error reading STDOUT/STDERR in ssh::call";
                return 1;
            fi;
        fi;
    fi;
    if [ "${keep_temp_files}" != true ]; then
        ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'rm -fd "${temp_dir}/script" "${temp_dir}/stdin" "${temp_dir}/stdout" "${temp_dir}/stderr" "${temp_dir}/output_concat_good" "${temp_dir}/exit_status" "${temp_dir}/done" "${temp_dir}"';
        softfail --unless-good --status $? "Unable to remove remote temp files";
        if [ -n "${upload_remote_temp:-}" ]; then
            ssh "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "$(printf "rm -rf %q" "${upload_remote_temp}")")";
            softfail --unless-good --status $? "Unable to remove remote temp directory for file upload";
        fi;
    fi;
    return "${task_status}"
}
ssh::call::invoke () 
{ 
    local nohup_mode=false;
    local terminal_mode;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --nohup)
                nohup_mode=true;
                shift
            ;;
            --terminal)
                terminal_mode=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local remote_temp_dir="$1";
    shift;
    local ssh_destination="$1";
    shift;
    local command_string="$1";
    shift;
    command_string="$(printf "temp_dir=%q; ${command_string}" "${remote_temp_dir}" "$@")";
    if [ "${nohup_mode}" = true ]; then
        command_string="$(printf "nohup sh -c %q >/dev/null 2>/dev/null </dev/null" "${command_string}")";
    fi;
    ssh ${terminal_mode:+"-t"} "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "${command_string}")"
}
ssh::call::produce_script () 
{ 
    local command_mode=false;
    local terminal_mode=false;
    local cd_to_home=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --command)
                command_mode=true;
                shift
            ;;
            --home)
                cd_to_home=true;
                shift
            ;;
            --terminal)
                terminal_mode=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local joined_command="$*";
    if [ -n "${joined_command//[[:blank:][:cntrl:]]/}" ]; then
        local command_present=true;
    else
        local command_present=false;
    fi;
    if [ "${command_present}" = false ] && [ "${terminal_mode}" = false ]; then
        softfail "Command should be specified (note that ssh::call may ate your first argument as a host name if REMOTE_HOST is not provided)";
        return $?;
    fi;
    if shopt -o -q xtrace; then
        if [ -n "${PS4:-}" ]; then
            printf "PS4=%q\n" "${PS4}" || softfail;
        fi;
        echo "set -o xtrace";
    fi;
    if shopt -o -q nounset; then
        echo "set -o nounset";
    fi;
    local env_list=();
    if [ -n "${REMOTE_ENV:-}" ]; then
        IFS=" " read -r -a env_list <<< "${REMOTE_ENV}" || softfail || return $?;
    fi;
    local env_list_item;
    for env_list_item in "${env_list[@]}";
    do
        if [ -n "${!env_list_item:-}" ]; then
            printf "export %s\n" "$(printf "%q=%q" "${env_list_item}" "${!env_list_item}")";
        fi;
    done;
    if [ "${command_mode}" = false ] && [ "${command_present}" = true ] && declare -F "$1" > /dev/null; then
        if [ -z "${PS1:-}" ]; then
            declare -f || softfail "Unable to produce source code dump of functions" || return $?;
        else
            local function_name;
            declare -F | while IFS="" read -r function_name; do
                if ! ssh::call::interactive_terminal_functions_filter "${function_name:11}"; then
                    declare -f "${function_name:11}" || softfail "Unable to produce source code dump of function: ${function_name:11}" || return $?;
                fi;
            done;
        fi;
    fi;
    if [ "${cd_to_home}" = true ]; then
        echo 'cd "${HOME}" || exit $?';
    fi;
    if [ -n "${REMOTE_DIR:-}" ]; then
        printf "cd %q || exit \$?\n" "${REMOTE_DIR}";
    fi;
    if [ -n "${REMOTE_NON_ROOT_UMASK:-}" ]; then
        printf "if [ \"\${EUID}\" != 0 ]; then umask %q || exit \$?; fi\n" "${REMOTE_NON_ROOT_UMASK}";
    fi;
    if [ -n "${REMOTE_UMASK:-}" ]; then
        printf "umask %q || exit \$?\n" "${REMOTE_UMASK}";
    fi;
    local locale_list=();
    if [ -n "${REMOTE_LOCALE:-}" ]; then
        IFS=" " read -r -a locale_list <<< "${REMOTE_LOCALE}" || softfail || return $?;
    fi;
    if [ "${#locale_list[@]}" != 0 ]; then
        printf "unset -v LANG LANGUAGE \"\${!LC_@}\" || { echo 'Error unsetting locales' >&2; exit 1; }\n";
        local locale_item;
        for locale_item in "${locale_list[@]}";
        do
            printf "export %q || { echo 'Error setting REMOTE_LOCALE values' >&2; exit 1; }\n" "${locale_item}";
        done;
    fi;
    if [ "${command_present}" = false ] && [ "${terminal_mode}" = true ]; then
        echo '"${SHELL}"';
    else
        local command_string;
        printf -v command_string " %q" "$@" || softfail || return $?;
        echo "${command_string:1}";
    fi
}
ssh::call::set_ssh_args () 
{ 
    dir::ensure_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create directory: ${HOME}/.ssh" || return $?;
    dir::ensure_exists --mode 0700 "${HOME}/.ssh/control-sockets" || softfail "Unable to create directory: ${HOME}/.ssh/control-sockets" || return $?;
    if ! [[ "${OSTYPE}" =~ ^msys ]] && [ "${REMOTE_CONTROL_MASTER:-}" != "no" ]; then
        Ssh_Args+=("-o" "ControlMaster=${REMOTE_CONTROL_MASTER:-"auto"}");
        if [ "${REMOTE_FORWARD_AGENT:-}" = true ]; then
            Ssh_Args+=("-S" "${REMOTE_CONTROL_PATH:-"${HOME}/.ssh/control-sockets/%C.with-forward-agent"}");
        else
            Ssh_Args+=("-S" "${REMOTE_CONTROL_PATH:-"${HOME}/.ssh/control-sockets/%C"}");
        fi;
        Ssh_Args+=("-o" "ControlPersist=${REMOTE_CONTROL_PERSIST:-"600"}");
    fi;
    if [ "${REMOTE_FORWARD_AGENT:-}" = true ]; then
        Ssh_Args+=("-o" "ForwardAgent=yes");
    fi;
    if [ -n "${REMOTE_IDENTITY_FILE:-}" ]; then
        Ssh_Args+=("-i" "${REMOTE_IDENTITY_FILE}");
    fi;
    if [ -n "${REMOTE_PORT:-}" ]; then
        Ssh_Args+=("-p" "${REMOTE_PORT}");
    fi;
    if [ "${REMOTE_SERVER_ALIVE_INTERVAL:-}" != "unset" ]; then
        Ssh_Args+=("-o" "ServerAliveInterval=${REMOTE_SERVER_ALIVE_INTERVAL:-"20"}");
    fi;
    if [ -n "${REMOTE_USER:-}" ]; then
        Ssh_Args+=("-l" "${REMOTE_USER}");
    fi
}
ssh::gnome_keyring_credentials () 
{ 
    local key_file_path="$1";
    local password="$2";
    echo -n "${password}" | secret-tool store --label="Unlock password for: ${key_file_path}" unique "ssh-store:${key_file_path}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
ssh::gnome_keyring_credentials::exists () 
{ 
    local key_file_path="$1";
    secret-tool lookup unique "ssh-store:${key_file_path}" > /dev/null
}
ssh::install_authorized_keys_from_pass () 
{ 
    local profile_name;
    local file_owner;
    local file_group;
    local perhaps_sudo;
    local ssh_call=false;
    local ssh_call_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --profile-name)
                profile_name="$2";
                shift;
                shift
            ;;
            -o | --owner)
                file_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                file_group="$2";
                shift;
                shift
            ;;
            -s | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -c | --ssh-call)
                ssh_call=true;
                ssh_call_command+=(ssh::call);
                shift
            ;;
            -*)
                fail "Unknown argument: $1"
            ;;
            *)
                break
            ;;
        esac;
    done;
    local profile_path="$1";
    if [ -z "${profile_name:-}" ]; then
        profile_name="$(basename "${profile_path}")" || softfail || return $?;
    fi;
    local home_dir;
    if [ -n "${file_owner:-}" ]; then
        home_dir="$("${ssh_call_command[@]}" linux::get_home_dir "${file_owner}")" || softfail || return $?;
    else
        if [ "${ssh_call}" != true ]; then
            home_dir="${HOME}";
        fi;
    fi;
    "${ssh_call_command[@]}" dir::ensure_exists ${perhaps_sudo:+"--sudo"} --mode 0700 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} "${home_dir:+"${home_dir}/"}.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    if pass::secret_exists "${profile_path}/id_ed25519.pub"; then
        pass::use --consume-in-callback "${profile_path}/id_ed25519.pub" "${ssh_call_command[@]}" file::write ${perhaps_sudo:+"--sudo"} --mode 0600 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} --section "${profile_name}-id_ed25519.pub" "${home_dir:+"${home_dir}/"}.ssh/authorized_keys" || softfail || return $?;
    fi;
    if pass::secret_exists "${profile_path}/authorized_keys"; then
        pass::use --consume-in-callback --body "${profile_path}/authorized_keys" "${ssh_call_command[@]}" file::write ${perhaps_sudo:+"--sudo"} --mode 0600 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} --section "${profile_name}-authorized_keys" "${home_dir:+"${home_dir}/"}.ssh/authorized_keys" || softfail || return $?;
    fi
}
ssh::install_ssh_key_from_pass () 
{ 
    local secret_path="$1";
    local key_file_path;
    key_file_path="${2:-"${HOME}/.ssh/$(basename "${secret_path}")"}" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    pass::use --consume-in-callback --body "${secret_path}" file::write --mode 0600 "${key_file_path}" || softfail || return $?;
    if pass::secret_exists "${secret_path}.pub"; then
        pass::use "${secret_path}.pub" file::write --mode 0600 "${key_file_path}.pub" || softfail || return $?;
    fi;
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        pass::use --skip-if-empty "${secret_path}" ssh::gnome_keyring_credentials "${key_file_path}" || softfail || return $?;
    else
        if [[ "${OSTYPE}" =~ ^darwin ]]; then
            pass::use --skip-if-empty "${secret_path}" ssh::macos_keychain "${key_file_path}" || softfail || return $?;
        fi;
    fi
}
ssh::install_ssh_key_from_pass_to_remote () 
{ 
    local pass_args=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -*)
                pass_args+=("$1");
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    local secret_path="$1";
    local key_file_path;
    key_file_path="${2:-".ssh/$(basename "${secret_path}")"}" || softfail || return $?;
    ssh::call --home dir::ensure_exists --mode 0700 ".ssh" || softfail "Unable to create ssh user config directory" || return $?;
    pass::use "${pass_args[@]}" --consume-in-callback --body "${secret_path}" ssh::call --home file::write --mode 0600 "${key_file_path}" || softfail || return $?;
    if pass::secret_exists "${secret_path}.pub"; then
        pass::use "${pass_args[@]}" "${secret_path}.pub" ssh::call --home file::write --mode 0600 "${key_file_path}.pub" || softfail || return $?;
    fi
}
ssh::install_ssh_profile_from_pass () 
{ 
    local profile_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --profile-name)
                profile_name="$2";
                shift;
                shift
            ;;
            -*)
                fail "Unknown argument: $1"
            ;;
            *)
                break
            ;;
        esac;
    done;
    local profile_path="$1";
    if pass::secret_exists "${profile_path}/id_ed25519"; then
        ssh::install_ssh_key_from_pass "${profile_path}/id_ed25519" "${HOME}/.ssh/${profile_name}.id_ed25519" || softfail || return $?;
    fi;
    local config_file_path="${HOME}/.ssh/ssh_config.d/${profile_name}.conf";
    if [[ "${OSTYPE}" =~ ^linux ]] && pass::secret_exists "${profile_path}/config.linux"; then
        ssh::install_ssh_profile_from_pass::write_config "${profile_path}" "${profile_name}" "${config_file_path}" "${profile_path}/config.linux" || softfail || return $?;
    else
        if pass::secret_exists "${profile_path}/config"; then
            ssh::install_ssh_profile_from_pass::write_config "${profile_path}" "${profile_name}" "${config_file_path}" "${profile_path}/config" || softfail || return $?;
        else
            if pass::secret_exists "${profile_path}/id_ed25519"; then
                file::write --mode 0600 "${config_file_path}" <<< "IdentityFile ${HOME}/.ssh/${profile_name}.id_ed25519" || softfail || return $?;
            fi;
        fi;
    fi;
    if pass::secret_exists "${profile_path}/known_hosts"; then
        pass::use --consume-in-callback --body "${profile_path}/known_hosts" file::write --mode 0600 --section "${profile_name}" "${HOME}/.ssh/known_hosts" || softfail || return $?;
    fi
}
ssh::install_ssh_profile_from_pass::write_config () 
{ 
    local profile_path="$1";
    local profile_name="$2";
    local config_file_path="$3";
    local pass_config_path="$4";
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    pass::use --consume-in-callback --body "${pass_config_path}" file::write --mode 0600 "${temp_file}" || softfail || return $?;
    if pass::secret_exists "${profile_path}/id_ed25519"; then
        sed --in-place -E "s#IdentityFile %k#IdentityFile ${HOME}/.ssh/${profile_name}.id_ed25519#g" "${temp_file}" || softfail || return $?;
    fi;
    file::write --consume "${temp_file}" --mode 0600 "${config_file_path}" || softfail || return $?
}
ssh::macos_keychain () 
{ 
    local key_file_path="$1";
    local password="$2";
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    chmod 755 "${temp_file}" || softfail || return $?;
    printf "#!/bin/sh\nexec cat\n" > "${temp_file}" || softfail || return $?;
    echo "${password}" | SSH_ASKPASS="${temp_file}" DISPLAY=1 ssh-add -K "${key_file_path}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    rm "${temp_file}" || softfail || return $?
}
ssh::macos_keychain::configure_use_on_all_hosts () 
{ 
    local ssh_config_file="${HOME}/.ssh/config";
    if [ ! -f "${ssh_config_file}" ]; then
        ( umask 0177 && touch "${ssh_config_file}" ) || softfail || return $?;
    fi;
    if ! grep -q "^# Use keychain" "${ssh_config_file}"; then
        tee -a "${ssh_config_file}" <<EOF || 

# Use keychain
Host *
  UseKeychain yes
  AddKeysToAgent yes
EOF
 softfail "Unable to append to the file: ${ssh_config_file}" || return $?;
    fi
}
ssh::macos_keychain::exists () 
{ 
    local key_file_path="$1";
    ssh-add -L | grep -qF "${key_file_path}"
}
ssh::refresh_host_in_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    ssh::remove_host_from_known_hosts --port "${ssh_port}" "${host_name}" || softfail || return $?;
    ssh::wait_for_host_to_become_available --port "${ssh_port}" "${host_name}" || softfail || return $?;
    ssh::add_host_to_known_hosts --port "${ssh_port}" "${host_name}" || softfail || return $?
}
ssh::remove_host_from_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    if [ "${ssh_port}" = "22" ]; then
        local keygen_host_string="${host_name}";
    else
        local keygen_host_string="[${host_name}]:${ssh_port}";
    fi;
    ssh-keygen -R "${keygen_host_string}" || softfail || return $?
}
ssh::wait_for_host_to_become_available () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    while true; do
        local key;
        key="$(ssh-keyscan -p "${ssh_port}" "${host_name}" 2> /dev/null)";
        if [ -n "${key}" ]; then
            return 0;
        else
            if [ -t 2 ]; then
                echo "Waiting for SSH to become available on host '${host_name}'..." 1>&2;
            fi;
            sleep 1 || softfail || return $?;
        fi;
    done
}
sshd::disable_password_authentication () 
{ 
    dir::ensure_exists --sudo --mode 0755 /etc/ssh || softfail || return $?;
    dir::ensure_exists --sudo --mode 0755 /etc/ssh/sshd_config.d || softfail || return $?;
    file::write --sudo --mode 0644 /etc/ssh/sshd_config.d/disable-password-authentication.conf <<SHELL || 
PasswordAuthentication no
AuthenticationMethods publickey
SHELL
 softfail || return $?
}
sublime_merge::get_config_path () 
{ 
    local config_path;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        config_path="${HOME}/Library/Application Support/Sublime Merge";
    else
        if [[ "${OSTYPE}" =~ ^msys ]]; then
            config_path="${APPDATA}/Sublime Merge";
        else
            dir::ensure_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
            config_path="${HOME}/.config/sublime-merge";
        fi;
    fi;
    dir::ensure_exists --mode 0700 "${config_path}" || softfail || return $?;
    echo "${config_path}"
}
sublime_merge::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "sublimetext" "https://download.sublimetext.com/ apt/stable/" "https://download.sublimetext.com/sublimehq-pub.gpg" || softfail || return $?;
        apt::install sublime-merge || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            true;
        fi;
    fi )
}
sublime_merge::install_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_merge::get_config_path)" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${config_path}/Packages" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${config_path}/Packages/User" || softfail || return $?;
    config::install "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_merge::merge_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_merge::get_config_path)" || softfail || return $?;
    config::merge "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_text::get_config_path () 
{ 
    local config_path;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        config_path="${HOME}/Library/Application Support/Sublime Text 3";
    else
        if [[ "${OSTYPE}" =~ ^msys ]]; then
            config_path="${APPDATA}/Sublime Text 3";
        else
            dir::ensure_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
            config_path="${HOME}/.config/sublime-text-3";
        fi;
    fi;
    dir::ensure_exists --mode 0700 "${config_path}" || softfail || return $?;
    echo "${config_path}"
}
sublime_text::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "sublimetext" "https://download.sublimetext.com/ apt/stable/" "https://download.sublimetext.com/sublimehq-pub.gpg" || softfail || return $?;
        apt::install sublime-text || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            true;
        fi;
    fi )
}
sublime_text::install_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${config_path}/Packages" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${config_path}/Packages/User" || softfail || return $?;
    config::install "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_text::install_package_control () 
{ 
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    local installed_packages="${config_path}/Installed Packages";
    local package_control_package="${installed_packages}/Package Control.sublime-package";
    if [ ! -f "${package_control_package}" ]; then
        dir::ensure_exists --mode 0700 "${installed_packages}" || softfail || return $?;
        local url="https://packagecontrol.io/Package%20Control.sublime-package";
        curl --fail --silent --show-error "${url}" --output "${package_control_package}.download_temp" || softfail "Unable to download ${url} ($?)" || return $?;
        mv "${package_control_package}.download_temp" "${package_control_package}" || softfail || return $?;
    fi
}
sublime_text::merge_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    config::merge "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
syncthing::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "syncthing" "https://apt.syncthing.net/ syncthing stable" "https://syncthing.net/release-key.txt" || softfail "Unable to add syncthing apt source" || return $?;
        apt::install syncthing || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm syncthing || softfail || return $?;
        fi;
    fi;
    systemctl --user --now enable syncthing.service || softfail || return $? )
}
syncthing::install::macos () 
{ 
    brew install syncthing || softfail || return $?;
    brew services start syncthing || softfail || return $?
}
syncthing::open () 
{ 
    xdg-open "http://127.0.0.1:8384" || softfail || return $?
}
systemd::block () 
{ 
    local block_name="$1";
    shift;
    local block_content;
    printf -v block_content "\n${block_name}=%s" "$@" || softfail || return $?;
    echo "${block_content:1}"
}
systemd::export_shell_function_as_command () 
{ 
    local command;
    command="$(declare -f "$1" | tail -n +3 | head -n -1 | sed -E "s/^\s*//"; test "${PIPESTATUS[*]}" = "0 0 0 0")" || softfail || return $?;
    echo "/usr/bin/bash -c '${command//\'/\\\'}'"
}
systemd::service_action () 
{ 
    local action_args=();
    local user_services=false;
    local ssh_call=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                action_args+=("$1" "$2");
                shift;
                shift
            ;;
            -u | --user)
                action_args+=("$1");
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                action_args+=("$1");
                shift
            ;;
            -c | --ssh-call)
                ssh_call=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local action="$1";
    shift;
    local ssh_call_command=();
    if [ "${ssh_call}" = true ]; then
        ssh_call_command+=(ssh::call);
        if [ "${user_services}" != true ]; then
            ssh_call_command+=(--root);
        else
            if [ "${action}" = "journal" ]; then
                local release_codename;
                release_codename="$("${ssh_call_command[@]}" lsb_release --codename --short)" || softfail || return $?;
                if [ "${release_codename}" = "focal" ]; then
                    ssh_call_command+=(--root);
                fi;
            fi;
        fi;
        if [ "${action}" = "journal" ] && [ "${1:-}" = "--follow" ]; then
            ssh_call_command+=(--direct);
        fi;
    fi;
    "${ssh_call_command[@]}" "systemd::service_action::${action}" "${action_args[@]}" "$@" || softfail || return $?
}
systemd::service_action::disable_timer () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    "${systemctl_command[@]}" stop "${service_name}.timer" || softfail || return $?;
    "${systemctl_command[@]}" disable "${service_name}.timer" || softfail || return $?
}
systemd::service_action::enable_timer () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    "${systemctl_command[@]}" reenable "${service_name}.timer" || softfail || return $?;
    "${systemctl_command[@]}" start "${service_name}.timer" || softfail || return $?
}
systemd::service_action::journal () 
{ 
    ( local service_name;
    local user_services=false;
    local follow_argument=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            --follow)
                follow_argument=(--follow);
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    . /etc/os-release || softfail || return $?;
    if [ "${user_services}" = true ] && [ "${VERSION_CODENAME:-}" = "focal" ]; then
        sudo journalctl "_SYSTEMD_USER_UNIT=${service_name}.service" --lines 2048 "${follow_argument[@]}" || softfail || return $?;
        return $?;
    fi;
    if [ "${user_services}" = true ]; then
        local journalctl_command=(journalctl --user);
    else
        local journalctl_command=(sudo journalctl);
    fi;
    "${journalctl_command[@]}" --unit "${service_name}.service" --lines 2048 "${follow_argument[@]}" || softfail || return $? )
}
systemd::service_action::start () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        systemctl --user --no-block start "${service_name}.service" || softfail || return $?;
    else
        sudo systemctl --no-block start "${service_name}.service" || softfail || return $?;
    fi
}
systemd::service_action::status () 
{ 
    local service_name;
    local user_services=false;
    local with_timer=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                with_timer=true;
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    local exit_statuses=();
    printf "\n";
    if [ "${with_timer}" = true ]; then
        "${systemctl_command[@]}" list-timers "${service_name}.timer" --all || softfail || return $?;
        exit_statuses+=($?);
        printf "\n\n\n";
        "${systemctl_command[@]}" status "${service_name}.timer";
        exit_statuses+=($?);
        printf "\n\n\n";
    fi;
    "${systemctl_command[@]}" status "${service_name}.service";
    exit_statuses+=($?);
    printf "\n";
    if [[ "${exit_statuses[*]}" =~ [^0[:space:]] ]]; then
        softfail || return $?;
    fi
}
systemd::service_action::stop () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        systemctl --user stop "${service_name}.service" || softfail || return $?;
    else
        sudo systemctl stop "${service_name}.service" || softfail || return $?;
    fi
}
systemd::service_tasks () 
{ 
    local with_timer;
    local action_args=();
    local envelope_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -e | --envelope)
                envelope_command+=("$2");
                shift;
                shift
            ;;
            -t | --with-timer)
                action_args+=("$1");
                with_timer=true;
                shift
            ;;
            -n | --service-name)
                action_args+=("$1" "$2");
                shift;
                shift
            ;;
            -u | --user | -c | --ssh-call)
                action_args+=("$1");
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" start || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" stop || softfail || return $?;
    if [ "${with_timer:-}" = true ]; then
        task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" enable_timer || softfail || return $?;
        task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" disable_timer || softfail || return $?;
    fi;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" status || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" journal || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" journal --follow || softfail || return $?
}
systemd::write_system_unit () 
{ 
    local name="$1";
    file::write --sudo --mode 0644 "/etc/systemd/system/${name}" || softfail || return $?
}
systemd::write_user_unit () 
{ 
    local name="$1";
    local user_units_dir="${HOME}/.config/systemd/user";
    dir::ensure_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${HOME}/.config/systemd" || softfail || return $?;
    dir::ensure_exists --mode 0700 "${user_units_dir}" || softfail || return $?;
    file::write --mode 0600 "${user_units_dir}/${name}" || softfail || return $?
}
tailscale::add_apt_source () 
{ 
    ( . /etc/os-release || softfail || return $?;
    apt::add_source_with_key "tailscale" "https://pkgs.tailscale.com/stable/${ID} ${VERSION_CODENAME} main" "https://pkgs.tailscale.com/stable/${ID}/${VERSION_CODENAME}.gpg" || softfail || return $? )
}
tailscale::is_logged_in () 
{ 
    local backend_state;
    backend_state="$(tailscale status --json | jq --raw-output --exit-status .BackendState; test "${PIPESTATUS[*]}" = "0 0")" || fail "Unable to obtain tailscale status";
    if [ "${backend_state}" = "NeedsLogin" ]; then
        return 1;
    else
        return 0;
    fi
}
task::add () 
{ 
    local task_type="basic-task";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -g | --group)
                task_type="task-group";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [[ ! -v RUNAG_TASK ]]; then
        declare -ga RUNAG_TASK=();
    fi;
    RUNAG_TASK+=("${task_type}" "$#" "$@");
    if [ "${task_type}" = "task-group" ]; then
        local function_name="$1";
        if ! declare -F "${function_name}" > /dev/null && declare -F "${function_name}::set" > /dev/null; then
            [[ "${function_name}" =~ ^[a-zA-Z0-9:_]+$ ]] || softfail "Error: Function name must contain only alphanumeric characters, colons (:), and underscores (_)." || return $?;
            eval "${function_name}() { task::display_set ${function_name}::set "\$@"; }";
        fi;
    fi
}
task::any () 
{ 
    [[ -v RUNAG_TASK ]] && (( ${#RUNAG_TASK[@]} > 0 ))
}
task::clear () 
{ 
    declare -ga RUNAG_TASK=() || softfail "Failed to clear the task array: unable to reset RUNAG_TASK." || return $?
}
task::display () 
{ 
    local nested_display;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --nested-display)
                nested_display=true;
                shift
            ;;
            -*)
                softfail "Unrecognized argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    task::any || softfail "The task list is empty." || return $?;
    if ! [ -t 0 ] || ! [ -t 1 ] || ! command -v fzf > /dev/null; then
        task::render --non-interactive || softfail "Error rendering tasks non-interactively." || return $?;
        return $?;
    fi;
    local prompt_color;
    local reset_attrs;
    prompt_color="$(printf "setaf 11\nbold" | tput -S 2> /dev/null)" || prompt_color="";
    reset_attrs="$(tput sgr 0 2> /dev/null)" || reset_attrs="";
    while :; do
        local fzf_task_list;
        local fzf_result_string;
        local fzf_status;
        local _fzf_result_tail;
        local main_pointer;
        local line_number;
        fzf_task_list="$(task::render --force-color-output)" || softfail "Failed to render task list for fzf interface." || exit $?;
        fzf_result_string="$(fzf --ansi --cycle --tac --with-nth="3.." --wrap ${line_number:+--bind "load:pos:-${line_number}"} <<< "${fzf_task_list}")";
        fzf_status=$?;
        if [ "${fzf_status}" = 1 ] || [ "${fzf_status}" = 130 ]; then
            if [ "${nested_display:-}" = true ]; then
                return 130;
            fi;
            return 0;
        fi;
        softfail --unless-good --status "${fzf_status}" "Error during task selection." || return $?;
        IFS=" " read -r main_pointer line_number _fzf_result_tail <<< "${fzf_result_string}";
        [[ "${main_pointer}" =~ ^[0-9]+$ ]] || softfail "Invalid task pointer: Non-numeric value." || return $?;
        [[ "${line_number}" =~ ^[0-9]+$ ]] || softfail "Invalid line_number: Non-numeric value." || return $?;
        local item_type="${RUNAG_TASK[${main_pointer}]}";
        local item_length="${RUNAG_TASK[$(( main_pointer + 1 ))]}";
        [[ "${item_length}" =~ ^[0-9]+$ ]] || softfail "Invalid task length: Non-numeric value." || return $?;
        if [ "${item_type}" != "basic-task" ] && [ "${item_type}" != "task-group" ]; then
            softfail "Unrecognized item type: ${item_type}" || return $?;
        fi;
        local command_array=();
        local item_pointer;
        for ((item_pointer = main_pointer + 2; item_pointer <= (main_pointer + 1 + item_length); item_pointer++ ))
        do
            case "${RUNAG_TASK[${item_pointer}]}" in 
                -c | --comment)
                    (( item_pointer += 1 ))
                ;;
                -*)
                    softfail "Unrecognized argument: ${RUNAG_TASK[${item_pointer}]}" || return $?
                ;;
                *)
                    break
                ;;
            esac;
        done;
        if ! (( item_pointer <= (main_pointer + 1 + item_length) )); then
            softfail "The selected task does not include a runnable command." || return $?;
        fi;
        if [ "${item_type}" = "task-group" ]; then
            command_array+=("${RUNAG_TASK[${item_pointer}]}" "--nested-display");
            command_array+=("${RUNAG_TASK[@]:$(( item_pointer + 1 )):$(( (item_length - 1) - (item_pointer - (main_pointer + 2)) ))}");
        else
            command_array+=("${RUNAG_TASK[@]:${item_pointer}:$(( item_length - (item_pointer - (main_pointer + 2)) ))}");
            if [ -t 1 ]; then
                printf "\n%s\n" "${prompt_color}> ${command_array[*]}${reset_attrs}";
            fi;
        fi;
        "${command_array[@]}";
        local command_status=$?;
        if [ "${command_status}" = 130 ] && [ "${item_type}" = "task-group" ]; then
            continue;
        fi;
        softfail --unless-good --status "${command_status}" "Error performing command (${command_status}): ${command_array[*]}" || return $?;
        return "${command_status}";
    done
}
task::display_set () 
{ 
    ( local function_name="$1";
    shift;
    local nested_display;
    if [ "${1:-}" = "--nested-display" ]; then
        nested_display=true;
        shift;
    fi;
    task::clear || softfail "Failed to clear existing tasks." || return $?;
    "${function_name}" "$@";
    softfail --unless-good --status $? "Task group function '${function_name}' failed to define tasks." || return $?;
    task::display ${nested_display:+"--nested-display"} )
}
task::render () 
{ 
    local non_interactive=false;
    local force_color_output=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --non-interactive)
                non_interactive=true;
                shift
            ;;
            -c | --force-color-output)
                force_color_output=true;
                shift
            ;;
            *)
                softfail "Unrecognized argument: $1" || return $?
            ;;
        esac;
    done;
    local comment_color="";
    local end_marker_color="";
    local reset_attrs="";
    if [ -t 1 ] || [ "${force_color_output}" = true ]; then
        comment_color="$(printf "setaf 13\nbold" | tput -S 2> /dev/null)" || comment_color="";
        end_marker_color="$(printf "setaf 14\nbold" | tput -S 2> /dev/null)" || end_marker_color="";
        reset_attrs="$(tput sgr 0 2> /dev/null)" || reset_attrs="";
    fi;
    local main_pointer;
    local output_line_number=1;
    for ((main_pointer = 0; main_pointer < ${#RUNAG_TASK[@]}; main_pointer++ ))
    do
        local item_type="${RUNAG_TASK[${main_pointer}]}";
        local item_length="${RUNAG_TASK[$(( main_pointer + 1 ))]}";
        [[ "${item_length}" =~ ^[0-9]+$ ]] || softfail "Invalid task length: Non-numeric value" || return $?;
        if [ "${item_type}" != "basic-task" ] && [ "${item_type}" != "task-group" ]; then
            softfail "Unrecognized item type: ${item_type}" || return $?;
        fi;
        local command_array=();
        local command_string;
        local comment="";
        local end_marker="";
        if [ "${item_type}" = "task-group" ]; then
            end_marker="# -->";
        fi;
        local item_pointer;
        for ((item_pointer = main_pointer + 2; item_pointer <= main_pointer + item_length + 1; item_pointer++ ))
        do
            case "${RUNAG_TASK[${item_pointer}]}" in 
                -c | --comment)
                    (( item_pointer += 1 ));
                    comment="${RUNAG_TASK[${item_pointer}]}"
                ;;
                -*)
                    softfail "Unrecognized argument: ${RUNAG_TASK[${item_pointer}]}" || return $?
                ;;
                *)
                    break
                ;;
            esac;
        done;
        (( item_pointer <= main_pointer + item_length + 1 )) || softfail "Task contains no actionable command" || return $?;
        command_array+=("${RUNAG_TASK[@]:${item_pointer}:$(( item_length - (item_pointer - (main_pointer + 2)) ))}");
        if [ "${non_interactive}" = true ]; then
            printf -v command_string " %q" "${command_array[@]}" || softfail || return $?;
        else
            command_string=" ${main_pointer} ${output_line_number} ${command_array[*]}";
        fi;
        printf '%s%s%s\n' "${command_string:1}" "${end_marker:+" ${end_marker_color}${end_marker}${reset_attrs}"}" "${comment:+" ${comment_color}# ${comment}${reset_attrs}"}";
        (( output_line_number += 1 ));
        (( main_pointer += item_length + 1 ));
    done
}
terminal::color_table () 
{ 
    for i in {0..15};
    do
        echo "$(tput setaf "${i}")tput setaf ${i}$(tput sgr 0)";
    done;
    for i in {0..15};
    do
        echo "$(tput setab "${i}")tput setab ${i}$(tput sgr 0)";
    done
}
terminal::header () 
{ 
    if [ -t 2 ]; then
        echo '
'"$(printf "setaf 14\nbold" | tput -S 2> /dev/null)# ${1}$(tput sgr 0 2> /dev/null)"'
';
    else
        echo '
'"# ${1}"'
';
    fi
}
ubuntu::pro::available () 
{ 
    ( . /etc/os-release || softfail || return $?;
    test "${ID:-}" = ubuntu && command -v pro > /dev/null )
}
ubuntu::pro::is_attached () 
{ 
    pro status --format json | jq --raw-output --exit-status '.attached == true' > /dev/null
}
ui::confirm () 
{ 
    if [ ! -t 0 ]; then
        fail "Input is not a terminal";
    fi;
    if [ -n "${1:-}" ]; then
        echo "";
        echo "$1";
    fi;
    local user_input;
    IFS="" read -r user_input || fail;
    while [ "${user_input}" != yes ] && [ "${user_input}" != y ]; do
        if [ "${user_input}" = no ] || [ "${user_input}" = n ]; then
            return 1;
        fi;
        echo 'Please enter "yes" or "y" to continue, "no" or "n" to stop.';
        IFS="" read -r user_input || fail;
    done;
    return 0
}
vscode::install::apt () 
{ 
    apt::add_source_with_key "vscode" "https://packages.microsoft.com/repos/code stable main" "https://packages.microsoft.com/keys/microsoft.asc" || softfail || return $?;
    apt::install code || softfail || return $?
}
vscode::install_extensions () 
{ 
    local extensions_list="$1";
    if [ -f "${extensions_list}" ]; then
        local installed_extensions_list;
        installed_extensions_list="$(vscode::list_extensions_to_temp_file)" || softfail "Unable get extensions list" || return $?;
        if ! diff --strip-trailing-cr "${extensions_list}" "${installed_extensions_list}" > /dev/null 2>&1; then
            local extension;
            if [[ "${OSTYPE}" =~ ^msys ]]; then
                local ifs_value='';
            else
                local ifs_value="";
            fi;
            while IFS="${ifs_value}" read -r extension; do
                if [ -n "${extension}" ]; then
                    code --install-extension "${extension}" || softfail "Unable to install vscode extension ${extension}" || return $?;
                fi;
            done < "${extensions_list}" || softfail "Unable to install vscode extensions" || return $?;
        fi;
        rm "${installed_extensions_list}" || softfail || return $?;
    fi
}
vscode::list_extensions_to_temp_file () 
{ 
    local temp_file;
    temp_file="$(mktemp)" || softfail "Unable to create temp file" || return $?;
    code --list-extensions | sort > "${temp_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to list extensions" || return $?;
    echo "${temp_file}"
}
wifi::connect () 
{ 
    local pass_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${pass_path:-}" ]; then
        softfail "--pass-path should be specified" || return $?;
    fi;
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    local absolute_item_path;
    for absolute_item_path in "${password_store_dir}/${pass_path}"/*;
    do
        if [ -f "${absolute_item_path}/ssid.gpg" ] && [ -f "${absolute_item_path}/password.gpg" ]; then
            local item_path="${absolute_item_path:$((${#password_store_dir}+1))}";
            local ssid;
            ssid="$(pass::use "${item_path}/ssid")" || softfail || return $?;
            local password;
            password="$(pass::use "${item_path}/password")" || softfail || return $?;
            if nmcli device wifi connect "${ssid}" password "${password}"; then
                return 0;
            fi;
        fi;
    done
}
wifi::is_available () 
{ 
    nmcli --terse device wifi rescan 2> /dev/null
}
wifi::is_connected () 
{ 
    nmcli --terse device wifi list | grep -E "^[*]" > /dev/null
}

# == By now, all required library functions should be available ==

# Option to skip loading the runagfile
if [ "${1:-}" == "--skip-runagfile-load" ]; then
  shift  # Remove the argument from the positional parameters
else
  # Load the runagfile
  if [ "${BASH_SOURCE[0]}" != "$0" ]; then # Script is sourced
    runagfile::load --if-exists
    softfail --unless-good --status $? "Error: Failed to load runagfile ($?)" || return $?
  else # Script is run directly
    runagfile::load --if-exists
    softfail --unless-good --status $? "Error: Failed to load runagfile ($?)" || exit $?
  fi
fi

# If the first argument is provided, treat it as a command, run it, and then exit or return depending on whether the script is sourced
if [ -n "${1:-}" ]; then
  if [ "${BASH_SOURCE[0]}" != "$0" ]; then  # Script is sourced
    "$@"
    softfail --unless-good --status $? "Error: Failed ($?) to run command: $*"
    return $?
  else  # Script is run directly
    "$@"
    softfail --unless-good --status $? "Error: Failed ($?) to run command: $*"
    exit $?
  fi
fi

# If no command is provided and the script is not sourced, attempt to run runagfile::main or display available tasks
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  if declare -F runagfile::main >/dev/null; then
    # Call the main function if it exists
    runagfile::main
    softfail --unless-good --status $? "Error: Failed to run runagfile::main ($?)"
    exit $?
  elif task::any && [ -t 0 ] && [ -t 1 ]; then
    # Display tasks interactively if available
    task::display
    softfail --unless-good --status $? "Error: Failed to display tasks ($?)"
    exit $?
  fi

  # Log an error if no entry point or command is provided
  log::error "Error: No function or command specified. Define 'runagfile::main' or supply a valid command to proceed."
  
  printf "\n"

  if task::any; then
    task::render --non-interactive || softfail || exit $?
  fi

  exit 1
fi
