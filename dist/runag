#!/usr/bin/env bash

#  Copyright 2012-2024 RÃ¹nag project contributors
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

# Set shell options only if the script is not sourced
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  # Enable verbose mode if RUNAG_VERBOSE is true
  if [ "${RUNAG_VERBOSE:-}" = true ]; then
    # PS4: Customize trace output to include subshell, filename, line number, and function name
    PS4='+${BASH_SUBSHELL} ${BASH_SOURCE:+"${BASH_SOURCE}:${LINENO}: "}${FUNCNAME[0]:+"in \`${FUNCNAME[0]}'"'"' "}** '
    set -o xtrace   # Enable command tracing
  fi
  set -o nounset    # Treat unset variables as an error
fi

apt::add_source_with_key () 
{ 
    local source_name="$1";
    local source_string="$2";
    local key_url="$3";
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    curl --fail --silent --show-error "${key_url}" | gpg --dearmor > "${temp_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to get key or to save it: ${key_url}" || return $?;
    file::write --sudo --mode 0644 --absorb "${temp_file}" "/etc/apt/keyrings/${source_name}.gpg" || softfail || return $?;
    file::write --sudo --mode 0644 "/etc/apt/sources.list.d/${source_name}.list" <<< "deb [arch=amd64,arm64,armhf signed-by=/etc/apt/keyrings/${source_name}.gpg] ${source_string}" || softfail || return $?;
    apt::update || softfail || return $?
}
apt::autoremove () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y autoremove || softfail || return $?
}
apt::dist_upgrade () 
{ 
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --skip-in-ci | --skip-in-continuous-integration)
                if [ "${CI:-}" = "true" ]; then
                    return 0;
                fi;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    sudo DEBIAN_FRONTEND=noninteractive apt-get -o Dpkg::Options::="--force-confdef" -o Dpkg::Options::="--force-confold" -y dist-upgrade || softfail || return $?
}
apt::install () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y install "$@" || softfail || return $?
}
apt::remove () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get -y remove "$@" || softfail || return $?
}
apt::update () 
{ 
    sudo DEBIAN_FRONTEND=noninteractive apt-get update || softfail || return $?
}
asdf::add_plugin () 
{ 
    local plugin_name="$1";
    if asdf plugin list | grep -qFx "${plugin_name}"; then
        asdf plugin update "${plugin_name}" || softfail || return $?;
    else
        asdf plugin add "$@" || softfail || return $?;
    fi
}
asdf::add_plugin_and_install_package () 
{ 
    local package_name="$1";
    local package_version="${2:-"latest"}";
    asdf::add_plugin "${package_name}" || softfail || return $?;
    asdf install "${package_name}" "${package_version}" || softfail || return $?
}
asdf::add_plugin_install_package_and_set_global () 
{ 
    local package_name="$1";
    local package_version="${2:-"latest"}";
    asdf::add_plugin_and_install_package "${package_name}" "${package_version}" || softfail || return $?;
    asdf global "${package_name}" "${package_version}" || softfail || return $?
}
asdf::install () 
{ 
    local asdf_version;
    asdf_version="${1:-"$(github::query_release --get tag_name asdf-vm/asdf)"}" || softfail || return $?;
    git::place_up_to_date_clone --branch "${asdf_version}" "https://github.com/asdf-vm/asdf.git" "${HOME}/.asdf" || softfail || return $?;
    asdf::load || softfail || return $?
}
asdf::install_dependencies () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::install curl git || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm curl git || softfail || return $?;
        fi;
    fi )
}
asdf::install_shellfile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "profile/asdf" <<SHELL || 
${license_text}

if [ -f "\${HOME}/.asdf/asdf.sh" ]; then
  . "\${HOME}/.asdf/asdf.sh" || { echo "Unable to load asdf" >&2; return 1; }
fi
SHELL
 softfail || return $?
    shellfile::write "rc/asdf" <<SHELL || 
${license_text}

if [ -f "\${HOME}/.asdf/asdf.sh" ]; then
  . "\${HOME}/.asdf/asdf.sh" || { echo "Unable to load asdf" >&2; return 1; }

  if [ -n "\${BASH_VERSION:-}" ]; then
    . "\${HOME}/.asdf/completions/asdf.bash" || { echo "Unable to load asdf completions" >&2; return 1; }

  elif [ -n "\${ZSH_VERSION:-}" ]; then
    fpath=(\${ASDF_DIR}/completions \${fpath}) || { echo "Unable to set fpath" >&2; return 1; }
    autoload -Uz compinit || { echo "Unable to set compinit function to autoload" >&2; return 1; }
    compinit || { echo "Unable to run compinit" >&2; return 1; }

  fi
fi
SHELL
 softfail || return $?
}
asdf::install_with_shellrc () 
{ 
    asdf::install || softfail || return $?;
    asdf::install_shellfile || softfail || return $?
}
asdf::load () 
{ 
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -i | --if-installed)
                if [ ! -f "${HOME}/.asdf/asdf.sh" ]; then
                    return 0;
                fi;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    . "${HOME}/.asdf/asdf.sh" || softfail "Unable to load asdf" || return $?
}
asdf::path_env () 
{ 
    local home_dir="${HOME}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --user)
                home_dir="$(linux::get_home_dir "$2")" || softfail || return $?;
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "${ASDF_DATA_DIR:-"${home_dir}/.asdf"}/shims:${ASDF_DIR:-"${home_dir}/.asdf"}/bin"
}
asdf::shim_dir () 
{ 
    local home_dir="${HOME}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --user)
                home_dir="$(linux::get_home_dir "$2")" || softfail || return $?;
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    echo "${ASDF_DATA_DIR:-"${home_dir}/.asdf"}/shims"
}
aws::pass::create_access_key () 
{ 
    local pass_path;
    local user_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -u | --user-name)
                user_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local access_key;
    access_key="$(aws iam create-access-key --user-name "${user_name}")" || softfail || return $?;
    jq --raw-output --exit-status .AccessKey.AccessKeyId <<< "${access_key}" | pass insert --multiline "${pass_path}/id";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    jq --raw-output --exit-status .AccessKey.SecretAccessKey <<< "${access_key}" | pass insert --multiline "${pass_path}/secret";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
aws::pass::write_credentials_file () 
{ 
    local credentials_file;
    local pass_path;
    local profile_name="default";
    local ssh_call=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --credentials-file)
                credentials_file="$2";
                shift;
                shift
            ;;
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -e | --profile)
                profile_name="$2";
                shift;
                shift
            ;;
            -r | --ssh-call)
                ssh_call=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local command_prefix=();
    local default_credentials_dir="${HOME}/.aws";
    if [ "${ssh_call}" = true ]; then
        command_prefix+=("ssh::call");
        default_credentials_dir=".aws";
    fi;
    credentials_file="${credentials_file:-"${AWS_SHARED_CREDENTIALS_FILE:-"${default_credentials_dir}/credentials"}"}";
    local credentials_dir;
    credentials_dir="$(dirname "${credentials_file}")" || softfail || return $?;
    "${command_prefix[@]}" dir::should_exists --mode 0700 "${credentials_dir}" || softfail || return $?;
    local aws_access_key_id;
    aws_access_key_id="$(pass::use "${pass_path}/id")" || softfail || return $?;
    local aws_secret_access_key;
    aws_secret_access_key="$(pass::use "${pass_path}/secret")" || softfail || return $?;
    "${command_prefix[@]}" file::write_block --mode 0600 "${credentials_file}" "PROFILE ${profile_name}" <<INI || 
[${profile_name}]
aws_access_key_id=${aws_access_key_id}
aws_secret_access_key=${aws_secret_access_key}
INI
 softfail || return $?
}
benchmark::is_available () 
{ 
    if [[ "${OSTYPE}" =~ ^linux ]] || [[ "${OSTYPE}" =~ ^darwin ]]; then
        if command -v sysbench > /dev/null; then
            return 0;
        fi;
    fi;
    return 1
}
benchmark::run () 
{ 
    local hostname_string;
    hostname_string="$(hostnamectl --static status)" || softfail || return $?;
    local current_date;
    current_date="$(date --utc "+%Y-%m-%dT%H%M%SZ")" || softfail || return $?;
    local result_file;
    result_file="$(mktemp "benchmark-${hostname_string}-${current_date}-XXXX.txt")" || softfail || return $?;
    benchmark::run::indeed | tee "${result_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
benchmark::run::indeed () 
{ 
    ( echo "## CPU SPEED ##";
    sysbench cpu run || softfail || return $?;
    echo "## THREADS ##";
    sysbench threads run || softfail || return $?;
    echo "## RAM WRITE, 4KiB BLOCKS ##";
    sysbench memory run --memory-block-size=4096 || softfail || return $?;
    local temp_dir;
    temp_dir="$(mktemp -d "${HOME}/.benchmark-XXXXXX")" || softfail || return $?;
    cd "${temp_dir}" || softfail || return $?;
    sysbench fileio prepare --verbosity=2 --file-extra-flags=direct || softfail || return $?;
    sync || softfail || return $?;
    echo "## RANDOM READ QD1 ##";
    sysbench fileio run --file-test-mode=rndrd --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off --file-extra-flags=direct || softfail || return $?;
    echo "## RANDOM WRITE QD1 ##";
    sysbench fileio run --file-test-mode=rndwr --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on --file-extra-flags=direct || softfail || return $?;
    if ! [[ "${OSTYPE}" =~ ^darwin ]]; then
        echo "## RANDOM READ QD32 ##";
        sysbench fileio run --file-test-mode=rndrd --file-io-mode=async --file-async-backlog=32 --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off || softfail || return $?;
        echo "## RANDOM WRITE QD32 ##";
        sysbench fileio run --file-test-mode=rndwr --file-io-mode=async --file-async-backlog=32 --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on || softfail || return $?;
    fi;
    echo "## SEQUENTIAL READ ##";
    sysbench fileio run --file-test-mode=seqrd --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=off --file-extra-flags=direct || softfail || return $?;
    echo "## SEQUENTIAL WRITE ##";
    sysbench fileio run --file-test-mode=seqwr --file-extra-flags=sync --file-block-size=4096 --file-fsync-freq=0 --file-fsync-end=on --file-extra-flags=direct || softfail || return $?;
    sysbench fileio cleanup --verbosity=2 || softfail || return $?;
    rmdir "${temp_dir}" || softfail || return $? )
}
btrfs::check () 
{ 
    sudo btrfs check --readonly --progress "$@" || softfail || return $?
}
btrfs::scrub () 
{ 
    sudo btrfs scrub start "$@" || softfail || return $?
}
btrfs::scrub_status () 
{ 
    sudo btrfs scrub status -d "$@" || softfail || return $?
}
checksum::create_or_update () 
{ 
    local directory="$1";
    local current_checksum_file="$2";
    local checksum_algo="sha3-256";
    local new_checksum_file;
    new_checksum_file="$(mktemp)" || softfail || return $?;
    ( cd "${directory}" || softfail || return $?;
    find . -type f ! -path "./${current_checksum_file}" "${@:3}" -exec openssl dgst "-${checksum_algo}" {} \; | LC_ALL=C sort > "${new_checksum_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    if [ ! -f "${current_checksum_file}" ]; then
        if [ "${RUNAG_CREATE_CHECKSUMS_WITHOUT_CONFIRMATION:-}" != true ]; then
            cat "${new_checksum_file}" || softfail || return $?;
        fi;
        if [ "${RUNAG_CREATE_CHECKSUMS_WITHOUT_CONFIRMATION:-}" = true ] || ui::confirm "Do you want to create the checksum file: ${directory}/${current_checksum_file} (yes/no)?"; then
            cp "${new_checksum_file}" "${current_checksum_file}" || softfail || return $?;
            if [ -d .git ]; then
                git add "${current_checksum_file}" || softfail || return $?;
                git commit -m "Creates checksum file" "${current_checksum_file}" || softfail || return $?;
            fi;
        fi;
        exit 0;
    fi;
    if diff --strip-trailing-cr "${current_checksum_file}" "${new_checksum_file}" > /dev/null 2>&1; then
        echo "Checksums are good: ${directory}/${current_checksum_file}";
        exit 0;
    fi;
    if command -v git > /dev/null; then
        git diff --ignore-cr-at-eol --color --unified=6 --no-index "${current_checksum_file}" "${new_checksum_file}" | tee;
    else
        diff --strip-trailing-cr --context=6 --color "${current_checksum_file}" "${new_checksum_file}";
    fi;
    if ui::confirm "Do you want to update the checksum file: ${directory}/${current_checksum_file} (yes/no)?"; then
        cp "${new_checksum_file}" "${current_checksum_file}" || softfail || return $?;
        if [ -d .git ]; then
            git add "${current_checksum_file}" || softfail || return $?;
            git commit -m "Updates checksum file" "${current_checksum_file}" || softfail || return $?;
        fi;
    fi );
    local result=$?;
    rm "${new_checksum_file}" || softfail || return $?;
    sync || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "checksum::create_or_update failed (${result})" || return $?;
    fi
}
checksum::verify () 
{ 
    ( local directory="$1";
    local current_checksum_file="$2";
    local checksum_algo="sha3-256";
    local new_checksum_file;
    new_checksum_file="$(mktemp)" || softfail || return $?;
    ( cd "${directory}" || softfail || return $?;
    if [ ! -f "${current_checksum_file}" ]; then
        softfail "Unable to find the checksum file: ${directory}/${current_checksum_file}" || return $?;
    fi;
    find . -type f ! -path "./${current_checksum_file}" "${@:3}" -exec openssl dgst "-${checksum_algo}" {} \; | LC_ALL=C sort > "${new_checksum_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    if diff --strip-trailing-cr "${current_checksum_file}" "${new_checksum_file}" > /dev/null 2>&1; then
        echo "Checksums are good: ${directory}/${current_checksum_file}";
        exit 0;
    fi;
    if command -v git > /dev/null; then
        git diff --ignore-cr-at-eol --color --unified=6 --no-index "${current_checksum_file}" "${new_checksum_file}" | tee;
    else
        diff --strip-trailing-cr --context=6 --color "${current_checksum_file}" "${new_checksum_file}";
    fi;
    softfail "Checksums are different (!): ${directory}/${current_checksum_file}" || return $? );
    local result=$?;
    rm "${new_checksum_file}" || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "checksum::verify failed (${result})" || return $?;
    fi )
}
cifs::credentials () 
{ 
    local credentials_file="$1";
    local cifs_username="$2";
    local cifs_password="$3";
    printf "username=%s\npassword=%s\n" "${cifs_username}" "${cifs_password}" | file::write --mode 0600 "${credentials_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
cifs::credentials::exists () 
{ 
    local credentials_file="$1";
    test -f "${credentials_file}"
}
cifs::mount () 
{ 
    local file_mode="0600";
    local dir_mode="0700";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --file-mode)
                file_mode="$2";
                shift;
                shift
            ;;
            -d | --dir-mode)
                dir_mode="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local server_path="$1";
    local mount_point="$2";
    local credentials_file="$3";
    dir::should_exists --mode "${dir_mode}" "${mount_point}" || softfail || return $?;
    local fstab_tag="# cifs mount: ${mount_point}";
    if ! grep -qFx "${fstab_tag}" /etc/fstab; then
        echo "${fstab_tag}" | sudo tee -a /etc/fstab > /dev/null || softfail || return $?;
        echo "${server_path} ${mount_point} cifs credentials=${credentials_file},uid=${USER},forceuid,gid=${USER},forcegid,file_mode=${file_mode},dir_mode=${dir_mode},nosetuids,echo_interval=10,noserverino,noposix  0  0" | sudo tee -a /etc/fstab > /dev/null || softfail || return $?;
    fi;
    sudo mount -a;
    findmnt --mountpoint "${mount_point}" > /dev/null || softfail "Filesystem is not mounted: ${mount_point}" || return $?
}
config::install () 
{ 
    local src="$1";
    local dst="$2";
    if [ -f "${dst}" ]; then
        config::merge "${src}" "${dst}" || softfail || return $?;
    else
        cp "${src}" "${dst}" || softfail || return $?;
    fi
}
config::merge () 
{ 
    local src="$1";
    local dst="$2";
    if [ -t 0 ]; then
        if [ -f "${dst}" ]; then
            if ! diff --strip-trailing-cr "${src}" "${dst}" > /dev/null 2>&1; then
                if command -v git > /dev/null; then
                    git diff --ignore-cr-at-eol --color --unified=6 --no-index "${dst}" "${src}" | tee;
                else
                    diff --strip-trailing-cr --context=6 --color "${dst}" "${src}";
                fi;
                local action;
                echo "Files are different:";
                echo "  ${src}";
                echo "  ${dst}";
                echo "Please choose an action to perform:";
                echo "  1: Use file from the repository to replace file on this machine (apply the patch shown above)";
                echo "  2: Use file from this machine to save it to the repository";
                echo "  3 (or Enter): Ignore conflict";
                IFS="" read -r action || softfail || return $?;
                if [ "${action}" = 1 ]; then
                    cp "${src}" "${dst}" || softfail || return $?;
                else
                    if [ "${action}" = 2 ]; then
                        cp "${dst}" "${src}" || softfail || return $?;
                    fi;
                fi;
            fi;
        fi;
    fi
}
cross_platform::config_home () 
{ 
    case "${OSTYPE}" in 
        linux*)
            echo "${XDG_CONFIG_HOME:-"${HOME}/.config"}"
        ;;
        darwin*)
            echo "${HOME}/Library/Application Support"
        ;;
        msys*)
            echo "${APPDATA}"
        ;;
        *)
            softfail "Platform is not supported" || return $?
        ;;
    esac
}
dir::should_exists () 
{ 
    ( local dir_mode;
    local dir_owner;
    local dir_group;
    local perhaps_sudo;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -m | --mode)
                dir_mode="0$2";
                shift;
                shift
            ;;
            -o | --owner)
                dir_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                dir_group="$2";
                shift;
                shift
            ;;
            -s | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -f | --for-me-only)
                dir_mode=0700;
                dir_owner="${USER}";
                dir_group="$(grep -E "^${USER}:" /etc/passwd | cut -d: -f4; test "${PIPESTATUS[*]}" = "0 0")" || softfail || return $?;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local dir_path="$1";
    if [ -n "${dir_mode:-}" ]; then
        umask "$(printf "0%o" "$(( 0777 - "${dir_mode}" ))")" || softfail || return $?;
    fi;
    ${perhaps_sudo:+"sudo"} mkdir ${dir_mode:+-m "${dir_mode}"} -p "${dir_path}" || softfail || return $?;
    if [ -n "${dir_mode:-}" ]; then
        ${perhaps_sudo:+"sudo"} chmod "${dir_mode}" "${dir_path}" || softfail || return $?;
    fi;
    if [ -n "${dir_owner:-}" ]; then
        ${perhaps_sudo:+"sudo"} chown "${dir_owner}${dir_group:+":${dir_group}"}" "${dir_path}" || softfail || return $?;
    else
        if [ -n "${dir_group:-}" ]; then
            ${perhaps_sudo:+"sudo"} chgrp "${dir_group}" "${dir_path}" || softfail || return $?;
        fi;
    fi )
}
direnv::save_variable_block () 
{ 
    ( local block_name="SHELL VARIABLES";
    local envrc_path=".envrc";
    local skip_allow_check=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -b | --block-name)
                block_name="$2";
                shift;
                shift
            ;;
            -e | --envrc-path)
                envrc_path="$2";
                shift;
                shift
            ;;
            -s | --skip-allow-check)
                skip_allow_check=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local envrc_dir;
    envrc_dir="$(dirname "${envrc_path}")" || softfail || return $?;
    local envrc_basename;
    envrc_basename="$(basename "${envrc_path}")" || softfail || return $?;
    cd "${envrc_dir}" || softfail "Unable to change directory: ${envrc_dir}" || return $?;
    if [ "${skip_allow_check}" != true ]; then
        local json_support_test;
        json_support_test="$(direnv status --json | head -c 1; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain direnv status" || return $?;
        if [ "${json_support_test}" = "{" ]; then
            local found_any;
            found_any="$(direnv status --json | jq --raw-output --exit-status 'if (.state | has("foundRC")) and (.state | has("foundRC")) then if .state.foundRC == null and .state.foundRC == null then "empty-ok" else "non-empty" end else false end'; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain possible empty list from direnv status" || return $?;
            if [ "${found_any}" != "empty-ok" ]; then
                local allowed_path;
                if ! allowed_path="$(direnv status --json | jq --raw-output --exit-status 'if .state.foundRC.allowed == 0 then .state.foundRC.path else false end'; test "${PIPESTATUS[*]}" = "0 0")"; then
                    direnv status --json 1>&2;
                    softfail "Found envrc file that is not currently allowed or unable to obtain foundRC.path from direnv status";
                    return $?;
                fi;
                if [ "${allowed_path}" != "${PWD}/${envrc_basename}" ]; then
                    direnv status --json 1>&2;
                    softfail "Allowed envrc file path is different than provided: ${PWD}/${envrc_basename}";
                    return $?;
                fi;
            fi;
        else
            if ! { 
                direnv status | grep -qFx "No .envrc or .env found" || { 
                    direnv status | grep -qFx "Found RC path ${PWD}/${envrc_basename}" && { 
                        direnv status | grep -qFx "Found RC allowed 0" || direnv status | grep -qFx "Found RC allowed true"
                    }
                }
            }; then
                direnv status 1>&2;
                softfail "Found envrc file that is not currently allowed, or allowed file path is different than provided: ${PWD}/${envrc_basename}";
                return $?;
            fi;
        fi;
    fi;
    shell::dump_variables --export "$@" | file::write_block --mode 0600 "${envrc_basename}" "${block_name}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    direnv allow || softfail || return $? )
}
erlang::install_dependencies () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        local package_list=(autoconf build-essential fop libncurses5-dev libssh-dev libxml2-utils m4 xsltproc);
        apt::install "${package_list[@]}" || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            local package_list=(base-devel fop libssh libxslt ncurses);
            sudo pacman --sync --needed --noconfirm "${package_list[@]}" || softfail || return $?;
        fi;
    fi )
}
erlang::install_dependencies::observer () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        local package_list;
        mapfile -t package_list < <(apt-cache --names-only search '^libwxgtk-webview.*-dev' | cut -d " " -f1) || softfail || return $?;
        apt::install libgl1-mesa-dev libglu1-mesa-dev libpng-dev "${package_list[@]}" || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            local package_list=(glu libpng mesa wxwidgets-gtk3);
            sudo pacman --sync --needed --noconfirm "${package_list[@]}" || softfail || return $?;
        fi;
    fi )
}
fail () 
{ 
    local exit_status;
    local unless_good=false;
    local perform_softfail=false;
    local trace_start=1;
    local message;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -e | --exit-status)
                exit_status="$2";
                shift;
                shift
            ;;
            -u | --unless-good)
                unless_good=true;
                shift
            ;;
            -s | --soft)
                perform_softfail=true;
                shift
            ;;
            -w | --wrapped-softfail)
                perform_softfail=true;
                trace_start=2;
                shift
            ;;
            -*)
                { 
                    declare -F "log::error" > /dev/null && log::error "Unknown argument for fail: $1"
                } || echo "Unknown argument for fail: $1" 1>&2;
                shift;
                message="$*";
                break
            ;;
            *)
                message="$1";
                break
            ;;
        esac;
    done;
    if [ -z "${message:-}" ]; then
        message="Abnormal termination";
    fi;
    if ! [[ "${exit_status:-}" =~ ^[0-9]+$ ]]; then
        exit_status=1;
    else
        if [ "${exit_status:-}" = 0 ]; then
            if [ "${unless_good}" = true ]; then
                return 0;
            fi;
            exit_status=1;
        fi;
    fi;
    { 
        declare -F "log::error" > /dev/null && log::error "${message}"
    } || echo "${message}" 1>&2;
    local trace_line trace_index trace_end=$((${#BASH_LINENO[@]}-1));
    for ((trace_index=trace_start; trace_index<=trace_end; trace_index++))
    do
        trace_line="  ${BASH_SOURCE[${trace_index}]}:${BASH_LINENO[$((trace_index-1))]}: in \`${FUNCNAME[${trace_index}]}'";
        { 
            declare -F "log::error" > /dev/null && log::error "${trace_line}"
        } || echo "${trace_line}" 1>&2;
    done;
    if [ "${perform_softfail}" = true ]; then
        return "${exit_status:-0}";
    fi;
    exit "${exit_status:-0}"
}
fail::function_sources () 
{ 
    declare -f fail || softfail || return $?;
    declare -f softfail || softfail || return $?
}
file::append_line_unless_present () 
{ 
    local perhaps_sudo;
    local keep_permissions;
    local file_mode;
    local file_owner;
    local file_group;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -k | --keep-permissions)
                keep_permissions=true;
                shift
            ;;
            -m | --mode)
                file_mode="$2";
                shift;
                shift
            ;;
            -o | --owner)
                file_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                file_group="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local line_content="$2";
    if ! ${perhaps_sudo:+"sudo"} test -e "${file_path}" || ! ${perhaps_sudo:+"sudo"} grep -qFx "${line_content}" "${file_path}"; then
        local temp_file;
        temp_file="$(mktemp)" || softfail || return $?;
        if ${perhaps_sudo:+"sudo"} test -f "${file_path}"; then
            ${perhaps_sudo:+"sudo"} cat "${file_path}" | sed "\$a\\" > "${temp_file}";
            test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
        fi;
        echo "${line_content}" >> "${temp_file}" || softfail || return $?;
        file::write ${perhaps_sudo:+"--sudo"} ${keep_permissions:+"--keep-permissions"} ${file_mode:+--mode "${file_mode}"} ${file_owner:+--owner "${file_owner}"} ${file_group:+--group "${file_group}"} --absorb "${temp_file}" "${file_path}" || softfail || return $?;
    fi
}
file::get_block () 
{ 
    local file_path="$1";
    local block_name="$2";
    if [ -f "${file_path}" ]; then
        test "$(sed -n "/^# BEGIN ${block_name}$/,/^# END ${block_name}$/p" < "${file_path}" | tail -n +2 | head -n -1 | wc -l)" -ge 1 || softfail "Block ${block_name} not found in ${file_path}" || return $?;
        sed -n "/^# BEGIN ${block_name}$/,/^# END ${block_name}$/p" < "${file_path}" | tail -n +2 | head -n -1;
        test "${PIPESTATUS[*]}" = "0 0 0" || softfail || return $?;
    fi
}
file::read_with_updated_block () 
{ 
    local perhaps_sudo;
    local source_file;
    local temp_file;
    local allow_empty;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -s | --source)
                source_file="$2";
                shift;
                shift
            ;;
            -a | --absorb)
                temp_file="$2";
                shift;
                shift
            ;;
            -e | --allow-empty)
                allow_empty=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local block_name="$2";
    local content_string="${3:-}";
    if ${perhaps_sudo:+"sudo"} test -f "${file_path}"; then
        ${perhaps_sudo:+"sudo"} cat "${file_path}" | sed "\$a\\" | sed "/^# BEGIN ${block_name}$/,/^# END ${block_name}$/d";
        test "${PIPESTATUS[*]}" = "0 0 0" || softfail || return $?;
    fi;
    if [ -z "${temp_file:-}" ]; then
        temp_file="$(mktemp)" || softfail || return $?;
        if [ -n "${source_file:-}" ]; then
            cp "${source_file}" "${temp_file}" || softfail "Unable to copy from source file" || return $?;
        else
            if [ "${content_string:+true}" = true ]; then
                echo "$content_string" > "${temp_file}" || softfail "Unable to write to temp file" || return $?;
            else
                cat > "${temp_file}" || softfail "Unable to write to temp file" || return $?;
            fi;
        fi;
    fi;
    if [ ! -r "${temp_file}" ]; then
        softfail "Temporary file is not readable: ${temp_file}" || return $?;
    fi;
    if [ "${allow_empty:-}" != true ] && [ ! -s "${temp_file}" ]; then
        rm "${temp_file}" || softfail || return $?;
        softfail "Empty input for file::write" || return $?;
    fi;
    echo "# BEGIN ${block_name}";
    sed "\$a\\" < "${temp_file}" || softfail || return $?;
    echo "# END ${block_name}";
    rm "${temp_file}" || softfail || return $?
}
file::wait_until_available () 
{ 
    local file_path="$1";
    if [ ! -e "${file_path}" ]; then
        echo "File not found: '${file_path}'" 1>&2;
        echo "Please connect the external media if the file resides on it" 1>&2;
        echo "Waiting for the file to be available, press Control-C to interrupt" 1>&2;
    fi;
    while [ ! -e "${file_path}" ]; do
        sleep 0.1;
    done
}
file::write () 
{ 
    local perhaps_sudo;
    local keep_permissions;
    local file_mode;
    local file_owner;
    local file_group;
    local source_file;
    local temp_file;
    local allow_empty;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -k | --keep-permissions)
                keep_permissions=true;
                shift
            ;;
            -m | --mode)
                file_mode="$2";
                shift;
                shift
            ;;
            -o | --owner)
                file_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                file_group="$2";
                shift;
                shift
            ;;
            -s | --source)
                source_file="$2";
                shift;
                shift
            ;;
            -a | --absorb)
                temp_file="$2";
                shift;
                shift
            ;;
            -e | --allow-empty)
                allow_empty=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local content_string="${2:-}";
    if ${perhaps_sudo:+"sudo"} test -e "${file_path}" && ! ${perhaps_sudo:+"sudo"} test -f "${file_path}"; then
        softfail "Unable to write to file, it exists but it's not a regular file: ${file_path}" || return $?;
    fi;
    if [ "${perhaps_sudo:-}" = true ]; then
        if [ -z "${file_owner:-}" ]; then
            file_owner=root;
        fi;
        if [ -z "${file_group:-}" ]; then
            if [[ "${OSTYPE}" =~ ^darwin ]]; then
                file_group=wheel;
            else
                file_group=root;
            fi;
        fi;
    fi;
    if [ -z "${file_mode:-}" ]; then
        if [ "${keep_permissions:-}" = true ] && ${perhaps_sudo:+"sudo"} test -f "${file_path}"; then
            file_mode="$(${perhaps_sudo:+"sudo"} stat -c "%a" "${file_path}")" || softfail || return $?;
        else
            local umask_value;
            if [ "${perhaps_sudo:-}" = true ]; then
                umask_value="$(sudo /usr/bin/sh -c umask)" || softfail || return $?;
            else
                umask_value="$(umask)" || softfail || return $?;
            fi;
            file_mode="$(printf "%o" "$(( 0666 ^ "${umask_value}" ))")" || softfail || return $?;
        fi;
    fi;
    if [ -z "${temp_file:-}" ]; then
        temp_file="$(mktemp)" || softfail || return $?;
        if [ -n "${source_file:-}" ]; then
            cp "${source_file}" "${temp_file}" || softfail "Unable to copy from source file" || return $?;
        else
            if [ "${content_string:+true}" = true ]; then
                echo "$content_string" > "${temp_file}" || softfail "Unable to write to temp file" || return $?;
            else
                cat > "${temp_file}" || softfail "Unable to write to temp file" || return $?;
            fi;
        fi;
    fi;
    if [ ! -r "${temp_file}" ]; then
        softfail "Temporary file is not readable: ${temp_file}" || return $?;
    fi;
    if [ ! -s "${temp_file}" ] && [ "${allow_empty:-}" != true ]; then
        rm "${temp_file}" || softfail || return $?;
        softfail "Empty input for file::write" || return $?;
    fi;
    if [ -n "${file_owner:-}" ]; then
        ${perhaps_sudo:+"sudo"} chown "${file_owner}${file_group:+":${file_group}"}" "${temp_file}" || softfail || return $?;
    else
        if [ -n "${file_group:-}" ]; then
            ${perhaps_sudo:+"sudo"} chgrp "${file_group}" "${temp_file}" || softfail || return $?;
        fi;
    fi;
    ${perhaps_sudo:+"sudo"} chmod "${file_mode}" "${temp_file}" || softfail || return $?;
    ${perhaps_sudo:+"sudo"} mv "${temp_file}" "${file_path}" || softfail || return $?
}
file::write_block () 
{ 
    local perhaps_sudo;
    local keep_permissions;
    local file_mode;
    local file_owner;
    local file_group;
    local source_file;
    local temp_file;
    local allow_empty;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -u | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -k | --keep-permissions)
                keep_permissions=true;
                shift
            ;;
            -m | --mode)
                file_mode="$2";
                shift;
                shift
            ;;
            -o | --owner)
                file_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                file_group="$2";
                shift;
                shift
            ;;
            -s | --source)
                source_file="$2";
                shift;
                shift
            ;;
            -a | --absorb)
                temp_file="$2";
                shift;
                shift
            ;;
            -e | --allow-empty)
                allow_empty=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local block_name="$2";
    local content_string="${3:-}";
    local result_temp_file;
    result_temp_file="$(mktemp)" || softfail || return $?;
    file::read_with_updated_block ${perhaps_sudo:+"--sudo"} ${source_file:+"--source" "${source_file}"} ${temp_file:+"--absorb" "${temp_file}"} ${allow_empty:+"--allow-empty"} "${file_path}" "${block_name}" ${content_string:+"${content_string}"} > "${result_temp_file}" || softfail || return $?;
    file::write ${perhaps_sudo:+"--sudo"} ${keep_permissions:+"--keep-permissions"} ${file_mode:+--mode "${file_mode}"} ${file_owner:+--owner "${file_owner}"} ${file_group:+--group "${file_group}"} --absorb "${result_temp_file}" ${allow_empty:+"--allow-empty"} "${file_path}" || softfail || return $?
}
firefox::enable_wayland () 
{ 
    shellfile::write "profile/firefox-enable-wayland" <<SHELL || 
export MOZ_ENABLE_WAYLAND=1
SHELL
 softfail || return $?
}
firefox::set_pref () 
{ 
    local name="$1";
    local value="$2";
    local prefs_line="user_pref(\"${name}\", ${value});";
    local profile_dir;
    for profile_dir in "${HOME}/.mozilla/firefox"/*.default-release;
    do
        if [ -d "${profile_dir}" ]; then
            local prefs_file="${profile_dir}/prefs.js";
            if ! grep -qFx "${prefs_line}" "${prefs_file}"; then
                echo "${prefs_line}" >> "${prefs_file}" || softfail || return $?;
            fi;
        fi;
    done
}
fs::convert_msys_path_to_windows () 
{ 
    echo "$1" | sed "s/^\\/\\([[:alpha:]]\\)\\//\\1:\\//" | sed "s/\\//\\\\/g";
    test "${PIPESTATUS[*]}" = "0 0 0" || softfail || return $?
}
fs::get_absolute_path () 
{ 
    local relative_path="$1";
    local path_basename;
    path_basename="$(basename "${relative_path}")" || softfail "Unable to get a basename of '${relative_path}' ($?)" || return $?;
    local unresolved_dir;
    unresolved_dir="$(dirname "${relative_path}")" || softfail "Unable to get a dirname of '${relative_path}'" || return $?;
    local resolved_dir;
    resolved_dir="$(cd "${unresolved_dir}" > /dev/null 2>&1 && pwd)" || softfail "Unable to determine absolute path for '${unresolved_dir}'" || return $?;
    echo "${resolved_dir}/${path_basename}"
}
fs::update_symlink () 
{ 
    local target_thing="$1";
    local link_name="$2";
    if [ -e "${link_name}" ] && [ ! -L "${link_name}" ]; then
        softfail "Unable to create/update symlink, some non-link file exists: ${link_name}";
        return $?;
    fi;
    ln --symbolic --force --no-dereference "${target_thing}" "${link_name}" || softfail || return $?
}
fs::wait_until_mounted () 
{ 
    local mountpoint="$1";
    if ! findmnt --mountpoint "${mountpoint}" > /dev/null; then
        echo "Filesystem is not mounted: '${mountpoint}'" 1>&2;
        echo "Please connect the external media if the filesystem resides on it" 1>&2;
        echo "Waiting for the filesystem to be available, press Control-C to interrupt" 1>&2;
    fi;
    while ! findmnt --mountpoint "${mountpoint}" > /dev/null; do
        sleep 0.1;
    done
}
fs::with_secure_temp_dir_if_available () 
{ 
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        linux::with_secure_temp_dir "$@";
    else
        "$@";
    fi
}
fstab::add_mount_option () 
{ 
    local fstype;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --filesystem-type)
                fstype="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local option="$1";
    local skip;
    skip="$(sed 's/^\([[:alnum:]]\+\).*/\1/' <<< "${option}")" || softfail || return $?;
    sed "/^\(#\|[[:graph:]]\+[[:blank:]]\+[[:graph:]]\+[[:blank:]]\+${fstype}[[:blank:]]\+.*[[:blank:][:punct:]]${skip}\([[:blank:][:punct:]]\|$\)\)/!s/^\([[:graph:]]\+[[:blank:]]\+[[:graph:]]\+[[:blank:]]\+${fstype}[[:blank:]]\+defaults\)\([^[:alnum:]]\|$\)/\1,${option}\2/g;" /etc/fstab | fstab::verify_and_write;
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Error adding mount option to /etc/fstab" || return $?
}
fstab::verify_and_write () 
{ 
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    cat > "${temp_file}" || softfail "Error writing to temp file: ${temp_file}" || return $?;
    test -s "${temp_file}" || softfail "Error: fstab candidate should have size greater that zero: ${temp_file}" || return $?;
    findmnt --verify --tab-file "${temp_file}" 2>&1 || softfail "Failed to verify fstab candidate: ${temp_file}" || return $?;
    file::write --sudo --mode 0664 --absorb "${temp_file}" /etc/fstab || softfail "Failed to install new fstab: ${temp_file}" || return $?
}
git::add_or_update_remote () 
{ 
    local remote_name="$1";
    local remote_url="$2";
    if ! git config "remote.${remote_name}.url" > /dev/null; then
        git remote add "${remote_name}" "${remote_url}" || softfail || return $?;
    else
        git config "remote.${remote_name}.url" "${remote_url}" || softfail || return $?;
    fi
}
git::add_signed_off_by_trailer_in_commit_msg_hook () 
{ 
    ( local dest_path="${1:-}";
    if [ -n "${dest_path}" ]; then
        cd "${dest_path}" || softfail || return $?;
    fi;
    if [ ! -d .git ]; then
        softfail "Not in a git folder: ${PWD}" || return $?;
    fi;
    local hook_file=".git/hooks/commit-msg";
    if [ -s "${hook_file}" ]; then
        if [ "$(head -n 1 "${hook_file}")" != "#!/bin/sh" ]; then
            softfail "Not a /bin/sh script: ${hook_file}" || return $?;
        fi;
    else
        file::write --keep-permissions "${hook_file}" "#!/bin/sh" || softfail || return $?;
    fi;
    chmod u+x "${hook_file}" || softfail || return $?;
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    file::write_block --keep-permissions "${hook_file}" "add-signed-off-by-trailer" <<SHELL || 
${license_text}

user_name="\$(git config user.name)" || exit 1
user_email="\$(git config user.email)" || exit 1

git interpret-trailers --if-exists addIfDifferent --trailer "Signed-off-by: \${user_name} <\${user_email}>" --in-place "\$1"
SHELL
 softfail || return $? )
}
git::clone_or_update_local_mirror () 
{ 
    local source_path="$1";
    local dest_path="$2";
    local remote_name="${3:-}";
    local source_path_full;
    source_path_full="$(cd "${source_path}" > /dev/null 2>&1 && pwd)" || softfail || return $?;
    if [ ! -d "${dest_path}" ]; then
        git clone "${source_path_full}" "${dest_path}" || softfail || return $?;
        local mirror_origin;
        mirror_origin="$(git -C "${source_path_full}" remote get-url origin)" || softfail || return $?;
        git -C "${dest_path}" remote set-url origin "${mirror_origin}" || softfail || return $?;
        if [ -n "${remote_name}" ]; then
            git -C "${dest_path}" remote add "${remote_name}" "${source_path_full}" || softfail || return $?;
        fi;
    else
        git -C "${dest_path}" pull "${remote_name}" main || softfail || return $?;
    fi
}
git::create_or_update_mirror () 
{ 
    local source_url="$1";
    local dest_path="$2";
    if [ -d "${dest_path}" ]; then
        ( cd "${dest_path}" && git remote update ) || softfail || return $?;
    else
        git clone --mirror "${source_url}" "${dest_path}" || softfail || return $?;
    fi
}
git::ensure_git_is_installed () 
{ 
    ( if [[ "${OSTYPE}" =~ ^linux ]]; then
        if ! command -v git > /dev/null; then
            . /etc/os-release || softfail || return $?;
            if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
                apt::update || softfail || return $?;
                apt::install git || softfail || return $?;
            else
                if [ "${ID:-}" = arch ]; then
                    sudo pacman --sync --refresh --sysupgrade --noconfirm || softfail || return $?;
                    sudo pacman --sync --needed --noconfirm git || softfail || return $?;
                else
                    softfail "Unable to install git, your operating system is not supported" || return $?;
                fi;
            fi;
        fi;
    else
        if [[ "${OSTYPE}" =~ ^darwin ]]; then
            git --version > /dev/null || softfail "Please install git" || return $?;
        else
            if ! command -v git > /dev/null; then
                softfail "Unable to install git, your operating system is not supported" || return $?;
            fi;
        fi;
    fi )
}
git::get_remote_url_without_username () 
{ 
    local remote_name="${1:-"origin"}";
    git remote get-url "${remote_name}" | sed 's/^https:\/\/[[:alnum:]_]\+@/https:\/\//';
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
git::gnome_keyring_credentials () 
{ 
    local server="$1";
    local login="$2";
    local password="$3";
    echo -n "${password}" | secret-tool store --label="Git: https://${server}/" server "${server}" user "${login}" protocol https xdg:schema org.gnome.keyring.NetworkPassword;
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
git::gnome_keyring_credentials::exists () 
{ 
    local server="$1";
    local login="$2";
    secret-tool lookup server "${server}" user "${login}" protocol https xdg:schema org.gnome.keyring.NetworkPassword > /dev/null
}
git::install_libsecret_credential_helper () 
{ 
    if [ ! -f /usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret ]; then
        ( cd /usr/share/doc/git/contrib/credential/libsecret && sudo make ) || softfail "Unable to compile libsecret" || return $?;
    fi
}
git::install_profile_from_pass () 
{ 
    local pass_path="$1";
    if pass::exists "${pass_path}/user-name"; then
        local user_name;
        user_name="$(pass::use "${pass_path}/user-name")" || softfail || return $?;
        git config "${@:2}" user.name "${user_name}" || softfail || return $?;
    fi;
    if pass::exists "${pass_path}/user-email"; then
        local user_email;
        user_email="$(pass::use "${pass_path}/user-email")" || softfail || return $?;
        git config "${@:2}" user.email "${user_email}" || softfail || return $?;
    fi;
    if pass::exists "${pass_path}/signing-key"; then
        local signing_key;
        signing_key="$(pass::use "${pass_path}/signing-key")" || softfail || return $?;
        git config "${@:2}" commit.gpgsign true || softfail || return $?;
        git config "${@:2}" user.signingkey "${signing_key}" || softfail || return $?;
    fi
}
git::is_local_remote_connected () 
{ 
    local remote_name="${1:-"origin"}";
    local remote_path;
    remote_path="$(git config "remote.${remote_name}.url")" || fail "Remote url not found";
    if [[ ! "${remote_path}" =~ ^/ ]]; then
        fail "Remote path should be an absolute path: ${remote_path}";
    fi;
    [ -d "${remote_path}" ] && [ -f "${remote_path}/config" ]
}
git::is_remote_local () 
{ 
    local remote_name="${1:-"origin"}";
    local remote_path;
    remote_path="$(git config "remote.${remote_name}.url")" || fail "Remote url not found";
    if [[ "${remote_path}" =~ ^/ ]]; then
        return 0;
    fi;
    return 1
}
git::place_up_to_date_clone () 
{ 
    local branch_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -b | --branch)
                local branch_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local remote_url="$1";
    local dest_path="$2";
    if [ -d "${dest_path}" ]; then
        local current_url;
        current_url="$(cd "${dest_path}" && git config remote.origin.url)" || softfail || return $?;
        if [ "${current_url}" != "${remote_url}" ]; then
            git::remove_current_clone "${dest_path}" || softfail || return $?;
        fi;
    fi;
    if [ ! -d "${dest_path}" ]; then
        git clone "${remote_url}" "${dest_path}" || softfail "Unable to clone ${remote_url}" || return $?;
    fi;
    if [ -n "${branch_name:-}" ]; then
        ( cd "${dest_path}" && git remote update ) || softfail "Unable to perform git remote update: ${dest_path}" || return $?;
        ( cd "${dest_path}" && git fetch ) || softfail "Unable to perform git fetch: ${dest_path}" || return $?;
        ( cd "${dest_path}" && git checkout "${branch_name}" ) || softfail "Unable to perform git checkout: ${dest_path}" || return $?;
    else
        ( cd "${dest_path}" && git pull ) || softfail "Unable to perform git pull: ${dest_path}" || return $?;
    fi
}
git::remove_current_clone () 
{ 
    local dest_path="$1";
    local dest_full_path;
    dest_full_path="$(cd "${dest_path}" > /dev/null 2>&1 && pwd)" || softfail || return $?;
    local dest_parent_dir;
    dest_parent_dir="$(dirname "${dest_full_path}")" || softfail || return $?;
    local dest_dir_name;
    dest_dir_name="$(basename "${dest_full_path}")" || softfail || return $?;
    local backup_path;
    backup_path="$(mktemp -u "${dest_parent_dir}/${dest_dir_name}-PREVIOUS-CLONE-XXXXXXXXXX")" || softfail || return $?;
    mv "${dest_full_path}" "${backup_path}" || softfail || return $?
}
git::use_libsecret_credential_helper () 
{ 
    ( local libsecret_path;
    . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        libsecret_path="/usr/share/doc/git/contrib/credential/libsecret/git-credential-libsecret";
    else
        if [ "${ID:-}" = arch ]; then
            libsecret_path="/usr/lib/git-core/git-credential-libsecret";
        else
            softfail "Your operating system is not supported" || return $?;
        fi;
    fi;
    if [ ! -f "${libsecret_path}" ]; then
        softfail "Unable to find libsecret: ${libsecret_path}" || return $?;
    fi;
    git config --global credential.helper "${libsecret_path}" || softfail || return $? )
}
github::download_release () 
{ 
    local release_id="latest";
    local query_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --release-id)
                release_id="$2";
                shift;
                shift
            ;;
            -q | --query)
                query_string="$2";
                shift;
                shift
            ;;
            -l | --asset-label)
                query_string=".assets[] | select(.label == \"$2\").browser_download_url";
                shift;
                shift
            ;;
            -n | --asset-name)
                query_string=".assets[] | select(.name | test(\"$2\")).browser_download_url";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${query_string:-}" ]; then
        softfail "Query string should be specified" || return $?;
    fi;
    local repo_path="$1";
    local file_url;
    file_url="$(github::query_release --release-id "${release_id}" --query "${query_string}" "${repo_path}")" || softfail || return $?;
    if [ -z "${file_url}" ]; then
        softfail "Can't find release URL for ${repo_path} that matched ${query_string} and release ${release_id}" || return $?;
    fi;
    local temp_file;
    temp_file="$(mktemp)" || softfail "Unable to create temp file" || return $?;
    curl --location --fail --silent --show-error --output "${temp_file}" "${file_url}" > /dev/null || softfail "Unable to download ${file_url}" || return $?;
    echo "${temp_file}"
}
github::install_profile_from_pass () 
{ 
    local pass_path="$1";
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        git::use_libsecret_credential_helper || softfail || return $?;
        local github_username;
        github_username="$(pass::use "${pass_path}/username")" || softfail || return $?;
        pass::use "${pass_path}/personal-access-token" git::gnome_keyring_credentials "github.com" "${github_username}" || softfail || return $?;
    fi
}
github::query_release () 
{ 
    local release_id="latest";
    local query_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --release-id)
                release_id="$2";
                shift;
                shift
            ;;
            -g | --get)
                query_string=".$2";
                shift;
                shift
            ;;
            -q | --query)
                query_string="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${query_string:-}" ]; then
        softfail "Query string should be specified" || return $?;
    fi;
    local repo_path="$1";
    local api_url="https://api.github.com/repos/${repo_path}/releases/${release_id}";
    curl --fail --silent --show-error "${api_url}" | jq --raw-output --exit-status "${query_string}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
gpg::get_key_uid () 
{ 
    local source_path="$1";
    gpg --import --import-options show-only "${source_path}" | grep '^uid ' | head -n 1 | sed -E 's/^uid[[:space:]]+(.*)/\1/';
    test "${PIPESTATUS[*]}" = "0 0 0 0" || softfail || return $?
}
gpg::import_key () 
{ 
    local skip_if_exists trust_level should_confirm;
    local list_keys_command="--list-keys";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --confirm)
                should_confirm=true;
                shift
            ;;
            -s | --skip-if-exists)
                skip_if_exists=true;
                shift
            ;;
            -m | --trust-marginally)
                trust_level=4;
                shift
            ;;
            -f | --trust-fully)
                trust_level=5;
                shift
            ;;
            -u | --trust-ultimately)
                trust_level=6;
                shift
            ;;
            -e | --secret-key)
                list_keys_command="--list-secret-keys";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local gpg_key_id="$1";
    local source_path="$2";
    local trust_levels=(- - - - marginally fully ultimately);
    if [ "${skip_if_exists:-}" = true ] && gpg "${list_keys_command}" "${gpg_key_id}" > /dev/null 2>&1; then
        return 0;
    fi;
    if [ "${should_confirm:-}" = true ]; then
        local key_with_spaces;
        key_with_spaces="$(sed -E 's/(.{4})/\1 /g' <<< "${gpg_key_id}" | sed 's/ $//'; test "${PIPESTATUS[*]}" = "0 0")" || softfail || return $?;
        local key_base64;
        key_base64="$(xxd -r -p <<< "${gpg_key_id}" | base64 | sed -E 's/(.{4})/\1 /g' | sed 's/ $//'; test "${PIPESTATUS[*]}" = "0 0 0 0")" || softfail || return $?;
        echo "";
        echo "You are about to import GPG key with id: ${gpg_key_id}.";
        if [ -n "${trust_level:-}" ]; then
            echo "Trust level for that key will be set to \"Trust ${trust_levels[${trust_level}]}\"";
        fi;
        echo "Space-separated key id: ${key_with_spaces}";
        echo "Base64-encoded key id: ${key_base64}";
        echo "";
        echo "Data to be imported:";
        echo "";
        gpg --import --import-options show-only "${source_path}" || softfail || return $?;
        echo "Please confirm that it is your intention to do so by entering \"yes\"";
        echo "Please prepare the key password if needed";
        echo "Please enter \"no\" if you want to continue without this key being imported.";
        if ! ui::confirm; then
            log::warning "Key was not imported" || softfail || return $?;
            return 0;
        fi;
    fi;
    gpg --import "${source_path}" || softfail || return $?;
    if [ -n "${trust_level:-}" ]; then
        echo "${gpg_key_id}:${trust_level}:" | gpg --import-ownertrust || softfail || return $?;
    fi
}
imagemagick::set_policy::resource () 
{ 
    local policy_path="/etc/ImageMagick-6/policy.xml";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --policy-path)
                policy_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local name="$1";
    local value="$2";
    sudo sed --in-place "s/^.*\(<policy domain=\"resource\" name=\"${name}\" value=\"\).*\(\"\/>\)$/\1${value}\2/g" "${policy_path}" || softfail || return $?
}
leaseweb::domains::clear_acme_challenge () 
{ 
    leaseweb::domains::clear_record "_acme-challenge.${CERTBOT_DOMAIN}" TXT || softfail || return $?
}
leaseweb::domains::clear_record () 
{ 
    local record="$1";
    local record_type="$2";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    curl --fail --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request DELETE --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?
}
leaseweb::domains::extract_domain_from_host () 
{ 
    grep -E --only-matching "[a-zA-Z0-9\-]+\.[a-zA-Z0-9\-]+$" <<< "$1" || softfail || return $?
}
leaseweb::domains::get_short_record () 
{ 
    local record="$1";
    local record_type="$2";
    leaseweb::domains::list "${record}" "${record_type}" | jq --exit-status 'del(._links, .editable)';
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
leaseweb::domains::list () 
{ 
    local record="$1";
    local record_type="$2";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    curl --fail --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --request GET --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?
}
leaseweb::domains::set_acme_challenge () 
{ 
    leaseweb::domains::set_record "_acme-challenge.${CERTBOT_DOMAIN}" 1m TXT "${CERTBOT_VALIDATION}" || softfail || return $?
}
leaseweb::domains::set_record () 
{ 
    local record="$1";
    local record_ttl="$2";
    local record_type="$3";
    local record_data="$4";
    local domain;
    domain="$(leaseweb::domains::extract_domain_from_host "${record}")" || softfail || return $?;
    if [ "${record_ttl}" = 1m ]; then
        record_ttl=60;
    else
        if [ "${record_ttl}" = 5m ]; then
            record_ttl=300;
        else
            if [ "${record_ttl}" = 30m ]; then
                record_ttl=1800;
            else
                if [ "${record_ttl}" = 1h ]; then
                    record_ttl=3600;
                else
                    if [ "${record_ttl}" = 4h ]; then
                        record_ttl=14400;
                    else
                        if [ "${record_ttl}" = 8h ]; then
                            record_ttl=28800;
                        else
                            if [ "${record_ttl}" = 12h ]; then
                                record_ttl=43200;
                            else
                                if [ "${record_ttl}" = 1d ]; then
                                    record_ttl=86400;
                                fi;
                            fi;
                        fi;
                    fi;
                fi;
            fi;
        fi;
    fi;
    local domain_exists;
    domain_exists="$(curl --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request GET --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" --write-out "%{http_code}")" || softfail || return $?;
    if [ "${domain_exists}" = 200 ]; then
        curl --data "{ \"content\": [\"${record_data}\"], \"ttl\": ${record_ttl} }" --fail --header "content-type: application/json" --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request PUT --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets/${record}./${record_type}" || softfail || return $?;
    else
        if [ "${domain_exists}" = 404 ]; then
            curl --data "{ \"name\": \"${record}.\", \"type\": \"${record_type}\", \"content\": [\"${record_data}\"], \"ttl\": ${record_ttl} }" --fail --header "content-type: application/json" --header "X-Lsw-Auth: ${LEASEWEB_API_KEY}" --output /dev/null --request POST --show-error --silent --url "https://api.leaseweb.com/hosting/v2/domains/${domain}/resourceRecordSets" || softfail || return $?;
        else
            softfail "Domain check returned HTTP status code: ${domain_exists}";
            return $?;
        fi;
    fi
}
leaseweb::function_sources () 
{ 
    declare -f leaseweb::domains::get_short_record || softfail || return $?;
    declare -f leaseweb::domains::list || softfail || return $?;
    declare -f leaseweb::domains::set_record || softfail || return $?;
    declare -f leaseweb::domains::clear_record || softfail || return $?;
    declare -f leaseweb::domains::set_acme_challenge || softfail || return $?;
    declare -f leaseweb::domains::clear_acme_challenge || softfail || return $?;
    declare -f leaseweb::domains::extract_domain_from_host || softfail || return $?
}
letsencrypt::agree_tos_and_register_unsafely_without_email () 
{ 
    if [ ! -d /etc/letsencrypt/accounts ] || [ -z "$(ls -A /etc/letsencrypt/accounts)" ]; then
        sudo letsencrypt register --agree-tos --register-unsafely-without-email --non-interactive || softfail || return $?;
    fi
}
linux::adduser () 
{ 
    local user_name="${*: -1}";
    if ! id -u "${user_name}" > /dev/null 2>&1; then
        sudo adduser "$@" || softfail || return $?;
    fi
}
linux::configure_inotify () 
{ 
    local max_user_watches="1048576";
    local max_user_instances="2048";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -w | --max-user-watches)
                max_user_watches="$2";
                shift;
                shift
            ;;
            -i | --max-user-instances)
                max_user_instances="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    file::write --sudo --mode 0644 /etc/sysctl.d/runag-inotify.conf <<EOF || 
fs.inotify.max_user_watches=${max_user_watches}
fs.inotify.max_user_instances=${max_user_instances}
EOF
 softfail || return $?
    sudo sysctl --system || softfail || return $?
}
linux::get_cpu_count () 
{ 
    local cpu_count;
    cpu_count="$(grep -c ^processor /proc/cpuinfo 2> /dev/null)";
    if [[ "${cpu_count}" =~ ^[0-9]+$ ]]; then
        echo "${cpu_count}";
    else
        echo 1;
    fi
}
linux::get_default_path_env () 
{ 
    ( . /etc/environment && echo "${PATH}" || softfail || return $? )
}
linux::get_default_route () 
{ 
    ip route show | grep 'default via' | awk '{print $3}';
    test "${PIPESTATUS[*]}" = "0 0 0" || softfail || return $?
}
linux::get_home_dir () 
{ 
    local user_name="$1";
    getent passwd "${user_name}" | cut -d : -f 6;
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
linux::get_ipv4_address () 
{ 
    local ip_address;
    ip_address="$(ip route get 1.1.1.1 2> /dev/null | sed -n 's/^.*src \([[:digit:].]*\).*$/\1/p'; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain host ipv6 address" || return $?;
    if [ -z "${ip_address}" ]; then
        softfail "Unable to obtain host ipv6 address" || return $?;
    fi;
    echo "${ip_address}"
}
linux::get_ipv6_address () 
{ 
    local ip_address;
    ip_address="$(ip route get 2606:4700:4700::1111 2> /dev/null | sed -n 's/^.*src \([[:xdigit:]:]*\).*$/\1/p'; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain host ipv6 address" || return $?;
    if [ -z "${ip_address}" ]; then
        softfail "Unable to obtain host ipv6 address" || return $?;
    fi;
    echo "${ip_address}"
}
linux::install_gnome_keyring_and_libsecret () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::install gnome-keyring libsecret-tools libsecret-1-0 libsecret-1-dev || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm gnome-keyring libsecret || softfail || return $?;
        else
            softfail "Your operating system is not supported" || return $?;
        fi;
    fi )
}
linux::install_runag_essential_dependencies () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::install apt-transport-https curl git gpg jq pass xxd || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm curl git gnupg jq pass tinyxxd || softfail || return $?;
        fi;
    fi )
}
linux::is_user_exists () 
{ 
    local user_name="$1";
    id -u "${user_name}" > /dev/null 2>&1
}
linux::reset_locales () 
{ 
    local carry_on=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -c | --carry-on-with-disparities)
                carry_on=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local item;
    for item in "$@";
    do
        if [[ "${item}" =~ ^[[:alpha:]_]+=(.*)$ ]]; then
            local locale_match;
            locale_match="$(sed -E 's/[.]/[.]/g' <<< "${BASH_REMATCH[1]}")" || softfail || return $?;
            sudo sed --in-place -E 's/^#\s*('"${locale_match}"'(\s|$))/\1/g' /etc/locale.gen || softfail || return $?;
        fi;
    done;
    sudo locale-gen --keep-existing || softfail || return $?;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    { 
        local locale_line;
        for locale_line in "$@";
        do
            printf "%q\n" "${locale_line}" || softfail || return $?;
        done
    } > "${temp_file}" || softfail || return $?;
    file::write --sudo --absorb "${temp_file}" --mode 0644 /etc/locale.conf || softfail || return $?;
    shell::unset_locales || softfail || return $?;
    if [ "${carry_on}" = false ]; then
        local temp_file;
        temp_file="$(mktemp)" || softfail || return $?;
        ( declare -gx "$@" && /usr/bin/true ) 2> "${temp_file}" || softfail || return $?;
        if [ -s "${temp_file}" ]; then
            cat "${temp_file}" 1>&2 || softfail || return $?;
            rm "${temp_file}" || softfail || return $?;
            softfail "Unable to change locale, please try to run the same command once again in a new bash process";
            return $?;
        else
            rm "${temp_file}" || softfail || return $?;
        fi;
    fi;
    declare -gx "$@" || softfail || return $?
}
linux::set_battery_charge_control_threshold () 
{ 
    local battery_number=0;
    local if_present=false;
    local start_threshold=90;
    local end_threshold=100;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -b | --battery)
                battery_number="$2";
                shift;
                shift
            ;;
            -p | --if-present)
                if_present=true;
                shift
            ;;
            -s | --start)
                start_threshold="$2";
                shift;
                shift
            ;;
            -e | --end)
                end_threshold="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local battery_path="/sys/class/power_supply/BAT${battery_number}";
    if [ ! -d "${battery_path}" ]; then
        if [ "${if_present}" = true ]; then
            return 0;
        else
            softfail "Battery not found: ${battery_path}" || return $?;
        fi;
    fi;
    sudo tee "${battery_path}/charge_control_end_threshold" <<< "100" > /dev/null || softfail || return $?;
    sudo tee "${battery_path}/charge_control_start_threshold" <<< "${start_threshold}" > /dev/null || softfail || return $?;
    sudo tee "${battery_path}/charge_control_end_threshold" <<< "${end_threshold}" > /dev/null || softfail || return $?
}
linux::set_hostname () 
{ 
    local new_name="$1";
    local hosts_file="/etc/hosts";
    local previous_name;
    previous_name="$(hostnamectl --static status)" || softfail || return $?;
    if [ "${new_name}" = "${previous_name}" ]; then
        return 0;
    fi;
    local previous_name_escaped;
    previous_name_escaped="$(sed 's/\./\\./g' <<< "${previous_name}")" || softfail || return $?;
    file::append_line_unless_present --sudo --keep-permissions --mode 0644 "${hosts_file}" "127.0.1.1	${new_name}" || softfail || return $?;
    sudo hostnamectl set-hostname "${new_name}" || softfail || return $?;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    grep -vxE "[[:blank:]]*127.0.1.1[[:blank:]]+${previous_name_escaped}[[:blank:]]*" "${hosts_file}" > "${temp_file}" || softfail || return $?;
    file::write --sudo --keep-permissions --mode 0644 --absorb "${temp_file}" "${hosts_file}" || softfail || return $?
}
linux::set_timezone () 
{ 
    local timezone="$1";
    sudo timedatectl set-timezone "${timezone}" || softfail || return $?
}
linux::update_remote_locale () 
{ 
    ( shell::unset_locales || fail;
    export REMOTE_CONTROL_MASTER=no;
    ssh::call linux::reset_locales "$@" || fail )
}
linux::upgrade_system () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::autoremove || softfail || return $?;
        apt::update || softfail || return $?;
        apt::dist_upgrade --skip-in-continuous-integration || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --clean --noconfirm || softfail || return $?;
            sudo pacman --sync --sysupgrade --refresh --noconfirm || softfail || return $?;
        fi;
    fi )
}
linux::user_media_path () 
{ 
    if [ -d /run/media ]; then
        echo "/run/media/${USER}";
    else
        if [ -d /media ]; then
            echo "/media/${USER}";
        else
            softfail "Unable to determine user mounts path" || return $?;
        fi;
    fi
}
linux::with_secure_temp_dir () 
{ 
    local secure_temp_dir;
    secure_temp_dir="$(mktemp -d)" || softfail || return $?;
    sudo mount -t ramfs -o mode=700 ramfs "${secure_temp_dir}" || softfail || return $?;
    sudo chown "${USER}:${USER}" "${secure_temp_dir}" || softfail || return $?;
    ( export TMPDIR="${secure_temp_dir}";
    "$@" );
    local result=$?;
    sudo umount "${secure_temp_dir}" || softfail || return $?;
    rmdir "${secure_temp_dir}" || softfail || return $?;
    if [ "${result}" != 0 ]; then
        softfail "Error performing ${1:-"(argument is empty)"} (${result})" || return $?;
    fi
}
log::elapsed_time () 
{ 
    log::notice "Elapsed time: $((SECONDS / 3600))h$(((SECONDS % 3600) / 60))m$((SECONDS % 60))s"
}
log::error () 
{ 
    local message="${1:-"(empty log message)"}";
    if [ -t 2 ]; then
        echo "$(printf "setaf 9\nbold" | tput -S 2> /dev/null)${message}$(tput sgr 0 2> /dev/null)" 1>&2;
    else
        echo "[ERROR] ${message}" 1>&2;
    fi
}
log::function_sources () 
{ 
    declare -f log::error || softfail || return $?;
    declare -f log::warning || softfail || return $?;
    declare -f log::notice || softfail || return $?;
    declare -f log::success || softfail || return $?;
    declare -f log::elapsed_time || softfail || return $?
}
log::notice () 
{ 
    local message="${1:-"(empty log message)"}";
    if [ -t 2 ]; then
        echo "$(printf "setaf 14\nbold" | tput -S 2> /dev/null)${message}$(tput sgr 0 2> /dev/null)" 1>&2;
    else
        echo "[NOTICE] ${message}" 1>&2;
    fi
}
log::success () 
{ 
    local message="${1:-"(empty log message)"}";
    if [ -t 2 ]; then
        echo "$(printf "setaf 13\nbold" | tput -S 2> /dev/null)${message}$(tput sgr 0 2> /dev/null)" 1>&2;
    else
        echo "[SUCCESS] ${message}" 1>&2;
    fi
}
log::warning () 
{ 
    local message="${1:-"(empty log message)"}";
    if [ -t 2 ]; then
        echo "$(printf "setaf 11\nbold" | tput -S 2> /dev/null)${message}$(tput sgr 0 2> /dev/null)" 1>&2;
    else
        echo "[WARNING] ${message}" 1>&2;
    fi
}
macos::hide_dir () 
{ 
    if [ -d "$1" ]; then
        chflags hidden "$1" || softfail || return $?;
    fi
}
macos::increase_maxfiles_limit () 
{ 
    local soft_limit="${1:-"262144"}";
    local hard_limit="${2:-"524288"}";
    local label="runag.limit.maxfiles";
    local dst="/Library/LaunchDaemons/${label}.plist";
    if [ ! -f "${dst}" ]; then
        file::write --sudo --mode 0644 "${dst}" <<HTML || 
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN"
        "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>${label}</string>
    <key>ProgramArguments</key>
    <array>
      <string>launchctl</string>
      <string>limit</string>
      <string>maxfiles</string>
      <string>${soft_limit}</string>
      <string>${hard_limit}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>ServiceIPC</key>
    <false/>
  </dict>
</plist>
HTML
 softfail || return $?
        echo "increase_maxfiles_limit: Please reboot your computer" 1>&2;
    fi
}
macos::install_homebrew () 
{ 
    if ! command -v brew > /dev/null; then
        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" < /dev/null || softfail "Unable to install homebrew" || return $?;
    fi
}
nodejs::install::apt () 
{ 
    local version="$1";
    apt::add_source_with_key "nodesource" "https://deb.nodesource.com/node_${version}.x nodistro main" "https://deb.nodesource.com/gpgkey/nodesource.gpg.key" || softfail || return $?;
    apt::install nodejs || softfail || return $?
}
nodejs::install_dependencies () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        local package_list=(curl dirmngr gawk gpg);
        apt::install "${package_list[@]}" || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            local package_list=(curl gawk gnupg);
            sudo pacman --sync --needed --noconfirm "${package_list[@]}" || softfail || return $?;
        fi;
    fi )
}
nodejs::install_yarn::apt () 
{ 
    apt::add_source_with_key "yarnpkg" "https://dl.yarnpkg.com/debian/ stable main" "https://dl.yarnpkg.com/debian/pubkey.gpg" || softfail "Unable to add yarn apt source" || return $?;
    apt::install yarn || softfail || return $?
}
npm::auth_token () 
{ 
    local registry="registry.npmjs.org";
    local project_config;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --registry)
                registry="$2";
                shift;
                shift
            ;;
            -l | --project)
                project_config=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local token="$1";
    if [ "${project_config:-}" = true ]; then
        file::append_line_unless_present --keep-permissions ".gitignore" "/.npmrc" || softfail || return $?;
        if [ -f .npmignore ]; then
            file::append_line_unless_present --keep-permissions ".npmignore" "/.npmrc" || softfail || return $?;
        fi;
    fi;
    npm config set ${project_config:+"--location" "project"} "//${registry}/:_authToken" "${token}" || softfail || return $?;
    chmod 0600 ".npmrc" || softfail || return $?
}
npm::update_globally_installed_packages () 
{ 
    sudo NODENV_VERSION=system npm update -g --unsafe-perm=true || softfail || return $?
}
nvidia::enable_preserve_video_memory_allocations () 
{ 
    file::write --sudo --mode 0644 "/etc/modprobe.d/nvidia-power-management.conf" <<< "options nvidia NVreg_PreserveVideoMemoryAllocations=1" || softfail || return $?
}
nvidia::is_device_present () 
{ 
    lspci | grep -q "VGA.*NVIDIA Corporation";
    local savedPipeStatus="${PIPESTATUS[*]}";
    if [ "${savedPipeStatus}" = "0 1" ]; then
        return 0;
    else
        if [ "${savedPipeStatus}" = "1 0" ] || [ "${savedPipeStatus}" = "1 1" ]; then
            fail "Error calling lspci";
        fi;
    fi
}
pass::dir_exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -d "${password_store_dir}/${secret_path}" ]; then
        return 0;
    else
        return 1;
    fi
}
pass::each () 
{ 
    local test_expression="-f";
    local search_extension=".gpg";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dir | --directory)
                test_expression="-d";
                search_extension="";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local search_path="$1";
    shift;
    local password_store_dir;
    password_store_dir="$(realpath "${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}")";
    local absolute_search_path;
    absolute_search_path="$(realpath "${password_store_dir}/${search_path}")" || softfail || return $?;
    local found_path;
    for found_path in "${absolute_search_path}"/*"${search_extension}";
    do
        if test "${test_expression}" "${found_path}"; then
            local found_relative_path="${found_path:$((${#password_store_dir}+1))}";
            if [ "${test_expression}" = "-f" ]; then
                local dir_name;
                dir_name="$(dirname "${found_relative_path}")" || softfail || return $?;
                local base_name;
                base_name="$(basename -s .gpg "${found_relative_path}")" || softfail || return $?;
                found_relative_path="${dir_name}/${base_name}";
            fi;
            "$@" "${found_relative_path}";
            softfail --unless-good --exit-status $? || exit $?;
        fi;
    done
}
pass::exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -d "${password_store_dir}/${secret_path}" ] || [ -f "${password_store_dir}/${secret_path}".gpg ]; then
        return 0;
    else
        return 1;
    fi
}
pass::get_metadata () 
{ 
    local match_string="$1";
    local match_string_canonical;
    match_string_canonical="$(tr "[:upper:]" "[:lower:]" <<< "${match_string}" | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//"; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to produce match_string_canonical" || return $?;
    local line metadata_key;
    while IFS="" read -r line; do
        metadata_key="$(tr "[:upper:]" "[:lower:]" <<< "${line}" | cut -s -d ":" -f 1 | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//"; test "${PIPESTATUS[*]}" = "0 0 0")" || softfail "Unable to produce canonical metadata_key" || return $?;
        if [ "${metadata_key}" = "${match_string_canonical}" ]; then
            cut -s -d ":" -f 2- <<< "${line}" | sed "s/^[[:blank:]]*//;s/[[:blank:]]*$//";
            test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to produce metadata value" || return $?;
            return 0;
        fi;
    done;
    return 1
}
pass::secret_exists () 
{ 
    local secret_path="$1";
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    if [ -f "${password_store_dir}/${secret_path}".gpg ]; then
        return 0;
    else
        return 1;
    fi
}
pass::use () 
{ 
    local get_body=false;
    local get_metadata=false metadata_name;
    local get_multiline=false;
    local skip_if_empty=false;
    local skip_if_not_exists=false;
    local skip_update=false;
    local absorb_in_callback=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -a | --absorb-in-callback)
                absorb_in_callback=true;
                shift
            ;;
            -b | --body)
                get_body=true;
                shift
            ;;
            -g | --get)
                get_metadata=true;
                metadata_name="$2";
                shift;
                shift
            ;;
            -m | --multiline)
                get_multiline=true;
                shift
            ;;
            -e | --skip-if-empty)
                skip_if_empty=true;
                shift
            ;;
            -x | --skip-if-not-exists)
                skip_if_not_exists=true;
                shift
            ;;
            -u | --skip-update)
                skip_update=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local secret_path="$1";
    shift;
    local callback_function="${1:-}";
    shift;
    if [ "${skip_update}" = true ]; then
        if [ -z "${callback_function}" ]; then
            softfail "Callback function name should be specified" || return $?;
        fi;
        if ! declare -F "${callback_function}::exists" > /dev/null && ! command -v "${callback_function}::exists" > /dev/null; then
            softfail "${callback_function}::exists should be available as function or command" || return $?;
        fi;
        if "${callback_function}::exists" "$@"; then
            return 0;
        fi;
    fi;
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    local secret_file_path="${password_store_dir}/${secret_path}.gpg";
    if [ ! -f "${secret_file_path}" ]; then
        if [ "${skip_if_not_exists}" = true ]; then
            return 0;
        else
            softfail "Unable to find password file: ${secret_file_path}" || return $?;
        fi;
    fi;
    if [ "${get_body}" = true ] || [ "${get_multiline}" = true ]; then
        if [ "${absorb_in_callback}" = true ]; then
            if [ -z "${callback_function}" ]; then
                softfail "Callback function should be specified" || return $?;
            fi;
            local temp_file;
            temp_file="$(mktemp)" || softfail || return $?;
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2 > "${temp_file}";
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass" || return $?;
            else
                pass show "${secret_path}" > "${temp_file}" || softfail || return $?;
            fi;
            if [ -f "${temp_file}" ] && [ ! -s "${temp_file}" ]; then
                if [ "${skip_if_empty}" = true ]; then
                    return 0;
                fi;
                softfail "Zero-length secret data from pass" || return $?;
            fi;
            "${callback_function}" --absorb "${temp_file}" "$@";
            softfail --unless-good --exit-status $? "Unable to process secret data in ${callback_function} ($?)" || return $?;
            return 0;
        fi;
        if [ "${skip_if_empty}" = true ]; then
            softfail "--skip-if-empty is not supported for pipe output" || return $?;
        fi;
        if [ -n "${callback_function}" ]; then
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2 | "${callback_function}" "$@";
                test "${PIPESTATUS[*]}" = "0 0 0" || softfail "Unable to obtain secret from pass and process it with the callback function: ${callback_function}" || return $?;
            else
                pass show "${secret_path}" | "${callback_function}" "$@";
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass and process it with the callback function: ${callback_function}" || return $?;
            fi;
        else
            if [ "${get_body}" = true ]; then
                pass show "${secret_path}" | tail -n +2;
                test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to obtain secret from pass" || return $?;
            else
                pass show "${secret_path}" || softfail "Unable to obtain secret from pass" || return $?;
            fi;
        fi;
        return 0;
    fi;
    local secret_data;
    if [ "${get_metadata}" = true ]; then
        secret_data="$(pass show "${secret_path}" | tail -n +2 | pass::get_metadata "${metadata_name}"; test "${PIPESTATUS[*]}" = "0 0 0")" || softfail "Unable to obtain secret from pass" || return $?;
    else
        secret_data="$(pass show "${secret_path}" | head -n1; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain secret from pass" || return $?;
    fi;
    if [ -z "${secret_data}" ]; then
        if [ "${skip_if_empty}" = true ]; then
            if [ -n "${callback_function}" ]; then
                return 0;
            fi;
            softfail "--skip-if-empty is not supported for pipe output" || return $?;
        fi;
        softfail "Zero-length secret data from pass" || return $?;
    fi;
    if [ -n "${callback_function}" ]; then
        "${callback_function}" "$@" "${secret_data}";
        softfail --unless-good --exit-status $? "Unable to process secret data in ${callback_function} ($?)" || return $?;
    else
        printf "%s" "${secret_data}" || softfail || return $?;
    fi
}
postfix::install () 
{ 
    local mailname;
    local root_address;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -m | --mailname)
                mailname="$2";
                shift;
                shift
            ;;
            -r | --root-address)
                root_address="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    sudo debconf-set-selections <<EOF || 
postfix postfix/mailname string ${mailname}
postfix postfix/main_mailer_type select Internet Site
postfix postfix/root_address string ${root_address}
EOF
 fail
    apt::install postfix || fail;
    sudo sed --in-place -E "s/^mydestination.*$/mydestination = localhost.localdomain, localhost/g" /etc/postfix/main.cf || fail;
    sudo systemctl reload postfix || fail
}
postgresql::as_postgres_user () 
{ 
    local postgres_user;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        if [ -n "${SUDO_USER:-}" ]; then
            postgres_user="${SUDO_USER}";
        else
            postgres_user="${USER}";
        fi;
    else
        postgres_user=postgres;
    fi;
    sudo -i -u "${postgres_user}" "$@"
}
postgresql::create_role_if_not_exists () 
{ 
    local with_string;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --with)
                with_string="WITH $2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local role_name="${1:-"${PGUSER:-"${USER}"}"}";
    if ! postgresql::is_role_exists "${role_name}"; then
        postgresql::psql --sudo --query "CREATE ROLE ${role_name} ${with_string:-}" --dbname postgres || softfail || return $?;
    fi
}
postgresql::install_dictionaries () 
{ 
    ( local source_dir="$1";
    test -d "${source_dir}" || softfail "The directory does not exist: ${source_dir}" || return $?;
    . /etc/os-release || softfail || return $?;
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
            local dest_found=false;
            local dest;
            for dest in /usr/share/postgresql/*;
            do
                test -d "${dest}" || continue;
                postgresql::install_dictionaries::do || softfail || return $?;
                dest_found=true;
            done;
            if [ "${dest_found}" = false ]; then
                softfail "No destination were found for installation";
                return $?;
            fi;
        else
            if [ "${ID:-}" = arch ]; then
                local dest="/usr/share/postgresql";
                test -d "${dest}" || softfail "Destination directory not found: ${dest}" || return $?;
                postgresql::install_dictionaries::do || softfail || return $?;
            else
                softfail "Your operating system is not supported";
                return $?;
            fi;
        fi;
    else
        softfail "Your operating system is not supported";
        return $?;
    fi )
}
postgresql::install_dictionaries::do () 
{ 
    local file_found=false;
    local file;
    for file in "${source_dir}"/*;
    do
        test -f "${file}" || continue;
        local file_basename;
        file_basename="$(basename "${file}")" || softfail || return $?;
        file::write --sudo --mode 0644 --source "${file}" "${dest}/tsearch_data/${file_basename}" || softfail || return $?;
        file_found=true;
    done;
    if [ "${file_found}" = false ]; then
        softfail "No files were found for installation";
        return $?;
    fi
}
postgresql::is_database_exists () 
{ 
    local database_name="${1:-"${PGDATABASE}"}";
    local database_exists;
    database_exists="$(postgresql::psql --query "SELECT 1 FROM pg_database WHERE datname='${database_name}'" --dbname postgres)" || fail --exit-status 2 "Unable to query postgresql";
    test "${database_exists}" = 1
}
postgresql::is_role_exists () 
{ 
    local role_name="${1:-"${PGUSER:-"${USER}"}"}";
    local role_exists;
    role_exists="$(postgresql::psql --sudo --query "SELECT 1 FROM pg_roles WHERE rolname='${role_name}'" --dbname postgres)" || fail --exit-status 2 "Unable to query postgresql";
    test "${role_exists}" = 1
}
postgresql::psql () 
{ 
    local psql_command=(psql --set ON_ERROR_STOP=on);
    local arguments_list=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --sudo)
                local user_name;
                if [[ "${OSTYPE}" =~ ^darwin ]]; then
                    if [ -n "${SUDO_USER:-}" ]; then
                        user_name="${SUDO_USER}";
                    else
                        user_name="${USER}";
                    fi;
                else
                    user_name=postgres;
                fi;
                psql_command=(sudo -i -u "${user_name}" psql --username "${user_name}" --set ON_ERROR_STOP=on);
                shift
            ;;
            --query)
                arguments_list=(--no-align --echo-errors --quiet --tuples-only --command "$2");
                shift;
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    "${psql_command[@]}" "${arguments_list[@]}" "$@"
}
python::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::install python-is-python3 python3 pipx || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm python python-pipx || softfail || return $?;
        fi;
    fi )
}
rails::get_database_config () 
{ 
    ruby <(rails::get_database_config::ruby_script) "$1" || softfail "Unable to get database config from ruby" || return $?
}
rails::get_database_config::ruby_script () 
{ 
    cat <<RUBY
    require "yaml"

    key=ARGV[0]

    exit 1 unless key
    exit 1 if key.empty?
    
    config = YAML.load_file "config/database.yml"

    exit 1 unless config.is_a?(Hash)

    env_config = config[ENV["RAILS_ENV"] || "development"]

    exit 1 unless env_config.is_a?(Hash)

    value = env_config[key]

    exit 1 unless value
    exit 1 if value.empty?

    puts value
RUBY

}
rails::is_migration_pending () 
{ 
    bin/rails db:migrate:status | grep -cE "^[[:space:]]+down" > /dev/null;
    local saved_pipe_status=("${PIPESTATUS[@]}");
    test "${saved_pipe_status[0]}" = 0 || fail "Error performing 'bin/rails db:migrate:status'";
    test "${saved_pipe_status[1]}" = 0
}
release::build_and_deploy_services () 
{ 
    ( local release_dir;
    local load_local_runagfile;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --release-dir)
                release_dir="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${release_dir}" || softfail || return $?;
    if [ "${load_local_runagfile}" = true ]; then
        runagfile::load --working-directory-only || softfail || return $?;
    fi;
    if declare -F release::env > /dev/null; then
        release::env || softfail || return $?;
    fi;
    if declare -F release::build > /dev/null; then
        release::build || softfail || return $?;
    fi;
    if declare -F release::deploy_services > /dev/null; then
        release::deploy_services || softfail || return $?;
    fi )
}
release::cleanup () 
{ 
    local cleanup_kind;
    local keep_amount=6;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -k | --kind)
                cleanup_kind="$2";
                shift;
                shift
            ;;
            -p | --keep)
                keep_amount="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local release_item;
    for release_item in releases/*;
    do
        if [ -d "${release_item}" ]; then
            if [ "${cleanup_kind}" = successful ] && [ -f "${release_item}/.successful-release-flag" ]; then
                echo "${release_item}";
            else
                if [ "${cleanup_kind}" = non-successful ] && [ ! -f "${release_item}/.successful-release-flag" ]; then
                    echo "${release_item}";
                fi;
            fi;
        fi;
    done | sort | head --lines="-${keep_amount}" | while IFS="" read -r release_item; do
        echo "Cleaning up past release ${PWD}/${release_item}...";
        rm -rf "${release_item:?}" || softfail || return $?;
    done;
    if [[ "${PIPESTATUS[*]}" =~ [^0[:space:]] ]]; then
        softfail || return $?;
    fi
}
release::create () 
{ 
    ( local dest_path;
    local load_local_runagfile;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${dest_path}" || softfail || return $?;
    local current_date;
    current_date="$(date --utc "+%Y%m%dT%H%M%SZ")" || softfail || return $?;
    local release_dir;
    release_dir="$(mktemp -d "releases/${current_date}-XXX")" || softfail "Unable to make release directory" || return $?;
    git clone --quiet repo "${release_dir}" || softfail || return $?;
    release::build_and_deploy_services ${load_local_runagfile:+"--load-local-runagfile"} --release-dir "${release_dir}" || softfail || return $?;
    ln --symbolic --force --no-dereference "${release_dir}" "current" || softfail || return $?;
    touch "${release_dir}/.successful-release-flag" || softfail || return $?;
    release::cleanup --kind successful || softfail || return $?;
    release::cleanup --kind non-successful || softfail || return $? )
}
release::deploy () 
{ 
    local source_path;
    local dest_path;
    local load_local_runagfile;
    local ssh_call_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source)
                source_path="$2";
                shift;
                shift
            ;;
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -l | --load-local-runagfile)
                load_local_runagfile=true;
                shift
            ;;
            -c | --ssh-call)
                ssh_call_command+=(ssh::call);
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${dest_path:-}" ]; then
        dest_path="$(basename "${source_path}")" || softfail || return $?;
    fi;
    "${ssh_call_command[@]}" release::init --dest "${dest_path}" || softfail || return $?;
    release::push --source "${source_path}" --dest "${dest_path}" || softfail || return $?;
    "${ssh_call_command[@]}" release::create ${load_local_runagfile:+"--load-local-runagfile"} --dest "${dest_path}" || softfail || return $?
}
release::init () 
{ 
    local dest_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    dir::should_exists --mode 0700 "${dest_path}" || softfail || return $?;
    dir::should_exists --mode 0700 "${dest_path}/releases" || softfail || return $?;
    dir::should_exists --mode 0700 "${dest_path}/repo" || softfail || return $?;
    dir::should_exists --mode 0700 "${dest_path}/shared" || softfail || return $?;
    git init --quiet --bare "${dest_path}/repo" || softfail || return $?;
    ( cd "${dest_path}/repo" && git symbolic-ref HEAD refs/heads/main ) || softfail || return $?
}
release::push () 
{ 
    ( local source_path;
    local dest_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source)
                source_path="$2";
                shift;
                shift
            ;;
            -d | --dest)
                dest_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    cd "${source_path}" || softfail || return $?;
    local git_status_length;
    git_status_length="$(git status --porcelain=v1 | wc --bytes; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to obtain git status" || return $?;
    if [ "${git_status_length}" != 0 ]; then
        log::warning "There are uncommited changes in ${PWD}";
    fi;
    local remote_name="${REMOTE_USER}@${REMOTE_HOST}/${dest_path}";
    local git_remote_url="${REMOTE_USER:?}@${REMOTE_HOST:?}:${dest_path}/repo";
    git::add_or_update_remote "${remote_name}" "${git_remote_url}" || softfail || return $?;
    if git ls-remote --exit-code --heads "${remote_name}" main > /dev/null; then
        git pull --quiet "${remote_name}" main || fail;
    fi;
    git push --quiet "${remote_name}" main || fail )
}
restic::install () 
{ 
    local restic_version="$1";
    if command -v restic > /dev/null; then
        local installed_restic_version;
        installed_restic_version="$(restic version)" || softfail || return $?;
        if [[ "${installed_restic_version}" =~ ^[^[:digit:]]+([[:digit:]\.]+) ]] && [ "${BASH_REMATCH[1]}" = "${restic_version}" ]; then
            return 0;
        fi;
    fi;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    curl --location --fail --silent --show-error --output "${temp_file}" "https://github.com/restic/restic/releases/download/v${restic_version}/restic_${restic_version}_linux_amd64.bz2" > /dev/null || softfail || return $?;
    bzip2 --decompress --stdout "${temp_file}" > "${temp_file}.out" || softfail || return $?;
    file::write --sudo --mode 0755 --absorb "${temp_file}.out" /usr/local/bin/restic || softfail || return $?;
    rm "${temp_file}" || softfail || return $?
}
restic::open_mount_when_available () 
{ 
    local mount_path="$1";
    local cutoff_time="$((SECONDS+40))";
    ( while [ ! -d "${mount_path}/snapshots" ]; do
        sleep 0.1 || fail;
        if [ "${SECONDS}" -gt "${cutoff_time}" ]; then
            fail "Maximum time to wait for mount to complete has been reached";
        fi;
    done;
    if [ -d "${mount_path}/snapshots/latest" ]; then
        xdg-open "${mount_path}/snapshots/latest" || fail;
    else
        xdg-open "${mount_path}" || fail;
    fi ) &
}
rsync::rsh_string () 
{ 
    local Ssh_Args=();
    ssh::call::set_ssh_args || softfail || return $?;
    local rsh_string="";
    local ssh_arg;
    for ssh_arg in "${Ssh_Args[@]}";
    do
        rsh_string+=" '$(sed -E "s/'/''/" <<< "${ssh_arg}")'" || softfail || return $?;
    done;
    echo "ssh ${rsh_string:1}" || softfail || return $?
}
rsync::set_default_args () 
{ 
    Default_Rsync_Args=(--checksum --delete --links --perms --recursive --safe-links --times)
}
rsync::sync () 
{ 
    local from_remote=false;
    local to_remote=false;
    local rsync_args=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --from-remote)
                from_remote=true;
                shift
            ;;
            --to-remote)
                to_remote=true;
                shift
            ;;
            -*)
                rsync_args+=("$1");
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    local sources_and_destination;
    if [ "${from_remote}" = true ]; then
        sources_and_destination=("${REMOTE_HOST:+"${REMOTE_HOST}:"}$1" "$2");
    else
        if [ "${to_remote}" = true ]; then
            sources_and_destination=("$1" "${REMOTE_HOST:+"${REMOTE_HOST}:"}$2");
        else
            sources_and_destination=("$@");
        fi;
    fi;
    local Default_Rsync_Args;
    rsync::set_default_args || softfail || return $?;
    local rsh_string;
    rsh_string="$(rsync::rsh_string)" || softfail || return $?;
    rsync --rsh "${rsh_string}" "${Default_Rsync_Args[@]}" "${rsync_args[@]}" "${sources_and_destination[@]}" || softfail || return $?
}
ruby::dangerously_append_nodocument_to_gemrc () 
{ 
    file::append_line_unless_present --keep-permissions "${HOME}/.gemrc" "gem: --no-document" || softfail || return $?
}
ruby::gem () 
{ 
    local exit_status;
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    gem "$@" 2> "${temp_file}";
    exit_status=$?;
    if [ "${exit_status}" != 0 ]; then
        rm "${temp_file}" || softfail "Unable to remove temp file";
        return "${exit_status}";
    fi;
    if [ -s "${temp_file}" ]; then
        cat "${temp_file}" 1>&2 || softfail "Unable to read STDERR output from temp file: ${temp_file}" || return $?;
        if grep -q "^ERROR:" "${temp_file}"; then
            rm "${temp_file}" || softfail "Unable to remove temp file";
            softfail "Error found in rubygems output";
            return $?;
        fi;
    fi
}
ruby::install::apt () 
{ 
    ruby::install_dependencies || softfail || return $?;
    apt::install ruby-full || softfail || return $?
}
ruby::install_dependencies () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        local package_list=(build-essential libedit-dev libffi-dev libsqlite3-dev libssl-dev libyaml-dev zlib1g-dev);
        apt::install "${package_list[@]}" || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            local package_list=(base-devel libffi libyaml openssl rust sqlite zlib);
            sudo pacman --sync --needed --noconfirm "${package_list[@]}" || softfail || return $?;
        fi;
    fi )
}
ruby::install_disable_spring_shellfile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "profile/ruby-disable-spring" <<SHELL || 
${license_text}

export DISABLE_SPRING=true
SHELL
 softfail || return $?
}
ruby::without_docs () 
{ 
    RUBY_CONFIGURE_OPTS="--disable-install-doc" "$@" || softfail || return $?
}
rubygems::credentials () 
{ 
    local api_key="$1";
    local file_path="${HOME}/.gem/credentials";
    file::write --mode 0600 "${file_path}" <<YAML || 
---
:rubygems_api_key: ${api_key}
YAML
 softfail "Unable to write secret to file" || return $?
}
rubygems::credentials::exists () 
{ 
    local file_path="${HOME}/.gem/credentials";
    test -s "${file_path}"
}
rubygems::direnv_credentials () 
{ 
    local GEM_HOST_API_KEY="$1";
    direnv::save_variable_block --block-name RUBYGEMS-CREDENTIALS GEM_HOST_API_KEY || fail;
    file::append_line_unless_present --keep-permissions ".gitignore" "/.envrc" || softfail || return $?;
    if [ -f .npmignore ]; then
        file::append_line_unless_present --keep-permissions ".npmignore" "/.envrc" || softfail || return $?;
    fi
}
runag::command () 
{ 
    local try_name;
    local found_name;
    local found_index;
    local i=1;
    local item;
    while [ $i -le $# ]; do
        item="${!i}";
        if [[ "${item}" == -* ]]; then
            break;
        fi;
        try_name="${try_name:+"${try_name}::"}${item//-/_}";
        if declare -F "${try_name}" > /dev/null; then
            found_name="${try_name}";
            found_index="$i";
        fi;
        if declare -F "${try_name}::env" > /dev/null; then
            "${try_name}::env" "${@:i+1}";
            softfail --unless-good --exit-status $? "Error: Failed to run ${try_name}::env ($?)" || return $?;
        fi;
        ((i++));
    done;
    if [ -n "${found_name:-}" ]; then
        "${found_name}" "${@:found_index+1}";
    else
        softfail "Error: Unable to find suitable function for the arguments: $*";
        return $?;
    fi
}
runag::create_or_update_offline_install () 
{ 
    ( local runag_path="${HOME}/.runag";
    if [ -n "$1" ]; then
        cd "$1" || softfail || return $?;
    fi;
    local target_directory="${PWD}" || softfail || return $?;
    if [ ! -d "${runag_path}/.git" ]; then
        softfail "Unable to find rÃ¹nag checkout" || return $?;
    fi;
    local runag_remote_url;
    runag_remote_url="$(git -C "${runag_path}" remote get-url origin)" || softfail || return $?;
    git -C "${runag_path}" pull origin main || softfail || return $?;
    git -C "${runag_path}" push --set-upstream origin main || softfail || return $?;
    git::create_or_update_mirror "${runag_remote_url}" runag.git || softfail || return $?;
    ( cd "${runag_path}" && git::add_or_update_remote "offline-install" "${target_directory}/runag.git" && git fetch "offline-install" ) || softfail || return $?;
    dir::should_exists --mode 0700 "runagfiles" || softfail || return $?;
    local runagfile_path;
    for runagfile_path in "${runag_path}/runagfiles"/*;
    do
        if [ -d "${runagfile_path}" ]; then
            local runagfile_dir_name;
            runagfile_dir_name="$(basename "${runagfile_path}")" || softfail || return $?;
            local runagfile_remote_url;
            runagfile_remote_url="$(git -C "${runagfile_path}" remote get-url origin)" || softfail || return $?;
            git -C "${runagfile_path}" pull origin main || softfail || return $?;
            git -C "${runagfile_path}" push --set-upstream origin main || softfail || return $?;
            git::create_or_update_mirror "${runagfile_remote_url}" "runagfiles/${runagfile_dir_name}" || softfail || return $?;
            ( cd "${runagfile_path}" && git::add_or_update_remote "offline-install" "${target_directory}/runagfiles/${runagfile_dir_name}" && git fetch "offline-install" ) || softfail || return $?;
        fi;
    done;
    cp -f "${runag_path}/deploy-offline.sh" . || softfail || return $? )
}
runag::load_runag_library () 
{ 
    local self_path;
    local lib_dir;
    local file_path;
    if [ -L "${BASH_SOURCE[0]}" ]; then
        self_path="$(readlink -f "${BASH_SOURCE[0]}")" || { 
            echo "Error: Unable to resolve symlink ${BASH_SOURCE[0]} ($?)" 1>&2;
            return 1
        };
    else
        self_path="${BASH_SOURCE[0]}";
    fi;
    lib_dir="$(dirname "${self_path}")/$1" || { 
        echo "Error: Unable to determine directory for ${self_path} ($?)" 1>&2;
        return 1
    };
    if [ ! -d "${lib_dir}" ]; then
        echo "Error: rÃ¹nag library directory not found: ${lib_dir}" 1>&2;
        return 1;
    fi;
    for file_path in "${lib_dir}"/*.sh;
    do
        if [ -f "${file_path}" ]; then
            . "${file_path}" || { 
                echo "Error: Unable to load library file ${file_path} ($?)" 1>&2;
                return 1
            };
        fi;
    done
}
runag::mini_library () 
{ 
    printf "#!/usr/bin/env bash\n\n" || fail;
    runag::print_license || fail;
    printf "\n" || fail;
    if [ "${1:-}" = "--nounset" ]; then
        printf "set -o nounset\n\n" || fail;
    fi;
    declare -f fail || softfail || return $?;
    declare -f softfail || softfail || return $?;
    declare -f dir::should_exists || softfail || return $?;
    declare -f file::write || softfail || return $?
}
runag::print_license () 
{ 
    cat <<SHELL
#  Copyright 2012-2024 RÃ¹nag project contributors
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
SHELL

}
runag::tasks () 
{ 
    if [ -d "${HOME}/.runag" ]; then
        task::add --header "RÃ¹nag and rÃ¹nagfiles" || softfail || return $?;
        task::add runag::create_or_update_offline_install || softfail || return $?;
        task::add runag::update_current_offline_install || softfail || return $?;
    fi
}
runag::update_current_offline_install () 
{ 
    local runag_path="${HOME}/.runag";
    if [ ! -d "${runag_path}/.git" ]; then
        softfail "Unable to find rÃ¹nag checkout" || return $?;
    fi;
    local remote_path;
    remote_path="$(git -C "${runag_path}" config "remote.offline-install.url")" || softfail || return $?;
    runag::create_or_update_offline_install "${remote_path}/.." || softfail || return $?
}
runagfile::add () 
{ 
    local user_name;
    user_name="$(cut -d "/" -f 1 <<< "$1")" || softfail || return $?;
    local repo_name;
    repo_name="$(cut -d "/" -f 2 <<< "$1")" || softfail || return $?;
    git::place_up_to_date_clone "https://github.com/${user_name}/${repo_name}.git" "${HOME}/.runag/runagfiles/${repo_name}-${user_name}-github" || softfail || return $?
}
runagfile::add_from_list () 
{ 
    local line;
    while IFS="" read -r line; do
        if [ -n "${line}" ]; then
            runagfile::add "${line}" || softfail "Unable to add rÃ¹nagfile ${line}" || return $?;
        fi;
    done || softfail "Unable to add rÃ¹nagfiles from list" || return $?
}
runagfile::load () 
{ 
    local working_directory_only=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -w | --working-directory-only)
                working_directory_only=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -f "./runagfile.sh" ]; then
        . "./runagfile.sh";
        softfail --unless-good --exit-status $? "Unable to load ./runagfile.sh ($?)" || return $?;
    else
        if [ "${working_directory_only}" = false ] && [ -d "${HOME}/.runag/runagfiles" ]; then
            local dir_path;
            for dir_path in "${HOME}/.runag/runagfiles/"*;
            do
                if [ -f "${dir_path}/runagfile.sh" ]; then
                    . "${dir_path}/runagfile.sh";
                    softfail --unless-good --exit-status $? "Unable to load ${dir_path}/runagfile.sh ($?)" || return $?;
                fi;
            done;
        fi;
    fi
}
shell::assign_and_mark_for_export () 
{ 
    declare -gx "$1"="$2"
}
shell::dump_variables () 
{ 
    local prefix;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -e | --export)
                prefix="export ";
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local list_item;
    for list_item in "$@";
    do
        if [ -n "${!list_item:-}" ]; then
            echo "${prefix:-}$(printf "%q=%q" "${list_item}" "${!list_item}")";
        fi;
    done
}
shell::enable_trace () 
{ 
    PS4='+${BASH_SUBSHELL} ${BASH_SOURCE:+"${BASH_SOURCE}:${LINENO}: "}${FUNCNAME[0]:+"in \`${FUNCNAME[0]}'"'"' "}** ';
    set -o xtrace
}
shell::open () 
{ 
    "${SHELL}" "$@" || true
}
shell::related_cd () 
{ 
    local caller_dir;
    caller_dir="$(dirname "${BASH_SOURCE[1]}")" || softfail || return $?;
    cd "${caller_dir}" || softfail || return $?;
    if [ -n "${1:-}" ]; then
        cd "$1" || softfail || return $?;
    fi
}
shell::related_source () 
{ 
    local caller_dir;
    caller_dir="$(dirname "${BASH_SOURCE[1]}")" || softfail || return $?;
    recursive_flag=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --recursive)
                recursive_flag=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "${recursive_flag}" = true ]; then
        shell::related_source::walk_directory "${caller_dir}/$1" "${@:2}" || softfail "Unable to load: ${caller_dir}/$1" || return $?;
    else
        . "${caller_dir}/$1" "${@:2}" || softfail "Unable to load: ${caller_dir}/$1" || return $?;
    fi
}
shell::related_source::walk_directory () 
{ 
    local dir_list=();
    local item dir_item;
    for item in "$1/"*;
    do
        if [ -d "${item}" ]; then
            dir_list+=("${item}");
        else
            if [ -f "${item}" ] && [[ "${item}" =~ \.sh$ ]]; then
                . "${item}" "${@:2}" || softfail "Unable to load: ${item}" || return $?;
            fi;
        fi;
    done;
    for dir_item in "${dir_list[@]}";
    do
        shell::related_source::walk_directory "${dir_item}" "${@:2}" || softfail "Unable to load: ${dir_item}" || return $?;
    done
}
shell::unset_locales () 
{ 
    unset -v LANG LANGUAGE LC_ALL LC_COLLATE LC_CTYPE LC_MESSAGES LC_MONETARY LC_NUMERIC LC_TIME LC_ADDRESS LC_IDENTIFICATION LC_MEASUREMENT LC_NAME LC_PAPER LC_RESPONSE LC_TELEPHONE
}
shell::with () 
{ 
    ( local call_array=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --)
                shift;
                break
            ;;
            *)
                call_array+=("$1");
                shift
            ;;
        esac;
    done;
    "${call_array[@]}";
    softfail --unless-good --exit-status $? || return $?;
    "$@" )
}
shellfile::install_direnv_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/direnv" <<SHELL || 
${license_text}

if command -v direnv >/dev/null; then
  export DIRENV_LOG_FORMAT=""
  if [ -n "\${ZSH_VERSION:-}" ]; then
    eval "\$(direnv hook zsh)" || echo "Unable to hook direnv" >&2
  elif [ -n "\${BASH_VERSION:-}" ]; then
    eval "\$(direnv hook bash)" || echo "Unable to hook direnv" >&2
  fi
fi
SHELL
 softfail || return $?
}
shellfile::install_editor_rc () 
{ 
    local editor_path;
    editor_path="$(command -v "$1")" || softfail || return $?;
    shift;
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/editor" <<SHELL || 
${license_text}

if [ -z "\${EDITOR:-}" ]; then
  export EDITOR=$(printf "%q" "${editor_path}")
fi
SHELL
 softfail || return $?
}
shellfile::install_flush_history_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/flush-history" <<SHELL || 
${license_text}

if [ -n "\${BASH_VERSION:-}" ]; then
  export PROMPT_COMMAND="\${PROMPT_COMMAND:+"\${PROMPT_COMMAND}; "}history -a"
fi
SHELL
 softfail || return $?
}
shellfile::install_fzf_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/fzf" <<SHELL || 
${license_text}

export FZF_DEFAULT_OPTS="--exact"

if command -v fzf >/dev/null; then
  if [ -n "\${ZSH_VERSION:-}" ]; then
    source <(fzf --zsh) || echo "Unable to hook fzf" >&2
  elif [ -n "\${BASH_VERSION:-}" ]; then
    eval "\$(fzf --bash)" || echo "Unable to hook fzf" >&2
  fi
fi
SHELL
 softfail || return $?
}
shellfile::install_loader::bash () 
{ 
    shellfile::write_loader_block --file "${HOME}/.bashrc" --dir ".shellfile.d/rc" || softfail || return $?;
    if [ -f "${HOME}/.bash_profile" ] || [ ! -f "${HOME}/.profile" ]; then
        shellfile::write_loader_block --file "${HOME}/.bash_profile" --dir ".shellfile.d/profile" || softfail || return $?;
    else
        shellfile::write_loader_block --file "${HOME}/.profile" --dir ".shellfile.d/profile" || softfail || return $?;
    fi
}
shellfile::install_loader::zsh () 
{ 
    shellfile::write_loader_block --file "${HOME}/.zshrc" --dir ".shellfile.d/rc" || softfail || return $?;
    shellfile::write_loader_block --file "${HOME}/.zprofile" --dir ".shellfile.d/profile" || softfail || return $?
}
shellfile::install_local_bin_path_profile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "profile/local-bin-path" <<SHELL || 
${license_text}

if [ -d "\${HOME}/.local/bin" ]; then
  case ":\${PATH}:" in
  *":\${HOME}/.local/bin:"*)
    true
    ;;
  *)
    export PATH="\${HOME}/.local/bin:\${PATH}"
    ;;
  esac
fi
SHELL
 softfail || return $?
}
shellfile::install_runag_path_profile () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "profile/runag-path" <<SHELL || 
${license_text}

if [ -d "\${HOME}/.runag/bin" ]; then
  case ":\${PATH}:" in
  *":\${HOME}/.runag/bin:"*)
    true
    ;;
  *)
    export PATH="\${HOME}/.runag/bin:\${PATH}"
    ;;
  esac
fi
SHELL
 softfail || return $?
}
shellfile::install_short_prompt_rc () 
{ 
    local license_text;
    license_text="$(runag::print_license)" || softfail || return $?;
    shellfile::write "$@" "rc/short-prompt" <<SHELL || 
${license_text}

if [ -n "\${BASH_VERSION:-}" ]; then
  if tput cols >/dev/null 2>&1 && [ "\$(tput cols)" -le 140 ]; then
    PS1='\['"\$(tput setaf 12)\$(tput bold)"'\]\W\['"\$(tput sgr 0)"'\]\$ '
  fi
fi
SHELL
 softfail || return $?
}
shellfile::write () 
{ 
    local source_now=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --source-now)
                source_now=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local file_path="$1";
    local shellfile_dir_path="${HOME}/.shellfile.d";
    dir::should_exists --mode 0700 "${shellfile_dir_path}" || softfail || return $?;
    dir::should_exists --mode 0700 "${shellfile_dir_path}/rc" || softfail || return $?;
    dir::should_exists --mode 0700 "${shellfile_dir_path}/profile" || softfail || return $?;
    local output_path="${shellfile_dir_path}/${file_path}.sh";
    file::write --mode 0600 "${output_path}" || softfail || return $?;
    if [ "${source_now}" = true ]; then
        . "${output_path}" || softfail || return $?;
    fi
}
shellfile::write_loader_block () 
{ 
    local file_path;
    local directory_path;
    local block_name="shellfile-d-loader";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -f | --file)
                file_path="$2";
                shift;
                shift
            ;;
            -d | --dir)
                directory_path="$2";
                shift;
                shift
            ;;
            -b | --block)
                block_name="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    file::write_block --keep-permissions --mode 0644 "${file_path}" "${block_name}" <<SHELL || 
if [ -d "\${HOME}"/$(printf "%q" "${directory_path}") ]; then
  for __file_bb21go6nkCN82Gk9XeY2 in "\${HOME}"/$(printf "%q" "${directory_path}")/*.sh; do
    if [ -f "\${__file_bb21go6nkCN82Gk9XeY2}" ]; then
      . "\${__file_bb21go6nkCN82Gk9XeY2}" || { echo "Unable to load file \${__file_bb21go6nkCN82Gk9XeY2} (\$?)" >&2; }
    fi
  done
  unset __file_bb21go6nkCN82Gk9XeY2
fi
SHELL
 softfail || return $?
}
snapshot::cleanup () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_time=false;
    local daily_snapshot_count=30;
    local weekly_snapshot_count=14;
    local monthly_snapshot_count=12;
    local snapshots_by_time_count=14;
    if [ "$#" = 1 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    daily_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    weekly_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    monthly_snapshot_count="$2";
                    shift;
                fi;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                if [[ "${2:-}" =~ ^[[:digit:]]+$ ]]; then
                    snapshots_by_time_count="$2";
                    shift;
                fi;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 1 ]; then
        softfail "Snapshots directory must be specified";
        return $?;
    else
        local dest="${1:?}";
    fi;
    if [ "${daily_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/daily-snapshots" "${daily_snapshot_count}";
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/weekly-snapshots" "${weekly_snapshot_count}";
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshot::cleanup::dir "${dest}/monthly-snapshots" "${monthly_snapshot_count}";
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshot::cleanup::dir "${dest}/snapshots-by-time" "${snapshots_by_time_count}";
    fi
}
snapshot::cleanup::dir () 
{ 
    local snapshots_dir="${1:?}";
    local keep_amount="${2:-10}";
    local snapshot_path;
    local remove_this_snapshot;
    if [ ! -f "${snapshots_dir:?}"/.safe-to-cleanup ]; then
        softfail "Unable to find safe to cleanup flag. To indicate that it is safe to perform automatic cleanup please put \".safe-to-cleanup\" file in the directory that you are sure it is safe to cleanup.";
        return $?;
    fi;
    for snapshot_path in "${snapshots_dir:?}"/*;
    do
        if [ -d "${snapshot_path:?}" ]; then
            echo "${snapshot_path:?}";
        fi;
    done | sort | head "--lines=-${keep_amount:?}" | while IFS="" read -r remove_this_snapshot; do
        echo "Removing ${remove_this_snapshot:?}...";
        if [ "$(stat --format=%i "${remove_this_snapshot:?}")" -eq 256 ]; then
            sudo btrfs subvolume delete "${remove_this_snapshot:?}" || softfail || return $?;
        else
            rm -rf "${remove_this_snapshot:?}" || softfail || return $?;
        fi;
    done;
    if [[ "${PIPESTATUS[*]}" =~ [^0[:space:]] ]]; then
        softfail || return $?;
    fi
}
snapshot::create () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_name=false;
    local snapshots_by_time=false;
    local snapshot_name;
    if [ "$#" = 2 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                shift
            ;;
            -n | --name)
                snapshots_by_name=true;
                snapshot_name="${2:?}";
                shift;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 2 ]; then
        softfail "Source and snapshot directories must be specified";
        return $?;
    else
        local source="${1:?}";
        local dest="${2:?}";
    fi;
    local snapshot_path;
    if [ "${daily_snapshot}" = true ]; then
        snapshot_path="${dest}/daily-snapshots/$(date --utc "+%Y-%m-%d")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshot_path="${dest}/weekly-snapshots/$(date --utc "+%G-W%V")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshot_path="${dest}/monthly-snapshots/$(date --utc "+%Y-%m")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        fi;
    fi;
    if [ "${snapshots_by_name}" = true ]; then
        snapshot_path="${dest}/snapshots-by-name/${snapshot_name}";
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        else
            softfail "Snapshot directory already exist: ${snapshot_path}";
            return $?;
        fi;
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshot_path="${dest}/snapshots-by-time/$(date --utc "+%Y-%m-%dT%H%M%SZ")" || softfail || return $?;
        if [ ! -d "${snapshot_path}" ]; then
            btrfs subvolume snapshot -r "${source}" "${snapshot_path}" || softfail || return $?;
        else
            softfail "Snapshot directory already exist: ${snapshot_path}";
            return $?;
        fi;
    fi
}
snapshot::init () 
{ 
    local daily_snapshot=false;
    local weekly_snapshot=false;
    local monthly_snapshot=false;
    local snapshots_by_name=false;
    local snapshots_by_time=false;
    if [ "$#" = 1 ]; then
        snapshots_by_time=true;
    fi;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -d | --daily)
                daily_snapshot=true;
                shift
            ;;
            -w | --weekly)
                weekly_snapshot=true;
                shift
            ;;
            -m | --monthly)
                monthly_snapshot=true;
                shift
            ;;
            -n | --name)
                snapshots_by_name=true;
                shift
            ;;
            -t | --time)
                snapshots_by_time=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "$#" != 1 ]; then
        softfail "Snapshots directory must be specified";
        return $?;
    else
        local dest="${1:?}";
    fi;
    dir::should_exists --mode 0700 "${dest}" || softfail || return $?;
    local snapshots_path;
    if [ "${daily_snapshot}" = true ]; then
        snapshots_path="${dest}/daily-snapshots";
        dir::should_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${weekly_snapshot}" = true ]; then
        snapshots_path="${dest}/weekly-snapshots";
        dir::should_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${monthly_snapshot}" = true ]; then
        snapshots_path="${dest}/monthly-snapshots";
        dir::should_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${snapshots_by_name}" = true ]; then
        snapshots_path="${dest}/snapshots-by-name";
        dir::should_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi;
    if [ "${snapshots_by_time}" = true ]; then
        snapshots_path="${dest}/snapshots-by-time";
        dir::should_exists --mode 0700 "${snapshots_path}" || softfail || return $?;
        touch "${snapshots_path}/.safe-to-cleanup" || softfail || return $?;
    fi
}
softfail () 
{ 
    fail --wrapped-softfail "$@"
}
ssh::add_host_to_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    local known_hosts="${HOME}/.ssh/known_hosts";
    if ! command -v ssh-keygen > /dev/null; then
        softfail "ssh-keygen not found" || return $?;
    fi;
    if [ ! -f "${known_hosts}" ]; then
        dir::should_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
        ( umask 0177 && touch "${known_hosts}" ) || softfail || return $?;
    fi;
    if [ "${ssh_port}" = "22" ]; then
        local keygen_host_string="${host_name}";
    else
        local keygen_host_string="[${host_name}]:${ssh_port}";
    fi;
    if ! ssh-keygen -F "${keygen_host_string}" > /dev/null; then
        ssh-keyscan -p "${ssh_port}" -T 30 "${host_name}" >> "${known_hosts}" || softfail "Unable to add host ${host_name}:${ssh_port} to ssh known_hosts" || return $?;
    fi
}
ssh::add_ssh_config_d_include_directive () 
{ 
    dir::should_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    dir::should_exists --mode 0700 "${HOME}/.ssh/ssh_config.d" || softfail "Unable to create ssh user config.d directory" || return $?;
    file::write_block --mode 0600 "${HOME}/.ssh/config" "include-files-from-ssh-config-d" <<SHELL || 
Host *
Include ~/.ssh/ssh_config.d/*.conf
SHELL
 softfail "Unable to add configuration to user ssh config" || return $?
}
ssh::call () 
{ 
    local Ssh_Args=();
    local internal_args=();
    local keep_temp_files=false;
    local terminal_mode=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --root)
                local REMOTE_USER=root;
                shift
            ;;
            --user | -l)
                local REMOTE_USER="$2";
                shift;
                shift
            ;;
            -[46AaCfGgKkMNnqsTtVvXxYy]*)
                Ssh_Args+=("$1");
                shift
            ;;
            -[BbcDEeFIiJLmOopQRSWw])
                Ssh_Args+=("$1" "$2");
                shift;
                shift
            ;;
            --keep-temp-files)
                internal_args+=("$1");
                keep_temp_files=true;
                shift
            ;;
            --terminal)
                internal_args+=("$1");
                terminal_mode=true;
                shift
            ;;
            --*)
                internal_args+=("$1");
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ "${keep_temp_files}" = false ] && [ "${REMOTE_KEEP_TEMP_FILES:-}" = true ]; then
        internal_args+=(--keep-temp-files);
        keep_temp_files=true;
    fi;
    ssh::call::set_ssh_args || softfail "Unable to set ssh args" || return $?;
    local temp_dir;
    temp_dir="$(mktemp -d)" || softfail "Unable to make temp file" || return $?;
    ssh::call::internal --temp-dir "${temp_dir}" "${internal_args[@]}" "$@";
    local exit_status=$?;
    if [ "${keep_temp_files}" != true ]; then
        local remove_list=("${temp_dir}/stdin" "${temp_dir}/stdout" "${temp_dir}/stderr");
        if [ "${exit_status}" = 0 ] || [ "${terminal_mode}" = true ]; then
            remove_list+=("${temp_dir}/script" "${temp_dir}");
        else
            echo "Script is kept due to abnormal termination: ${temp_dir}/script" 1>&2;
        fi;
        rm -fd "${remove_list[@]}" || softfail "Unable to remote temp files";
    fi;
    return "${exit_status}"
}
ssh::call::function_sources () 
{ 
    declare -f ssh::call || softfail || return $?;
    declare -f ssh::call::internal || softfail || return $?;
    declare -f ssh::call::set_ssh_args || softfail || return $?;
    declare -f ssh::call::produce_script || softfail || return $?;
    declare -f ssh::call::interactive_terminal_functions_filter || softfail || return $?;
    declare -f ssh::call::invoke || softfail || return $?
}
ssh::call::interactive_terminal_functions_filter () 
{ 
    local function_name="$1";
    [ "${function_name:0:1}" = "_" ] || [[ "${function_name}" =~ ^(asdf|command_not_found_handle|dequote|quote|quote_readline)$ ]]
}
ssh::call::internal () 
{ 
    local produce_script_args=();
    local direct_mode=false;
    local terminal_mode=false;
    local keep_temp_files=false;
    local absorb_file;
    local temp_dir;
    local upload_path;
    local ssh_destination;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --absorb)
                absorb_file="$2";
                shift;
                shift
            ;;
            --command | --cmd)
                produce_script_args+=(--command);
                shift
            ;;
            --home)
                produce_script_args+=(--home);
                shift
            ;;
            --direct)
                direct_mode=true;
                shift
            ;;
            --terminal)
                produce_script_args+=(--terminal);
                terminal_mode=true;
                shift
            ;;
            --keep-temp-files)
                keep_temp_files=true;
                shift
            ;;
            --temp-dir)
                temp_dir="$2";
                shift;
                shift
            ;;
            --upload)
                upload_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -n "${REMOTE_HOST:-}" ]; then
        ssh_destination="${REMOTE_HOST}";
    else
        ssh_destination="$1";
        shift;
    fi;
    local resolved_upload_path;
    local rsync_ssh_args_string;
    local upload_remote_temp;
    local upload_rsync_dest;
    local upload_rsync_src;
    local upload_basename;
    if [ -n "${upload_path:-}" ]; then
        if [ -d "${upload_path}" ]; then
            resolved_upload_path="$(cd "${upload_path}" > /dev/null 2>&1 && pwd)" || softfail "Unable to resolve upload directory: ${upload_path}" || return $?;
            upload_basename="$(basename "${resolved_upload_path}")" || softfail || return $?;
            if [ "${upload_basename}" = "/" ]; then
                upload_basename=root;
            fi;
            upload_rsync_src="${resolved_upload_path}/";
        else
            upload_basename="$(basename "${upload_path}")" || softfail || return $?;
            upload_rsync_src="${upload_path}";
        fi;
        upload_remote_temp="$(ssh "${Ssh_Args[@]}" "${ssh_destination}" "mktemp -d")" || softfail --exit-status $? "Unable to create remote temp directory for file upload" || return $?;
        upload_rsync_dest="${upload_remote_temp}/${upload_basename}";
        local ssh_args_item;
        for ssh_args_item in "${Ssh_Args[@]}";
        do
            rsync_ssh_args_string+=" '$(sed -E "s/'/''/" <<< "${ssh_args_item}")'" || softfail || return $?;
        done;
        rsync --rsh "ssh ${rsync_ssh_args_string:1}" --checksum --links --perms --recursive --safe-links --times "${upload_rsync_src}" "${ssh_destination}:${upload_rsync_dest}" || softfail || return $?;
        set -- "$@" "${upload_rsync_dest}";
    fi;
    local script_checksum;
    ssh::call::produce_script "${produce_script_args[@]}" "$@" > "${temp_dir}/script" || softfail "Unable to produce script" || return $?;
    script_checksum="$(cksum < "${temp_dir}/script")" || softfail "Unable to calculate script checksum" || return $?;
    local script_upload_command;
    printf -v script_upload_command 'temp_dir="$(mktemp -d)" && cat>"${temp_dir}/script" && { if [ "$(cksum <"${temp_dir}/script")" != %q ]; then exit 254; fi; } && echo "${temp_dir}"' "${script_checksum}" || softfail || return $?;
    local remote_temp_dir;
    remote_temp_dir="$(ssh "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "${script_upload_command}")" < "${temp_dir}/script")" || softfail --exit-status $? "Unable to upload script" || return $?;
    if [ -z "${remote_temp_dir}" ]; then
        softfail "Unable to get remote temp file name" || return $?;
    fi;
    if [ "${terminal_mode}" = true ]; then
        ssh::call::invoke --terminal "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script"';
        local task_status=$?;
    else
        if [ "${direct_mode}" = true ]; then
            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script"';
            local task_status=$?;
        else
            local remote_stdin_file="/dev/null";
            if [ ! -t 0 ] || [ -n "${absorb_file:-}" ]; then
                if [ -n "${absorb_file:-}" ]; then
                    mv "${absorb_file}" "${temp_dir}/stdin" || softfail "Unable to absorb file: ${absorb_file}" || return $?;
                else
                    cat > "${temp_dir}/stdin" || softfail "Unable to read stdin" || return $?;
                fi;
                if [ -s "${temp_dir}/stdin" ]; then
                    local stdin_checksum;
                    stdin_checksum="$(cksum < "${temp_dir}/stdin")" || softfail "Unable to get stdin checksum" || return $?;
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat >"${temp_dir}/stdin"; if [ "$(cksum <"${temp_dir}/stdin")" != %q ]; then exit 254; fi' "${stdin_checksum}" < "${temp_dir}/stdin" || softfail --exit-status $? "Unable to store stdin data on remote" || return $?;
                    remote_stdin_file="${remote_temp_dir}/stdin";
                fi;
            fi;
            ssh::call::invoke --nohup "${remote_temp_dir}" "${ssh_destination}" 'bash "${temp_dir}/script" <%q >"${temp_dir}/stdout" 2>"${temp_dir}/stderr"; script_status=$?; echo "${script_status}" >"${temp_dir}/exit_status"; touch "${temp_dir}/done"; exit "${script_status}"' "${remote_stdin_file}";
            local task_status=$?;
            local task_status_retrieved=false;
            local stdout_retrieved=false;
            local stderr_retrieved=false;
            local call_result;
            if [ "${task_status}" != 255 ]; then
                task_status_retrieved=true;
            fi;
            local started_at="${SECONDS}";
            local retry_limit="${REMOTE_RECONNECT_TIME_LIMIT:-600}";
            local first_run=true;
            while true; do
                if [ "${first_run}" = true ]; then
                    first_run=false;
                else
                    sleep "${REMOTE_RECONNECT_DELAY:-5}";
                    if [ "$(( SECONDS - started_at ))" -ge "${retry_limit}" ]; then
                        softfail "Unable to obtain task result, maximum time limit reached";
                        return 1;
                    fi;
                    log::notice "Attempting to obtain result ($(( retry_limit - (SECONDS - started_at) )) second(s) till timeout)...";
                fi;
                if [ "${task_status_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -f "${temp_dir}/done"';
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -d "${temp_dir}"';
                            call_result=$?;
                            if [ "${call_result}" != 0 ] && [ "${call_result}" != 255 ]; then
                                softfail "Unable to find remote task state directory, remote host may have been rebooted";
                                return 1;
                            fi;
                            ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'test -f "${temp_dir}/stdout"';
                            call_result=$?;
                            if [ "${call_result}" != 0 ] && [ "${call_result}" != 255 ]; then
                                softfail "It seems that the remote command did not even start";
                                return 1;
                            fi;
                            continue;
                        fi;
                    fi;
                    task_status="$(ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/exit_status"')";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain exit status from remote";
                            return 1;
                        fi;
                    fi;
                    if ! [[ "${task_status}" =~ ^[0-9]+$ ]]; then
                        task_status=1;
                    fi;
                    task_status_retrieved=true;
                fi;
                if [ "${stdout_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/stdout"' > "${temp_dir}/stdout";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain stdout from remote";
                            return 1;
                        fi;
                    fi;
                    stdout_retrieved=true;
                fi;
                if [ "${stderr_retrieved}" = false ]; then
                    ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'cat "${temp_dir}/stderr"' > "${temp_dir}/stderr";
                    call_result=$?;
                    if [ "${call_result}" = 255 ]; then
                        continue;
                    else
                        if [ "${call_result}" != 0 ]; then
                            softfail "Unable to obtain stderr from remote";
                            return 1;
                        fi;
                    fi;
                    stderr_retrieved=true;
                fi;
                local remote_checksum;
                local local_checksum;
                remote_checksum="$(ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" '{ cat "${temp_dir}/stdout" "${temp_dir}/stderr" && touch "${temp_dir}/output_concat_good"; } | cksum && test -f "${temp_dir}/output_concat_good"')";
                call_result=$?;
                if [ "${call_result}" = 255 ]; then
                    continue;
                else
                    if [ "${call_result}" != 0 ]; then
                        softfail "Unable to obtain checksums from remote";
                        return 1;
                    fi;
                fi;
                local_checksum="$(cat "${temp_dir}/stdout" "${temp_dir}/stderr" | cksum; test "${PIPESTATUS[*]}" = "0 0")" || softfail "Unable to get local output checksum" || return $?;
                if [ "${remote_checksum}" != "${local_checksum}" ]; then
                    softfail "Output checksum mismatch";
                    return 1;
                fi;
                break;
            done;
            local error_state=false;
            if [ -s "${temp_dir}/stdout" ]; then
                cat "${temp_dir}/stdout" || { 
                    echo "Unable to display task stdout ($?)" 1>&2;
                    error_state=true
                };
            fi;
            if [ -s "${temp_dir}/stderr" ]; then
                if test -t 2; then
                    local error_color;
                    error_color="$(printf "setaf 9\nbold" | tput -S 2> /dev/null)" || error_color="";
                    local reset_attrs;
                    reset_attrs="$(tput sgr 0 2> /dev/null)" || reset_attrs="";
                    local error_line;
                    while IFS="" read -r error_line; do
                        echo "${error_color}${error_line}${reset_attrs}" 1>&2;
                    done < "${temp_dir}/stderr" || { 
                        echo "Unable to display task stderr ($?)" 1>&2;
                        error_state=true
                    };
                else
                    cat "${temp_dir}/stderr" 1>&2 || { 
                        echo "Unable to display task stderr ($?)" 1>&2;
                        error_state=true
                    };
                fi;
            fi;
            if [ "${error_state}" = true ]; then
                softfail "Error reading STDOUT/STDERR in ssh::call";
                return 1;
            fi;
        fi;
    fi;
    if [ "${keep_temp_files}" != true ]; then
        ssh::call::invoke "${remote_temp_dir}" "${ssh_destination}" 'rm -fd "${temp_dir}/script" "${temp_dir}/stdin" "${temp_dir}/stdout" "${temp_dir}/stderr" "${temp_dir}/output_concat_good" "${temp_dir}/exit_status" "${temp_dir}/done" "${temp_dir}"';
        softfail --unless-good --exit-status $? "Unable to remove remote temp files";
        if [ -n "${upload_remote_temp:-}" ]; then
            ssh "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "$(printf "rm -rf %q" "${upload_remote_temp}")")";
            softfail --unless-good --exit-status $? "Unable to remove remote temp directory for file upload";
        fi;
    fi;
    return "${task_status}"
}
ssh::call::invoke () 
{ 
    local nohup_mode=false;
    local terminal_mode;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --nohup)
                nohup_mode=true;
                shift
            ;;
            --terminal)
                terminal_mode=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local remote_temp_dir="$1";
    shift;
    local ssh_destination="$1";
    shift;
    local command_string="$1";
    shift;
    command_string="$(printf "temp_dir=%q; ${command_string}" "${remote_temp_dir}" "$@")";
    if [ "${nohup_mode}" = true ]; then
        command_string="$(printf "nohup sh -c %q >/dev/null 2>/dev/null </dev/null" "${command_string}")";
    fi;
    ssh ${terminal_mode:+"-t"} "${Ssh_Args[@]}" "${ssh_destination}" "$(printf "sh -c %q" "${command_string}")"
}
ssh::call::produce_script () 
{ 
    local command_mode=false;
    local terminal_mode=false;
    local cd_to_home=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            --command)
                command_mode=true;
                shift
            ;;
            --home)
                cd_to_home=true;
                shift
            ;;
            --terminal)
                terminal_mode=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local joined_command="$*";
    if [ -n "${joined_command//[[:blank:][:cntrl:]]/}" ]; then
        local command_present=true;
    else
        local command_present=false;
    fi;
    if [ "${command_present}" = false ] && [ "${terminal_mode}" = false ]; then
        softfail "Command should be specified (note that ssh::call may ate your first argument as a host name if REMOTE_HOST is not provided)";
        return $?;
    fi;
    if [ "${RUNAG_VERBOSE:-}" = true ]; then
        echo PS4=\'+\$\{BASH_SUBSHELL\}\ \$\{BASH_SOURCE:+\"\$\{BASH_SOURCE\}:\$\{LINENO\}:\ \"\}\$\{FUNCNAME\[0\]:+\"in\ \\\`\$\{FUNCNAME\[0\]\}\'\"\'\"\'\ \"\}\*\*\ \';
        echo "set -o xtrace";
    else
        if shopt -o -q xtrace; then
            echo "set -o xtrace";
        fi;
    fi;
    if shopt -o -q nounset; then
        echo "set -o nounset";
    fi;
    local env_list=();
    if declare -p REMOTE_ENV 2> /dev/null | grep -q '^declare -a'; then
        env_list+=("${REMOTE_ENV[@]}");
    else
        if [ -n "${REMOTE_ENV:-}" ]; then
            IFS=" " read -r -a env_list <<< "${REMOTE_ENV}" || softfail || return $?;
        fi;
    fi;
    env_list+=(RUNAG_VERBOSE);
    local env_list_item;
    for env_list_item in "${env_list[@]}";
    do
        if [ -n "${!env_list_item:-}" ]; then
            echo "export $(printf "%q=%q" "${env_list_item}" "${!env_list_item}")";
        fi;
    done;
    local remote_rc_string;
    local remote_rc_require_functions=false;
    if declare -p REMOTE_RC 2> /dev/null | grep -q '^declare -a'; then
        if [ "${#REMOTE_RC[@]}" -gt 0 ]; then
            if declare -F "${REMOTE_RC[0]}" > /dev/null; then
                remote_rc_require_functions=true;
            fi;
            printf -v remote_rc_string " %q" "${REMOTE_RC[@]}" || softfail || return $?;
            remote_rc_string="${remote_rc_string:1}" || softfail || return $?;
        fi;
    else
        if [ -n "${REMOTE_RC:-}" ]; then
            remote_rc_require_functions=true;
            remote_rc_string="${REMOTE_RC}";
        fi;
    fi;
    if [ "${remote_rc_require_functions}" = true ] || { 
        [ "${command_mode}" = false ] && [ "${command_present}" = true ] && declare -F "$1" > /dev/null
    }; then
        if [ -z "${PS1:-}" ]; then
            declare -f || softfail "Unable to produce source code dump of functions" || return $?;
        else
            local function_name;
            declare -F | while IFS="" read -r function_name; do
                if ! ssh::call::interactive_terminal_functions_filter "${function_name:11}"; then
                    declare -f "${function_name:11}" || softfail "Unable to produce source code dump of function: ${function_name:11}" || return $?;
                fi;
            done;
        fi;
    fi;
    if [ "${cd_to_home}" = true ]; then
        echo 'cd "${HOME}" || exit $?';
    fi;
    if [ -n "${REMOTE_DIR:-}" ]; then
        printf "cd %q || exit \$?\n" "${REMOTE_DIR}";
    fi;
    if [ -n "${REMOTE_NON_ROOT_UMASK:-}" ]; then
        printf "if [ \"\${EUID}\" != 0 ]; then umask %q || exit \$?; fi\n" "${REMOTE_NON_ROOT_UMASK}";
    fi;
    if [ -n "${REMOTE_UMASK:-}" ]; then
        printf "umask %q || exit \$?\n" "${REMOTE_UMASK}";
    fi;
    if [ -n "${remote_rc_string:-}" ]; then
        printf "{\n%s\n} || { exit_status=\$?; echo 'Error performing REMOTE_RC line' >&2; exit \$?; }\n" "${remote_rc_string}" || softfail || return $?;
    fi;
    if [ "${command_present}" = false ] && [ "${terminal_mode}" = true ]; then
        echo '"${SHELL}"';
    else
        local command_string;
        printf -v command_string " %q" "$@" || softfail || return $?;
        echo "${command_string:1}";
    fi
}
ssh::call::set_ssh_args () 
{ 
    dir::should_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create directory: ${HOME}/.ssh" || return $?;
    dir::should_exists --mode 0700 "${HOME}/.ssh/control-sockets" || softfail "Unable to create directory: ${HOME}/.ssh/control-sockets" || return $?;
    if ! [[ "${OSTYPE}" =~ ^msys ]] && [ "${REMOTE_CONTROL_MASTER:-}" != "no" ]; then
        Ssh_Args+=("-o" "ControlMaster=${REMOTE_CONTROL_MASTER:-"auto"}");
        if [ "${REMOTE_FORWARD_AGENT:-}" = true ]; then
            Ssh_Args+=("-S" "${REMOTE_CONTROL_PATH:-"${HOME}/.ssh/control-sockets/%C.with-forward-agent"}");
        else
            Ssh_Args+=("-S" "${REMOTE_CONTROL_PATH:-"${HOME}/.ssh/control-sockets/%C"}");
        fi;
        Ssh_Args+=("-o" "ControlPersist=${REMOTE_CONTROL_PERSIST:-"600"}");
    fi;
    if [ "${REMOTE_FORWARD_AGENT:-}" = true ]; then
        Ssh_Args+=("-o" "ForwardAgent=yes");
    fi;
    if [ -n "${REMOTE_IDENTITY_FILE:-}" ]; then
        Ssh_Args+=("-i" "${REMOTE_IDENTITY_FILE}");
    fi;
    if [ -n "${REMOTE_PORT:-}" ]; then
        Ssh_Args+=("-p" "${REMOTE_PORT}");
    fi;
    if [ "${REMOTE_SERVER_ALIVE_INTERVAL:-}" != "no" ]; then
        Ssh_Args+=("-o" "ServerAliveInterval=${REMOTE_SERVER_ALIVE_INTERVAL:-"20"}");
    fi;
    if [ -n "${REMOTE_USER:-}" ]; then
        Ssh_Args+=("-l" "${REMOTE_USER}");
    fi;
    if declare -p REMOTE_SSH_ARGS 2> /dev/null | grep -q '^declare -a'; then
        Ssh_Args+=("${REMOTE_SSH_ARGS[@]}");
    else
        if [ -n "${REMOTE_SSH_ARGS:-}" ]; then
            local remote_ssh_args_array;
            IFS=" " read -a remote_ssh_args_array <<< "${REMOTE_SSH_ARGS}" || softfail || return $?;
            Ssh_Args+=("${remote_ssh_args_array[@]}");
        fi;
    fi
}
ssh::gnome_keyring_credentials () 
{ 
    local key_file_path="$1";
    local password="$2";
    echo -n "${password}" | secret-tool store --label="Unlock password for: ${key_file_path}" unique "ssh-store:${key_file_path}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?
}
ssh::gnome_keyring_credentials::exists () 
{ 
    local key_file_path="$1";
    secret-tool lookup unique "ssh-store:${key_file_path}" > /dev/null
}
ssh::install_authorized_keys_from_pass () 
{ 
    local profile_name;
    local file_owner;
    local file_group;
    local perhaps_sudo;
    local ssh_call=false;
    local ssh_call_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --profile-name)
                profile_name="$2";
                shift;
                shift
            ;;
            -o | --owner)
                file_owner="$2";
                shift;
                shift
            ;;
            -g | --group)
                file_group="$2";
                shift;
                shift
            ;;
            -s | --sudo)
                perhaps_sudo=true;
                shift
            ;;
            -c | --ssh-call)
                ssh_call=true;
                ssh_call_command+=(ssh::call);
                shift
            ;;
            -*)
                fail "Unknown argument: $1"
            ;;
            *)
                break
            ;;
        esac;
    done;
    local profile_path="$1";
    if [ -z "${profile_name:-}" ]; then
        profile_name="$(basename "${profile_path}")" || softfail || return $?;
    fi;
    local home_dir;
    if [ -n "${file_owner:-}" ]; then
        home_dir="$("${ssh_call_command[@]}" linux::get_home_dir "${file_owner}")" || softfail || return $?;
    else
        if [ "${ssh_call}" != true ]; then
            home_dir="${HOME}";
        fi;
    fi;
    "${ssh_call_command[@]}" dir::should_exists ${perhaps_sudo:+"--sudo"} --mode 0700 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} "${home_dir:+"${home_dir}/"}.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    if pass::secret_exists "${profile_path}/id_ed25519.pub"; then
        pass::use --absorb-in-callback "${profile_path}/id_ed25519.pub" "${ssh_call_command[@]}" file::write_block ${perhaps_sudo:+"--sudo"} --mode 0600 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} "${home_dir:+"${home_dir}/"}.ssh/authorized_keys" "${profile_name}-id_ed25519.pub" || softfail || return $?;
    fi;
    if pass::secret_exists "${profile_path}/authorized_keys"; then
        pass::use --absorb-in-callback --body "${profile_path}/authorized_keys" "${ssh_call_command[@]}" file::write_block ${perhaps_sudo:+"--sudo"} --mode 0600 ${file_owner:+"--owner" "${file_owner}"} ${file_group:+"--group" "${file_group}"} "${home_dir:+"${home_dir}/"}.ssh/authorized_keys" "${profile_name}-authorized_keys" || softfail || return $?;
    fi
}
ssh::install_ssh_key_from_pass () 
{ 
    local secret_path="$1";
    local key_file_path;
    key_file_path="${2:-"${HOME}/.ssh/$(basename "${secret_path}")"}" || softfail || return $?;
    dir::should_exists --mode 0700 "${HOME}/.ssh" || softfail "Unable to create ssh user config directory" || return $?;
    pass::use --absorb-in-callback --body "${secret_path}" file::write --mode 0600 "${key_file_path}" || softfail || return $?;
    if pass::secret_exists "${secret_path}.pub"; then
        pass::use "${secret_path}.pub" file::write --mode 0600 "${key_file_path}.pub" || softfail || return $?;
    fi;
    if [[ "${OSTYPE}" =~ ^linux ]]; then
        pass::use --skip-if-empty "${secret_path}" ssh::gnome_keyring_credentials "${key_file_path}" || softfail || return $?;
    else
        if [[ "${OSTYPE}" =~ ^darwin ]]; then
            pass::use --skip-if-empty "${secret_path}" ssh::macos_keychain "${key_file_path}" || softfail || return $?;
        fi;
    fi
}
ssh::install_ssh_key_from_pass_to_remote () 
{ 
    local pass_args=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -*)
                pass_args+=("$1");
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    local secret_path="$1";
    local key_file_path;
    key_file_path="${2:-".ssh/$(basename "${secret_path}")"}" || softfail || return $?;
    ssh::call --home dir::should_exists --mode 0700 ".ssh" || softfail "Unable to create ssh user config directory" || return $?;
    pass::use "${pass_args[@]}" --absorb-in-callback --body "${secret_path}" ssh::call --home file::write --mode 0600 "${key_file_path}" || softfail || return $?;
    if pass::secret_exists "${secret_path}.pub"; then
        pass::use "${pass_args[@]}" "${secret_path}.pub" ssh::call --home file::write --mode 0600 "${key_file_path}.pub" || softfail || return $?;
    fi
}
ssh::install_ssh_profile_from_pass () 
{ 
    local profile_name;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --profile-name)
                profile_name="$2";
                shift;
                shift
            ;;
            -*)
                fail "Unknown argument: $1"
            ;;
            *)
                break
            ;;
        esac;
    done;
    local profile_path="$1";
    if pass::secret_exists "${profile_path}/id_ed25519"; then
        ssh::install_ssh_key_from_pass "${profile_path}/id_ed25519" "${HOME}/.ssh/${profile_name}.id_ed25519" || softfail || return $?;
    fi;
    local config_file_path="${HOME}/.ssh/ssh_config.d/${profile_name}.conf";
    if [[ "${OSTYPE}" =~ ^linux ]] && pass::secret_exists "${profile_path}/config.linux"; then
        ssh::install_ssh_profile_from_pass::write_config "${profile_path}" "${profile_name}" "${config_file_path}" "${profile_path}/config.linux" || softfail || return $?;
    else
        if pass::secret_exists "${profile_path}/config"; then
            ssh::install_ssh_profile_from_pass::write_config "${profile_path}" "${profile_name}" "${config_file_path}" "${profile_path}/config" || softfail || return $?;
        else
            if pass::secret_exists "${profile_path}/id_ed25519"; then
                file::write --mode 0600 "${config_file_path}" <<< "IdentityFile ${HOME}/.ssh/${profile_name}.id_ed25519" || softfail || return $?;
            fi;
        fi;
    fi;
    if pass::secret_exists "${profile_path}/known_hosts"; then
        pass::use --absorb-in-callback --body "${profile_path}/known_hosts" file::write_block --mode 0600 "${HOME}/.ssh/known_hosts" "${profile_name}" || softfail || return $?;
    fi
}
ssh::install_ssh_profile_from_pass::write_config () 
{ 
    local profile_path="$1";
    local profile_name="$2";
    local config_file_path="$3";
    local pass_config_path="$4";
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    pass::use --absorb-in-callback --body "${pass_config_path}" file::write --mode 0600 "${temp_file}" || softfail || return $?;
    if pass::secret_exists "${profile_path}/id_ed25519"; then
        sed --in-place -E "s#IdentityFile %k#IdentityFile ${HOME}/.ssh/${profile_name}.id_ed25519#g" "${temp_file}" || softfail || return $?;
    fi;
    file::write --absorb "${temp_file}" --mode 0600 "${config_file_path}" || softfail || return $?
}
ssh::macos_keychain () 
{ 
    local key_file_path="$1";
    local password="$2";
    local temp_file;
    temp_file="$(mktemp)" || softfail || return $?;
    chmod 755 "${temp_file}" || softfail || return $?;
    printf "#!/bin/sh\nexec cat\n" > "${temp_file}" || softfail || return $?;
    echo "${password}" | SSH_ASKPASS="${temp_file}" DISPLAY=1 ssh-add -K "${key_file_path}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail || return $?;
    rm "${temp_file}" || softfail || return $?
}
ssh::macos_keychain::configure_use_on_all_hosts () 
{ 
    local ssh_config_file="${HOME}/.ssh/config";
    if [ ! -f "${ssh_config_file}" ]; then
        ( umask 0177 && touch "${ssh_config_file}" ) || softfail || return $?;
    fi;
    if ! grep -q "^# Use keychain" "${ssh_config_file}"; then
        tee -a "${ssh_config_file}" <<EOF || 

# Use keychain
Host *
  UseKeychain yes
  AddKeysToAgent yes
EOF
 softfail "Unable to append to the file: ${ssh_config_file}" || return $?;
    fi
}
ssh::macos_keychain::exists () 
{ 
    local key_file_path="$1";
    ssh-add -L | grep -qF "${key_file_path}"
}
ssh::refresh_host_in_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    ssh::remove_host_from_known_hosts --port "${ssh_port}" "${host_name}" || softfail || return $?;
    ssh::wait_for_host_to_become_available --port "${ssh_port}" "${host_name}" || softfail || return $?;
    ssh::add_host_to_known_hosts --port "${ssh_port}" "${host_name}" || softfail || return $?
}
ssh::remove_host_from_known_hosts () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    if [ "${ssh_port}" = "22" ]; then
        local keygen_host_string="${host_name}";
    else
        local keygen_host_string="[${host_name}]:${ssh_port}";
    fi;
    ssh-keygen -R "${keygen_host_string}" || softfail || return $?
}
ssh::wait_for_host_to_become_available () 
{ 
    local ssh_port="${REMOTE_PORT:-"22"}";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --port)
                ssh_port="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local host_name="${1:-"${REMOTE_HOST}"}";
    while true; do
        local key;
        key="$(ssh-keyscan -p "${ssh_port}" "${host_name}" 2> /dev/null)";
        if [ -n "${key}" ]; then
            return 0;
        else
            if [ -t 2 ]; then
                echo "Waiting for SSH to become available on host '${host_name}'..." 1>&2;
            fi;
            sleep 1 || softfail || return $?;
        fi;
    done
}
sshd::disable_password_authentication () 
{ 
    dir::should_exists --sudo --mode 0755 /etc/ssh || softfail || return $?;
    dir::should_exists --sudo --mode 0755 /etc/ssh/sshd_config.d || softfail || return $?;
    file::write --sudo --mode 0644 /etc/ssh/sshd_config.d/disable-password-authentication.conf <<SHELL || 
PasswordAuthentication no
AuthenticationMethods publickey
SHELL
 softfail || return $?
}
sublime_merge::get_config_path () 
{ 
    local config_path;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        config_path="${HOME}/Library/Application Support/Sublime Merge";
    else
        if [[ "${OSTYPE}" =~ ^msys ]]; then
            config_path="${APPDATA}/Sublime Merge";
        else
            dir::should_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
            config_path="${HOME}/.config/sublime-merge";
        fi;
    fi;
    dir::should_exists --mode 0700 "${config_path}" || softfail || return $?;
    echo "${config_path}"
}
sublime_merge::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "sublimetext" "https://download.sublimetext.com/ apt/stable/" "https://download.sublimetext.com/sublimehq-pub.gpg" || softfail || return $?;
        apt::install sublime-merge || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            true;
        fi;
    fi )
}
sublime_merge::install_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_merge::get_config_path)" || softfail || return $?;
    dir::should_exists --mode 0700 "${config_path}/Packages" || softfail || return $?;
    dir::should_exists --mode 0700 "${config_path}/Packages/User" || softfail || return $?;
    config::install "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_merge::merge_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_merge::get_config_path)" || softfail || return $?;
    config::merge "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_text::get_config_path () 
{ 
    local config_path;
    if [[ "${OSTYPE}" =~ ^darwin ]]; then
        config_path="${HOME}/Library/Application Support/Sublime Text 3";
    else
        if [[ "${OSTYPE}" =~ ^msys ]]; then
            config_path="${APPDATA}/Sublime Text 3";
        else
            dir::should_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
            config_path="${HOME}/.config/sublime-text-3";
        fi;
    fi;
    dir::should_exists --mode 0700 "${config_path}" || softfail || return $?;
    echo "${config_path}"
}
sublime_text::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "sublimetext" "https://download.sublimetext.com/ apt/stable/" "https://download.sublimetext.com/sublimehq-pub.gpg" || softfail || return $?;
        apt::install sublime-text || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            true;
        fi;
    fi )
}
sublime_text::install_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    dir::should_exists --mode 0700 "${config_path}/Packages" || softfail || return $?;
    dir::should_exists --mode 0700 "${config_path}/Packages/User" || softfail || return $?;
    config::install "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
sublime_text::install_package_control () 
{ 
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    local installed_packages="${config_path}/Installed Packages";
    local package_control_package="${installed_packages}/Package Control.sublime-package";
    if [ ! -f "${package_control_package}" ]; then
        dir::should_exists --mode 0700 "${installed_packages}" || softfail || return $?;
        local url="https://packagecontrol.io/Package%20Control.sublime-package";
        curl --fail --silent --show-error "${url}" --output "${package_control_package}.download_temp" || softfail "Unable to download ${url} ($?)" || return $?;
        mv "${package_control_package}.download_temp" "${package_control_package}" || softfail || return $?;
    fi
}
sublime_text::merge_config_file () 
{ 
    local src_path="$1";
    local file_name;
    file_name="$(basename "${src_path}")" || softfail || return $?;
    local config_path;
    config_path="$(sublime_text::get_config_path)" || softfail || return $?;
    config::merge "${src_path}" "${config_path}/Packages/User/${file_name}" || softfail || return $?
}
syncthing::install () 
{ 
    ( . /etc/os-release || softfail || return $?;
    if [ "${ID:-}" = debian ] || [ "${ID_LIKE:-}" = debian ]; then
        apt::add_source_with_key "syncthing" "https://apt.syncthing.net/ syncthing stable" "https://syncthing.net/release-key.txt" || softfail "Unable to add syncthing apt source" || return $?;
        apt::install syncthing || softfail || return $?;
    else
        if [ "${ID:-}" = arch ]; then
            sudo pacman --sync --needed --noconfirm syncthing || softfail || return $?;
        fi;
    fi;
    systemctl --user --quiet --now enable syncthing.service || softfail || return $? )
}
syncthing::install::macos () 
{ 
    brew install syncthing || softfail || return $?;
    brew services start syncthing || softfail || return $?
}
syncthing::open () 
{ 
    xdg-open "http://127.0.0.1:8384" || softfail || return $?
}
systemd::block () 
{ 
    local block_name="$1";
    shift;
    local block_content;
    printf -v block_content "\n${block_name}=%s" "$@" || softfail || return $?;
    echo "${block_content:1}"
}
systemd::export_shell_function_as_command () 
{ 
    local command;
    command="$(declare -f "$1" | tail -n +3 | head -n -1 | sed -E "s/^\s*//"; test "${PIPESTATUS[*]}" = "0 0 0 0")" || softfail || return $?;
    echo "/usr/bin/bash -c '${command//\'/\\\'}'"
}
systemd::service_action () 
{ 
    local action_args=();
    local user_services=false;
    local ssh_call=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                action_args+=("$1" "$2");
                shift;
                shift
            ;;
            -u | --user)
                action_args+=("$1");
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                action_args+=("$1");
                shift
            ;;
            -c | --ssh-call)
                ssh_call=true;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    local action="$1";
    shift;
    local ssh_call_command=();
    if [ "${ssh_call}" = true ]; then
        ssh_call_command+=(ssh::call);
        if [ "${user_services}" != true ]; then
            ssh_call_command+=(--root);
        else
            if [ "${action}" = "journal" ]; then
                local release_codename;
                release_codename="$("${ssh_call_command[@]}" lsb_release --codename --short)" || softfail || return $?;
                if [ "${release_codename}" = "focal" ]; then
                    ssh_call_command+=(--root);
                fi;
            fi;
        fi;
        if [ "${action}" = "journal" ] && [ "${1:-}" = "--follow" ]; then
            ssh_call_command+=(--direct);
        fi;
    fi;
    "${ssh_call_command[@]}" "systemd::service_action::${action}" "${action_args[@]}" "$@" || softfail || return $?
}
systemd::service_action::disable_timer () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    "${systemctl_command[@]}" stop "${service_name}.timer" || softfail || return $?;
    "${systemctl_command[@]}" --quiet disable "${service_name}.timer" || softfail || return $?
}
systemd::service_action::enable_timer () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    "${systemctl_command[@]}" --quiet reenable "${service_name}.timer" || softfail || return $?;
    "${systemctl_command[@]}" start "${service_name}.timer" || softfail || return $?
}
systemd::service_action::journal () 
{ 
    ( local service_name;
    local user_services=false;
    local follow_argument=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            --follow)
                follow_argument=(--follow);
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    . /etc/os-release || softfail || return $?;
    if [ "${user_services}" = true ] && [ "${VERSION_CODENAME:-}" = "focal" ]; then
        sudo journalctl "_SYSTEMD_USER_UNIT=${service_name}.service" --lines 2048 "${follow_argument[@]}" || softfail || return $?;
        return;
    fi;
    if [ "${user_services}" = true ]; then
        local journalctl_command=(journalctl --user);
    else
        local journalctl_command=(sudo journalctl);
    fi;
    "${journalctl_command[@]}" --unit "${service_name}.service" --lines 2048 "${follow_argument[@]}" || softfail || return $? )
}
systemd::service_action::start () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        systemctl --user --no-block start "${service_name}.service" || softfail || return $?;
    else
        sudo systemctl --no-block start "${service_name}.service" || softfail || return $?;
    fi
}
systemd::service_action::status () 
{ 
    local service_name;
    local user_services=false;
    local with_timer=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                with_timer=true;
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        local systemctl_command=(systemctl --user);
    else
        local systemctl_command=(sudo systemctl);
    fi;
    local exit_statuses=();
    printf "\n";
    if [ "${with_timer}" = true ]; then
        "${systemctl_command[@]}" list-timers "${service_name}.timer" --all || softfail || return $?;
        exit_statuses+=($?);
        printf "\n\n\n";
        "${systemctl_command[@]}" status "${service_name}.timer";
        exit_statuses+=($?);
        printf "\n\n\n";
    fi;
    "${systemctl_command[@]}" status "${service_name}.service";
    exit_statuses+=($?);
    printf "\n";
    if [[ "${exit_statuses[*]}" =~ [^03[:space:]] ]]; then
        softfail || return $?;
    fi
}
systemd::service_action::stop () 
{ 
    local service_name;
    local user_services=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -n | --service-name)
                service_name="$2";
                shift;
                shift
            ;;
            -u | --user)
                user_services=true;
                shift
            ;;
            -t | --with-timer)
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    if [ "${user_services}" = true ]; then
        systemctl --user stop "${service_name}.service" || softfail || return $?;
    else
        sudo systemctl stop "${service_name}.service" || softfail || return $?;
    fi
}
systemd::service_tasks () 
{ 
    local with_timer;
    local action_args=();
    local envelope_command=();
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -e | --envelope)
                envelope_command+=("$2");
                shift;
                shift
            ;;
            -t | --with-timer)
                action_args+=("$1");
                with_timer=true;
                shift
            ;;
            -n | --service-name)
                action_args+=("$1" "$2");
                shift;
                shift
            ;;
            -u | --user | -c | --ssh-call)
                action_args+=("$1");
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    task::add --header "Service actions" || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" start || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" stop || softfail || return $?;
    if [ "${with_timer:-}" = true ]; then
        task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" enable_timer || softfail || return $?;
        task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" disable_timer || softfail || return $?;
    fi;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" status || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" journal || softfail || return $?;
    task::add "${envelope_command[@]}" systemd::service_action "${action_args[@]}" journal --follow || softfail || return $?
}
systemd::write_system_unit () 
{ 
    local name="$1";
    file::write --sudo --mode 0644 "/etc/systemd/system/${name}" || softfail || return $?
}
systemd::write_user_unit () 
{ 
    local name="$1";
    local user_units_dir="${HOME}/.config/systemd/user";
    dir::should_exists --mode 0700 "${HOME}/.config" || softfail || return $?;
    dir::should_exists --mode 0700 "${HOME}/.config/systemd" || softfail || return $?;
    dir::should_exists --mode 0700 "${user_units_dir}" || softfail || return $?;
    file::write --mode 0600 "${user_units_dir}/${name}" || softfail || return $?
}
tailscale::add_apt_source () 
{ 
    ( . /etc/os-release || softfail || return $?;
    apt::add_source_with_key "tailscale" "https://pkgs.tailscale.com/stable/${ID} ${VERSION_CODENAME} main" "https://pkgs.tailscale.com/stable/${ID}/${VERSION_CODENAME}.gpg" || softfail || return $? )
}
tailscale::is_logged_in () 
{ 
    local backend_state;
    backend_state="$(tailscale status --json | jq --raw-output --exit-status .BackendState; test "${PIPESTATUS[*]}" = "0 0")" || fail "Unable to obtain tailscale status";
    if [ "${backend_state}" = "NeedsLogin" ]; then
        return 1;
    else
        return 0;
    fi
}
task::add () 
{ 
    local store_name=DEFAULT;
    local task_type="basic-task";
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --store)
                store_name="$2";
                shift;
                shift
            ;;
            -o | --os)
                if [[ ! "${OSTYPE}" =~ ^"$2" ]]; then
                    return;
                fi;
                shift;
                shift
            ;;
            -g | --group)
                task_type="task-group";
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    declare -n task_data="RUNAG_TASK_${store_name}";
    if [[ ! -v task_data ]]; then
        declare -ga "RUNAG_TASK_${store_name}=()";
    fi;
    task_data+=("${task_type}" "$#" "$@")
}
task::any () 
{ 
    local store_name=DEFAULT;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --store)
                store_name="$2";
                shift;
                shift
            ;;
            *)
                fail "Unknown argument: $1"
            ;;
        esac;
    done;
    declare -n task_data="RUNAG_TASK_${store_name}";
    [[ -v task_data ]] && (( ${#task_data[@]} > 0 ))
}
task::clear () 
{ 
    local store_name=DEFAULT;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --store)
                store_name="$2";
                shift;
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    declare -ga "RUNAG_TASK_${store_name}=()"
}
task::display () 
{ 
    local store_name=DEFAULT;
    local enable_return=false;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -s | --store)
                store_name="$2";
                shift;
                shift
            ;;
            -r | --enable-return)
                enable_return=true;
                shift
            ;;
            *)
                softfail "Unknown argument: $1" || return $?
            ;;
        esac;
    done;
    declare -n Task_Data="RUNAG_TASK_${store_name}";
    if [[ ! -v Task_Data ]]; then
        declare -ga "RUNAG_TASK_${store_name}=()";
    fi;
    if [ "${#Task_Data[@]}" = 0 ]; then
        softfail "Task list is empty";
        return $?;
    fi;
    local Prompt_Color="";
    local Color_A="";
    local Color_B="";
    local Color_A_Accent="";
    local Color_B_Accent="";
    local Header_Color="";
    local Comment_Color="";
    local Cursor_Up_Seq;
    local Reset_Attrs="";
    local Clear_Line="";
    local Leading_Spacer=" ";
    if [ -t 0 ]; then
        Prompt_Color="$(printf "setaf 11\nbold" | tput -S 2> /dev/null)" || Prompt_Color="";
    fi;
    if [ -t 1 ]; then
        Color_A="$(tput setaf 9 2> /dev/null)" || Color_A="";
        Color_A_Accent="$(printf "setaf 15\nsetab 9" | tput -S 2> /dev/null)" || Color_A_Accent="";
        Color_B_Accent="$(printf "setaf 15\nsetab 8" | tput -S 2> /dev/null)" || Color_B_Accent="";
        Header_Color="$(printf "setaf 14\nbold" | tput -S 2> /dev/null)" || Header_Color="";
        Comment_Color="$(printf "setaf 13\nbold" | tput -S 2> /dev/null)" || Comment_Color="";
        Cursor_Up_Seq="$(tput cuu1 2> /dev/null)" || softfail || return $?;
    fi;
    if [ -t 0 ] || [ -t 1 ]; then
        Reset_Attrs="$(tput sgr 0 2> /dev/null)" || softfail || return $?;
        Clear_Line="$(tput el 2> /dev/null)" || softfail || return $?;
    fi;
    local Item_Position=undefined;
    local Section_Position=undefined;
    local First_Render=true;
    local Lines_Drawn;
    local Non_Interactive=false;
    local Should_Perform_Command;
    local Should_Exit;
    local Should_Return;
    local Should_Enter;
    local Selected_Command;
    local Selected_Command_Type;
    local command_exit_status;
    if ! [ -t 0 ] || ! [ -t 1 ]; then
        Non_Interactive=true;
        Leading_Spacer="";
        task::render || softfail || return $?;
        return 0;
    fi;
    while :; do
        task::render || softfail || return $?;
        Should_Perform_Command=false;
        Should_Exit=false;
        Should_Return=false;
        Should_Enter=false;
        task::read_input || softfail || return $?;
        if [ "${enable_return}" = true ] && [ "${Should_Return}" = true ]; then
            return 254;
        else
            if [ "${Should_Exit}" = true ]; then
                return 0;
            else
                if [ "${Should_Perform_Command}" = true ] || { 
                    [ "${Should_Enter}" = true ] && [ "${Selected_Command_Type}" = "task-group" ]
                }; then
                    if [ "${Selected_Command_Type}" = "task-group" ]; then
                        printf "\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n";
                        task::group --enable-return "${Selected_Command[@]}";
                        command_exit_status=$?;
                        if [ "${command_exit_status}" = 254 ]; then
                            First_Render=true;
                            printf "\n. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n";
                            continue;
                        fi;
                    else
                        echo '
'"${Prompt_Color}> ${Selected_Command[*]}${Reset_Attrs}";
                        "${Selected_Command[@]}";
                        command_exit_status=$?;
                    fi;
                    softfail --unless-good --exit-status "${command_exit_status}" "Error performing ${Selected_Command[0]} (${command_exit_status})" || return $?;
                    return 0;
                fi;
            fi;
        fi;
    done
}
task::group () 
{ 
    ( local enable_return;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -r | --enable-return)
                enable_return=true;
                shift
            ;;
            *)
                break
            ;;
        esac;
    done;
    task::clear || softfail || return $?;
    "$@";
    softfail --unless-good --exit-status $? "Error performing $1 ($?)" || return $?;
    task::display ${enable_return:+"--enable-return"};
    local command_exit_status=$?;
    if [ "${command_exit_status}" = 254 ]; then
        return "${command_exit_status}";
    fi;
    softfail --unless-good --exit-status "${command_exit_status}" "Error performing task::display (${command_exit_status})" || return $? )
}
task::read_input () 
{ 
    local input_text;
    local read_status;
    IFS="" read -n 1 -r -s input_text || softfail "Read failed: $?" || return $?;
    if [ "${input_text}" = '' ]; then
        Should_Exit=true;
    fi;
    if [ "${input_text}" = '' ]; then
        IFS="" read -n 5 -r -s -t 0.01 input_text;
        read_status=$?;
        if [ ${read_status} -gt 128 ]; then
            if [ -z "${input_text}" ]; then
                Should_Exit=true;
            fi;
        else
            if [ ${read_status} != 0 ]; then
                softfail "Read failed: ${read_status}";
                return $?;
            fi;
        fi;
        case "${input_text}" in 
            "[5~" | "[1;5A")
                if [ "${Section_Position}" != undefined ]; then
                    Item_Position=undefined;
                    (( Section_Position -= 1 )) || true;
                fi
            ;;
            "[6~" | "[1;5B")
                if [ "${Section_Position}" != undefined ]; then
                    Item_Position=undefined;
                    (( Section_Position += 1 ));
                fi
            ;;
            "[A")
                if [ "${Item_Position}" != undefined ]; then
                    ((Item_Position-=1));
                    Section_Position=undefined;
                fi
            ;;
            "[B")
                if [ "${Item_Position}" != undefined ]; then
                    ((Item_Position+=1));
                    Section_Position=undefined;
                fi
            ;;
            "[C")
                if [ "${Item_Position}" != undefined ]; then
                    Should_Enter=true;
                fi
            ;;
            "[D")
                Should_Return=true
            ;;
            "[F")
                if [ "${Item_Position}" != undefined ]; then
                    Item_Position=-1;
                    Section_Position=undefined;
                fi
            ;;
            "[H")
                if [ "${Item_Position}" != undefined ]; then
                    Item_Position=0;
                    Section_Position=0;
                fi
            ;;
        esac;
    else
        if [ "${input_text}" = "" ]; then
            if [ "${Item_Position}" != undefined ]; then
                Should_Perform_Command=true;
            fi;
        fi;
    fi
}
task::render () 
{ 
    local main_pointer;
    local item_pointer;
    local comment;
    local is_command;
    local item_length;
    local item_type;
    local command;
    local command_display_prefix;
    local Current_Color;
    local current_color_accent;
    local Meta_Lines=();
    local meta_line_pointer;
    local selection_marker;
    local enter_marker;
    local current_item_index=undefined;
    local current_section_index=undefined;
    local current_line_color;
    if [ "${First_Render}" != true ]; then
        if [ -t 1 ]; then
            for ((1; Lines_Drawn > 0; Lines_Drawn--))
            do
                printf "%s" "${Cursor_Up_Seq}";
            done;
        fi;
    else
        First_Render=false;
    fi;
    Lines_Drawn=0;
    for ((main_pointer = 0; main_pointer < ${#Task_Data[@]}; main_pointer++ ))
    do
        if [ "${Task_Data[main_pointer]}" = "basic-task" ] || [ "${Task_Data[main_pointer]}" = "task-group" ]; then
            comment="";
            is_command=true;
            item_length="${Task_Data[main_pointer + 1]}";
            item_type="${Task_Data[main_pointer]}";
            for ((item_pointer = main_pointer + 2; item_pointer <= main_pointer + item_length + 1; item_pointer++ ))
            do
                case "${Task_Data[item_pointer]}" in 
                    -h | --header)
                        (( item_pointer += 1 ));
                        is_command=false;
                        Meta_Lines+=("header" "${Task_Data[item_pointer]}")
                    ;;
                    -n | --note)
                        (( item_pointer += 1 ));
                        is_command=false;
                        Meta_Lines+=("note" "${Task_Data[item_pointer]}")
                    ;;
                    -c | --comment)
                        (( item_pointer += 1 ));
                        comment="${Task_Data[item_pointer]}"
                    ;;
                    -*)
                        softfail "Unknown argument: ${Task_Data[item_pointer]}" || return $?
                    ;;
                    *)
                        break
                    ;;
                esac;
            done;
            if [ "${is_command}" = true ] && (( item_pointer <= main_pointer + item_length + 1 )); then
                command=("${Task_Data[@]:item_pointer:((item_length-(item_pointer-main_pointer-2)))}");
                if [ "${current_item_index}" = undefined ]; then
                    current_item_index=0;
                fi;
                if [ "${current_section_index}" = undefined ]; then
                    current_section_index=0;
                fi;
                if (( current_item_index > 0 && ${#Meta_Lines[@]} > 0)); then
                    for ((meta_line_pointer = 0; meta_line_pointer < ${#Meta_Lines[@]}; meta_line_pointer+=2 ))
                    do
                        if [ "${Meta_Lines[meta_line_pointer]}" = "header" ]; then
                            (( current_section_index += 1 ));
                            break;
                        fi;
                    done;
                fi;
                task::render::meta_lines "${current_item_index}" || softfail || return $?;
                if [ "${Current_Color:-}" = "${Color_A}" ]; then
                    Current_Color="${Color_B:-}";
                    current_color_accent="${Color_B_Accent}";
                else
                    Current_Color="${Color_A}";
                    current_color_accent="${Color_A_Accent}";
                fi;
                if [ "${Item_Position}" = undefined ] && [ "${Section_Position}" = undefined ]; then
                    Item_Position=current_item_index;
                    Section_Position=current_section_index;
                else
                    if [ "${Item_Position}" = undefined ] && [ "${Section_Position}" = "${current_section_index}" ]; then
                        (( Item_Position = current_item_index ));
                    else
                        if [ "${Section_Position}" = undefined ] && [ "${Item_Position}" = "${current_item_index}" ]; then
                            (( Section_Position = current_section_index ));
                        fi;
                    fi;
                fi;
                enter_marker="";
                if [ "${Non_Interactive}" != true ] && [ "${Item_Position}" = "${current_item_index}" ]; then
                    Selected_Command=("${command[@]}");
                    Selected_Command_Type="${item_type}";
                    selection_marker+="${Current_Color}!${Reset_Attrs}";
                    current_line_color="${current_color_accent}";
                    if [ "${item_type}" = "task-group" ]; then
                        enter_marker=" ${Current_Color}# -->${Reset_Attrs}";
                    fi;
                else
                    selection_marker="";
                    current_line_color="${Current_Color}";
                fi;
                if [ "${Task_Data[main_pointer]}" = "task-group" ]; then
                    command_display_prefix="task::group ";
                else
                    command_display_prefix="";
                fi;
                echo "${Clear_Line}${selection_marker}${Leading_Spacer}${current_line_color}${command_display_prefix}${command[*]}${Reset_Attrs}${comment:+" ${Comment_Color}#  ${comment}${Reset_Attrs}"}${enter_marker}";
                (( Lines_Drawn+=1 ));
                (( current_item_index+=1 ));
            fi;
            (( main_pointer += item_length + 1 ));
        else
            softfail "Unknown operation" || return $?;
        fi;
    done;
    task::render::meta_lines "${current_item_index}" || softfail || return $?;
    if [ "${Non_Interactive}" != true ]; then
        if [ "${Item_Position}" = undefined ]; then
            if [ "${Section_Position}" != undefined ] && [ "${current_section_index}" != undefined ]; then
                if (( Section_Position < 0 )); then
                    (( Section_Position = current_section_index ));
                    task::render;
                else
                    if (( Section_Position >= current_section_index )); then
                        Item_Position=0;
                        Section_Position=0;
                        task::render;
                    fi;
                fi;
            fi;
        else
            if [ "${current_item_index}" != undefined ]; then
                if (( Item_Position < 0 )); then
                    (( Item_Position = current_item_index - 1 ));
                    task::render;
                else
                    if (( Item_Position >= current_item_index )); then
                        Item_Position=0;
                        Section_Position=0;
                        task::render;
                    fi;
                fi;
            fi;
        fi;
    fi
}
task::render::meta_lines () 
{ 
    local current_item_index="$1";
    local meta_line_pointer;
    local spacer_required=false;
    if (( ${#Meta_Lines[@]} > 0)); then
        if [ "${current_item_index}" != undefined ] && [ "${current_item_index}" -gt 0 ]; then
            spacer_required=true;
        fi;
        for ((meta_line_pointer = 0; meta_line_pointer < ${#Meta_Lines[@]}; meta_line_pointer+=2 ))
        do
            if [ "${Meta_Lines[meta_line_pointer]}" = "header" ]; then
                if [ "${spacer_required}" = true ]; then
                    echo "${Clear_Line}";
                    (( Lines_Drawn += 1 ));
                    spacer_required=false;
                fi;
                echo "${Clear_Line}${Header_Color}${Leading_Spacer}# ${Meta_Lines[meta_line_pointer+1]}${Reset_Attrs}";
            else
                if [ "${Meta_Lines[meta_line_pointer]}" = "note" ]; then
                    echo "${Clear_Line}${Comment_Color}${Leading_Spacer}# -- ${Meta_Lines[meta_line_pointer+1]}${Reset_Attrs}";
                    spacer_required=true;
                fi;
            fi;
            (( Lines_Drawn+=1 ));
        done;
        Current_Color="";
        Meta_Lines=();
    fi
}
terminal::color_table () 
{ 
    for i in {0..15};
    do
        echo "$(tput setaf "${i}")tput setaf ${i}$(tput sgr 0)";
    done;
    for i in {0..15};
    do
        echo "$(tput setab "${i}")tput setab ${i}$(tput sgr 0)";
    done
}
ubuntu::pro::available () 
{ 
    ( . /etc/os-release || softfail || return $?;
    test "${ID:-}" = ubuntu && command -v pro > /dev/null )
}
ubuntu::pro::is_attached () 
{ 
    pro status --format json | jq --raw-output --exit-status '.attached == true' > /dev/null
}
ui::confirm () 
{ 
    if [ ! -t 0 ]; then
        fail "Input is not a terminal";
    fi;
    if [ -n "${1:-}" ]; then
        echo "";
        echo "$1";
    fi;
    local user_input;
    IFS="" read -r user_input || fail;
    while [ "${user_input}" != yes ] && [ "${user_input}" != y ]; do
        if [ "${user_input}" = no ] || [ "${user_input}" = n ]; then
            return 1;
        fi;
        echo 'Please enter "yes" or "y" to continue, "no" or "n" to stop.';
        IFS="" read -r user_input || fail;
    done;
    return 0
}
vscode::install::apt () 
{ 
    apt::add_source_with_key "vscode" "https://packages.microsoft.com/repos/code stable main" "https://packages.microsoft.com/keys/microsoft.asc" || softfail || return $?;
    apt::install code || softfail || return $?
}
vscode::install_extensions () 
{ 
    local extensions_list="$1";
    if [ -f "${extensions_list}" ]; then
        local installed_extensions_list;
        installed_extensions_list="$(vscode::list_extensions_to_temp_file)" || softfail "Unable get extensions list" || return $?;
        if ! diff --strip-trailing-cr "${extensions_list}" "${installed_extensions_list}" > /dev/null 2>&1; then
            local extension;
            if [[ "${OSTYPE}" =~ ^msys ]]; then
                local ifs_value='';
            else
                local ifs_value="";
            fi;
            while IFS="${ifs_value}" read -r extension; do
                if [ -n "${extension}" ]; then
                    code --install-extension "${extension}" || softfail "Unable to install vscode extension ${extension}" || return $?;
                fi;
            done < "${extensions_list}" || softfail "Unable to install vscode extensions" || return $?;
        fi;
        rm "${installed_extensions_list}" || softfail || return $?;
    fi
}
vscode::list_extensions_to_temp_file () 
{ 
    local temp_file;
    temp_file="$(mktemp)" || softfail "Unable to create temp file" || return $?;
    code --list-extensions | sort > "${temp_file}";
    test "${PIPESTATUS[*]}" = "0 0" || softfail "Unable to list extensions" || return $?;
    echo "${temp_file}"
}
wifi::connect () 
{ 
    local pass_path;
    while [ "$#" -gt 0 ]; do
        case "$1" in 
            -p | --pass-path)
                pass_path="$2";
                shift;
                shift
            ;;
            -*)
                softfail "Unknown argument: $1" || return $?
            ;;
            *)
                break
            ;;
        esac;
    done;
    if [ -z "${pass_path:-}" ]; then
        softfail "--pass-path should be specified" || return $?;
    fi;
    local password_store_dir="${PASSWORD_STORE_DIR:-"${HOME}/.password-store"}";
    local absolute_item_path;
    for absolute_item_path in "${password_store_dir}/${pass_path}"/*;
    do
        if [ -f "${absolute_item_path}/ssid.gpg" ] && [ -f "${absolute_item_path}/password.gpg" ]; then
            local item_path="${absolute_item_path:$((${#password_store_dir}+1))}";
            local ssid;
            ssid="$(pass::use "${item_path}/ssid")" || softfail || return $?;
            local password;
            password="$(pass::use "${item_path}/password")" || softfail || return $?;
            if nmcli device wifi connect "${ssid}" password "${password}"; then
                return 0;
            fi;
        fi;
    done
}
wifi::is_available () 
{ 
    nmcli --terse device wifi rescan 2> /dev/null
}
wifi::is_connected () 
{ 
    nmcli --terse device wifi list | grep -E "^[*]" > /dev/null
}

# == By now, all required library functions should be available ==

# Option to skip loading the runagfile
if [ "${1:-}" == "--skip-runagfile-load" ]; then
  shift  # Remove the argument from the positional parameters
else
  # Load the rÃ¹nagfile
  if [ "${BASH_SOURCE[0]}" != "$0" ]; then  # Script is sourced
    runagfile::load
    softfail --unless-good --exit-status $? "Error: Failed to load rÃ¹nagfile ($?)" || return $?
  else  # Script is run directly
    runagfile::load
    softfail --unless-good --exit-status $? "Error: Failed to load rÃ¹nagfile ($?)" || exit $?
  fi
fi

# If the first argument is provided, treat it as a command, run it, and then exit or return depending on whether the script is sourced
if [ -n "${1:-}" ]; then
  if [ "${BASH_SOURCE[0]}" != "$0" ]; then  # Script is sourced
    runag::command "$@"
    softfail --unless-good --exit-status $? "Error: Failed to run command $* ($?)"
    return $?
  else  # Script is run directly
    runag::command "$@"
    softfail --unless-good --exit-status $? "Error: Failed to run command $* ($?)"
    exit $?
  fi
fi

# If no command is provided and the script is not sourced, attempt to run runagfile::main or display available tasks
if [ "${BASH_SOURCE[0]}" = "$0" ]; then
  if declare -F runagfile::main >/dev/null; then
    # Call the main function if it exists
    runagfile::main
    softfail --unless-good --exit-status $? "Error: Failed to run runagfile::main ($?)"
    exit $?
  elif task::any && [ -t 0 ] && [ -t 1 ]; then
    # Display tasks interactively if available
    task::display
    softfail --unless-good --exit-status $? "Error: Failed to display tasks ($?)"
    exit $?
  fi

  # If no main function or tasks are available, log an error
  log::error "Error: It seems that no function name or command has been specified. Please define 'runagfile::main' or provide a command."
  log::error "Hint: For easier usage, consider adding tasks to the task list and running interactively."

  exit 1
fi
